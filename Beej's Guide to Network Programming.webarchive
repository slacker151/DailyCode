bplist00”#1_WebSubframeArchives_WebSubresources_WebMainResource¢—’	
_WebResourceFrameName^WebResourceURL_WebResourceData_WebResourceMIMEType_WebResourceTextEncodingName_ <!--framePath //<!--frame0-->-->[about:blankO'…<html><head><style type="text/css">body{margin: 0px; overflow: hidden;} #GINGER_SOFATWARE_menuList ul {list-style-type:none; width:116px; padding:6px 6px 0px 6px; margin:0px; -webkit-margin-before: 0px; -webkit-margin-after: 0em; -webkit-margin-start: 0px; -webkit-margin-end: 0px;} #GINGER_SOFATWARE_menuList ul li {font:12px/18px tahoma; color:#484848; cursor:pointer;} #GINGER_SOFATWARE_menuList ul li:first-child {font-weight:bold;} #GINGER_SOFATWARE_menuList ul li:hover {color:#000;} #GINGER_SOFATWARE_menuList #GINGER_SOFATWARE_separator{background:#e5e5e5; border-top:3px solid #ffffff; border-bottom:3px solid #ffffff; width:100%; height:1px; cursor:default; line-height:0px; font-size:0px;} #GINGER_SOFATWARE_menuList #GINGER_SOFATWARE_ignore {color: transparent;height:15px; margin-bottom: 3px; background:url("data:image/gif;base64,R0lGODlhHwAeAMQAAJiYmNjY2BEREaamptLS0oeHh+3t7fj4+Lq6uuXl5dzc3PHx8b+/v1VVVXd3d8zMzDMzM7Ozs0RERN/f37m5uampqevr68vLyyIiIq2trcbGxqCgoGZmZgAAAP7+/gAAACH5BAAAAAAALAAAAAAfAB4AAAX/oPZ4ZGmeaOpljOq+ZKbBNCrXeDynCbW4iV8iYbp5CBrNYjHJbAgkS4A01Wwej82zdGMMIpuAdXALDAaMxIaylTEypYhmEh6ErUh4hEHYLLQUMRksHnxJAWtOAV4HBAMHMg+PTkRHGwwLDxkHGhELGQN0AXIeagkadjOoByV9GwNEAVAHrBkBrFQ/D1AeC1MmUrgkvh4HA785KpATpskvfQOBzi8Tt9MoHA7XLxgN2y4YHN8q4eMp5SkIEgouCOwICCboBRwcCgoVGB0FJBcAJP84dHDgoMO+EuUaCIDQAYBAAeUACBDQAEEHCQfDNcBQAgKHCg0FNBRIjyOEBgU6ZCgwKIEEhpfeUNYDcFEfAIUGCggwEM7BTn3xPKRsoMABBgMcICjAIAAkAI8eLCLgIFIcVQMlUnYQEA8APwNYMQDACpCdA34eFPwz4Y8sCbUeDAhYa45nBanmsm5tmbdEhbF5QwAAOw==") 0 0 no-repeat #ffffff; overflow:hidden;} #GINGER_SOFATWARE_menuList #GINGER_SOFATWARE_ignore:hover {background-position:0 -15px;} #GINGER_SOFATWARE_menuList ul li #GINGER_SOFATWARE_contact {display:block; height:19px; font:11px/18px tahoma; color:#fff; text-decoration:none; text-align:center;} #GINGER_SOFATWARE_menuList ul li #GINGER_SOFATWARE_contact:hover {background-position:left bottom;} #GINGER_SOFATWARE_menuList ul li #GINGER_SOFATWARE_contact strong {font-size:12px; color:#fff;} #GINGER_SOFATWARE_menuList{border:2px solid #8ed231; background:#ffffff url("data:image/png;base64,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") left bottom repeat-x;} #GINGER_SOFATWARE_menuList.GINGER_SOFATWARE_menuContact{background-image: url("data:image/png;base64,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");}</style></head><body ginger_sofatware_stylesheet="true"><div style="border-top-left-radius: 8px 7px; -moz-border-top-left-radius: 8px 7px; border-top-right-radius: 8px 7px; -moz-border-top-right-radius: 8px 7px; border-bottom-left-radius: 10px 19px; -moz-border-bottom-left-radius: 10px 19px; border-bottom-right-radius: 10px 19px; -moz-border-bottom-right-radius: 10px 19px;" id="GINGER_SOFATWARE_menuList"><ul></ul></div></body></html>Ytext/htmlUUTF-8“¢‘	
_WebResourceResponse_1http://cdn.gingersoftware.com/webWidget/GIcon.svgO bplist00‘^_X$versionX$objectsY$archiverT$top Ü†Ø"()012FGHIJKLMNOPQRSTWXYU$null›	
 !R$6S$10R$2R$7R$3S$11R$8V$classR$4R$9R$0R$5R$1ÄÄÄ ÄÄÄÄÄ”#$%&'WNS.base[NS.relativeÄ ÄÄ_1http://cdn.gingersoftware.com/webWidget/GIcon.svg“*+,-Z$classnameX$classesUNSURL¢./UNSURLXNSObject#AΩG˚ím&»”345=EWNS.keysZNS.objectsß6789:;<Ä	Ä
ÄÄÄÄÄß>?@ABCDÄÄÄÄÄÄÄÄVServer\Content-TypeWX-Cache]Last-Modified]Accept-RangesTDate^Content-Length_ECAcc (mdw/BBCC)]image/svg+xmlSHIT_Mon, 15 Sep 2014 06:39:39 GMTUbytes_Tue, 26 Jul 2016 02:27:08 GMTV105603“*+UV\NSDictionary¢U/ úÉ]image/svg+xml“*+Z[_NSHTTPURLResponse£\]/_NSHTTPURLResponse]NSURLResponse_NSKeyedArchiver—`a_WebResourceResponseÄ    # - 2 7 U [ v y } Ä É Ü ä ç î ó ö ù † £ • ß © ´ ≠ Ø ± ≥ µ ∑ π ª ¬   ÷ ÿ ⁄ ‹ )/28AJLS[fnprtvxz|ÑÜàäåéêíîõ®∞æÃ—‡Û%+KRWdglzìó´πÀŒ‰             b              ÊO úÉ<?xml version="1.0" encoding="utf-8"?>
<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<!DOCTYPE svg [
	<!ENTITY ns_flows "http://ns.adobe.com/Flows/1.0/">
	<!ENTITY ns_extend "http://ns.adobe.com/Extensibility/1.0/">
	<!ENTITY ns_ai "http://ns.adobe.com/AdobeIllustrator/10.0/">
	<!ENTITY ns_graphs "http://ns.adobe.com/Graphs/1.0/">
	<!ENTITY ns_vars "http://ns.adobe.com/Variables/1.0/">
	<!ENTITY ns_imrep "http://ns.adobe.com/ImageReplacement/1.0/">
	<!ENTITY ns_sfw "http://ns.adobe.com/SaveForWeb/1.0/">
	<!ENTITY ns_custom "http://ns.adobe.com/GenericCustomNamespace/1.0/">
	<!ENTITY ns_adobe_xpath "http://ns.adobe.com/XPath/1.0/">
]>
<svg version="1.2" baseProfile="tiny" id="G_icon_normal" xmlns:x="&ns_extend;" xmlns:i="&ns_ai;" xmlns:graph="&ns_graphs;"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
	 x="0px" y="0px" width="473px" height="455px" viewBox="0 0 473 455" xml:space="preserve">
<switch>
	<foreignObject requiredExtensions="&ns_ai;" x="0" y="0" width="1" height="1">
		<i:pgfRef  xlink:href="#adobe_illustrator_pgf">
		</i:pgfRef>
	</foreignObject>
	<g i:extraneous="self">
		<g id="BG">
			<linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="227.4995" y1="1.001" x2="227.4995" y2="455.0005">
				<stop  offset="0" style="stop-color:#FFFFFF"/>
				<stop  offset="0.2712" style="stop-color:#FBFBFB"/>
				<stop  offset="0.5631" style="stop-color:#EEEEEE"/>
				<stop  offset="0.8635" style="stop-color:#D8D8D8"/>
				<stop  offset="1" style="stop-color:#CCCCCC"/>
				<a:midPointStop  offset="0" style="stop-color:#FFFFFF"/>
				<a:midPointStop  offset="0.6921" style="stop-color:#FFFFFF"/>
				<a:midPointStop  offset="1" style="stop-color:#CCCCCC"/>
			</linearGradient>
			<circle fill-rule="evenodd" fill="url(#SVGID_1_)" cx="227.5" cy="228" r="227"/>
		</g>
		<g id="ray">
			<path fill-rule="evenodd" fill="#2BAABE" d="M353.809,39.146c53.782,44.808,88.058,112.572,88.058,188.407
				c0,75.514-33.99,143.018-87.38,187.83c69.991-33.26,118.426-104.912,118.426-187.958
				C472.912,144.107,424.164,72.263,353.809,39.146z"/>
		</g>
		<g id="G_xA0_Image_1_">
		</g>
		<g id="Layer_4">
			<g>
				
					<image opacity="0.2"  a:adobe-blending-mode="multiply"  a:adobe-opacity-share="1" width="326" height="327" xlink:href="data:image/png;base64,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
PKNWe1YAAAAASUVORK5CYII=" transform="matrix(1 0 0 1 57 72)">
				</image>
				<g>
					<linearGradient id="SVGID_2_" gradientUnits="userSpaceOnUse" x1="220.0444" y1="76.1084" x2="220.0444" y2="371.9106">
						<stop  offset="0" style="stop-color:#2BAABE"/>
						<stop  offset="1" style="stop-color:#0C7984"/>
						<a:midPointStop  offset="0" style="stop-color:#2BAABE"/>
						<a:midPointStop  offset="0.5" style="stop-color:#2BAABE"/>
						<a:midPointStop  offset="1" style="stop-color:#0C7984"/>
					</linearGradient>
					<path fill-rule="evenodd" fill="url(#SVGID_2_)" d="M367.227,209.265H227.257v33.963h105.391
						c-12.133,60.006-60.279,94.725-112.213,94.725c-58.764,0-114.114-47.171-114.114-113.971
						c0-66.039,53.834-113.965,114.114-113.965c25.396,0,55.348,10.566,78.472,32.077l22.174-26.052
						c-26.445-24.752-61.959-39.933-101.033-39.933c-81.693,0-147.92,66.226-147.92,147.922c0,78.87,61.731,143.301,139.512,147.663
						c2.893,0.141,5.824,0.217,8.796,0.217c2.482,0,4.958-0.058,7.423-0.171c78.061-4.063,140.104-68.637,140.104-147.709
						C367.962,219.046,367.705,214.121,367.227,209.265z"/>
				</g>
			</g>
		</g>
	</g>
</switch>
<i:pgf  id="adobe_illustrator_pgf">
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	+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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
Zud9WURRX/lRGQrmYwd2bliBtxAOjEYaurFHUNTIoVGJmx6qcneYhJT/kDz+34ScTzKzcXLrFEh0
nDZ32bptzMo4545kVYHJLG+fP7h54cT+zctnjBnYK4B0dPCoqFBXJDVOc822lu06hcQlT56/Zmde
YaUichPVzx+II145e+LQ7s3Mfq2YnkRDUwMdfKysIXeAWXRZRpU/glhJVsg6zFk5HQNTa6RjUFj0
wOTx6WTLVf6ZizewO7KjIx6sf/v49sXD0ouncretnD0+KTLIw95Eu0WTerUUOCpiEf+F0jOqts2d
fbrHDJ2YkbnjEC62vyAi0woljlh0dN/2dUtmTx6ZhLdWuzsjDZmjefjs8s+SEn7zG5MQEh/BbtAI
nzlkdewZw2z/25yTd/Kc2B3xmu1vKD3jGfShHavnpg6J7urtaKbbqikbz4pRkRkUcXrWNXXwCo4a
PGHOqm0HT31BRFRH/CVqy587cWhX1sp508YO6de7G97mb4Y0VG+GQpk9bvtjB+lF98uQM8Tk/KsG
0tHGyd2X2Yo6Z+n6HfvzT19EoyNJ1r//juai714+unP59OHstfMnDYsN6ejMLBcoMA==
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	1dx+zqZt1BrwkFy4h1Xjm8w12ui2NTQ2NTMzh8LMzNTYsK1uGw1ye3s5GdEbZQodNIuOGzVrTU7B
pbJn7z5Jp2gyc7l2OjdrYWpiTy65KHxY5J4931hNQ1vf2NwaP57SpT0ULu2cHOyszY31tZmrdiUO
VXC9iLY25QsdqeSCUjSeuexbnzEuvoeXHWlFKDy5cM+KaqyuqWdsaY8fpOjr3zmgCwwBnf19O3q6
trO3NNbTVG9cX/JZJqJy0c6rx4Bx8zbsL8SFjvQs+u8/UYouu3QiZ83s0WjmYq3fio/kQjb41qrX
SE1T39S2nYdvYLfQ8IjIPlHREET1iYwID+0W6OvRztZUX1OtUT2JbZtYRVwuGtn7hCVMWJDF9iIk
Cx3R/K8kf9eqGSkxQa6WemjmwsNjgskRHPyEHlO7Dh2DwiLjBiQNHpo8fPjwFL5BvzN56OCkAXGR
YUEdO9iZ6mmQI7hcNJK1aLJc0Kln0kRcLrKN7nKFDt5xx8z/0pL7BLQ3Ryla8Q2dGty9rtrGth18
u0X0H5wyNnXKtLT06RCkp02bkjo2ZXD/iG7khuVyG7G5otvEybfXoMlLtuQVV+josLPoRzfPHt62
dOoQNP/DKVrxM5ca7Jk6DX3Ldh27RSWkpKbNWbB42YqVK1fxz8qVK5YtXjAnLTUlIapbx3b4qW0S
21+JirjodvbrPWQKLrpLKxbdWEVc6BzasnjSoF6+TiZafKRopk9CriT1CIpIGDVl7pLVGzZv27Ez
O3sX32Rn79yxbfOG1UvmTsGXF3vYG5d7Oq3E1AWv6G8/cq5UetGFlIu4RXs6d9PCVDyLNmrNx2oB
Wz600DVv5xvWP2XKvJVZO/fm5h05lp+ff5xf0G88diQvd+/OrJXzpqT0D8PHfFpIJFisIunRunTu
MyxtOTt1KV9043KR6UVsnD9+QKi3nSEzi+YhueB18rbWroGRg1PnrtyyJ6+gsPjchQslJSUX+QT9
vgsXzhUXFuTt2bJyburgyEBX63INVk5Fcxc0AUxfsfMY3hfxqYKKn9+/YMrFsfEhnrZtWzXho9Ah
QzZeEPLshu8Mz9pDnnRTeuv2Hf65fav0+uXzhUf3ZC1JS4nr5mlnqNlUPKqx6wV4Gh2VnL6SqCi9
LwKr+O753csn966bM6ZfNw8bnspFsmW/uZaxQ8fQAWPnrN6ZV3jxxp37jx4/eco/Tx4/un/nxsXC
vJ2r54wdENoR7yMW9wbFzYguUcOnr8zOL7n9tIKKfzMqntiDlwu6ulvrt2zMQ6NbNGQ7+YYnpeKL
487j50y+fP3mLf+8ef3y+eO7N84X7N2wIDUp3NfJtE3zBrJUjB4+fVW2uBlRcepSkJM5a2RcsJsV
X0U3O2S3848YPGXx5tzCy3cev3z7/sPHT/zz8cN7/CTBy4W5mxdz3f4Gtb9DxYsFuzNnjoxFUxfd
Fo14WEUVLU66dCYbAvPw9XtvP3z67fc/+Of33z59ePv8PtnUPm1oZGcXouLP36Qi7nTfuXh89+qZ
I2KIinwsurCHcESdT1SE4edR/P7nX3/zz1/kivxHpeeOiOZvEitPkiqmTJdsL5ZXES+jHt+1Gk2j
AztY6KrzpyI7ZJPEh3eb44dukWcY88p/yNNX8J65YztXpg+P6iKeBctS8fgXVVw1IyUaqajDt4rR
JPFxm1O5x5LzyP9jTu89uX0hP3vl9OHRX1PxokBVFA82Uk/d4oP/khsnmb5W9iqlVbH8YMO3iFLd
wekpP6gifgEoFWUMNjzKyKl4XA4qQvqijLfGv4oXqYr8qSjMHK1kKgqzXlSmcVGQcxdh5Oj/VT1H
C3EeLYx6UVLFr9WLwuvp8D93+WEVBdhf5Hke/QUlq6CiYHvdvPZ0/sNYR7aOrIq3S8g8WkY3Qrzu
kiawdRf++ot/Yv7662/i57JkZFR8cpv0dJKjSGesQQUVBbkGyGOv+/Pnz78h8yAp/5alIzOPfkNU
JP1FF3OpXrdg16P5W3d5h3j/KzLP59/+IDrKVPHjmyfMRthhfdhet1hF4e6N4G0N8Bni+YuXr968
+/Xjp9/+kCEjt5249NyR7XjFAO+yKbd6JblPZ7Gg9unwtx5dVnb33v2Hj58+f/X2/cfPf/xZQUZO
g1KswZQhZDsxVvEfYhXJnjGHjj0TJy7ahI8YCGXPGI97Iy5dvnLtxq2y+4+fv3r34fMff0lPkNh4
fHSzOG/L4skV4pHbv8gcd8EH9a/dlzpLCbV/kcd9OgUnThaePlty5cadB09evsUySjkjkxtePbx+
5uCmRRO5Tdk1JVVkjl55hcSz53orHhoC2UvL356x3Tl79h04dLSg6PyV0ntPXr77KP3IOW5r+/1r
5NzUwFAfe0PNpuI6Rbyv26Nbv9Fz1u6ReYANZF83b/sXV2euWbs+a2v23ryCMxdv3nuKHzde/hEY
5WvmcfHMuSmJPWPkjEEj5hqYkTNln9SHOWPA017aGTNmzJw9d96i5ZlZO/cfO32p9IGs5xOTWfAz
PAteO2c0nr+1lQzHGuxslbk1YjozBZQuu4HOu/C1r3vEyNFjJ0yZnrF07bZ9+cVXyyo+oPi/4h4r
6WvhjkxLfChXdMig/DyrsrIb4uwVT2cMYmLj+g1IGjZq4sxFa7bnniwpffhSxlOqmKIbTwBxM0Lc
7xepSGpbEyc/tmC88fDVB+lSB+QcYA0+zrsEBgYGde0e1jtmYPL4GUs27D529rqMJw9w5eK5w8w2
nfKbncQFo5EDvpNoYZbsayNgzqTycPaqQ4cOrm4eXp26dI/onzxx7qrth05fvSvz0nxyQPyMePrW
XPJos+h+LDuvHvHj5olKnQq9MYDz0TUUfg7QAmFpbevQzt23a8TAUdOXbj5w6nLZ07cVb5MlDZlr
rAA+Dkaa5VoJ4ut0PLr1HT17Tc4JchBQusMIc1a/Bg9nUnX12hqaWjq4+vWIS56yCD8DUZaKf4ta
rHPHcoWORFuLLXVa6OFDqSPIodTb6FWEcW9EDR7OR7doqaGla2jh6BnUZ8ikBRsYFSu9lGk3XjRh
2v2SiaGGqDHvEsB2GEulr1OVfBV+7zCpofCz+o0aN2mmrqFjbOvWJWIQ86Cqu9IXoTJFCpuiiReR
W9YkixRRG8/Zr/dgcvpK1mVtUPfpKPzeCGSchk3UtQysOwREDJ4kuvBdxtVWryS6WuV20jIqMhcH
oiQdhi8O5O5TFcjdToq+w+SXmrXrNmyu2dbKlTy/b8uhM9cfvKxwKFc0edu0cGJSeCdHY+kOq+Ql
lvFjM9azJ6T/qGgMWfeM8XMXjOLu0/kXrgEaNNNsa+0WFDM8fQWadeAGa2WhiGfRA3p427G9CAkV
uXum8Wn9Sq8lkrzzbkz/7l62hpr83XmnuLud8GDxS+0G5Am7+CmIMq/NL59cmLVk6aZWDfH9i12i
ktNXyEovEvcvooIpNTG8kxN7QzJf17Up6Maw/+Oe3m7i2CksYfw8/KSquxUKPfEMeOcK2clFNJNm
0gseGZib42XcBUoqRjQFGtani+guUGW+gLFGDfZZki10ybX5omGx0qutti6ZIjO5SKWXCQs24iwl
+15asjt81+pZ5OZ4AxW4aLoGc+F7E/wsya74fuidx86z1+ZX6K+yU7fUhJ4dHWV0BsXpBV/AMWet
rKvj/yuaSuOnGExI6IlDWk3pLz1nGsEN2HXGcRnr9lZybT5z4fuJL7QRmM48btTiK3WmsxtiZN7X
jWsd5nrfLh14zNIKQzKgI4ZMWbwZP0vyC3GIL3xnmosVWlrc7IW0GCt9pAb3MAgmpPt1x2dblf5h
ENzDYQ1sPLrGMQHNLsfLGBZxzY3bYgEuMtdA2adeMY93SWUGxueVPMcAh/RGVXkwCfcsyTYmTuiT
j5+HamV2Ei3j2vz714pys0jN7UTuh5ZOCZIDY7/RzLPDpBsSopC+oUIPySn/4PGpS3GG/sJzMPCw
iBs6djJrZdFjr5jn2KGK8Zxsv0Yh/YR5YNNYVXhgE5tbyIPHQ/qNnrV6V/4FGRmaa2hdOMYNizI7
/TVEz1Rs59978GQ8xl5/INskooeHDVGBh4dxuUXHHH3uyvo5Utfmk+dgyN4awj3f08jBB+d7PJWW
/Ziccg+y81TyB9nV4J5TjHNLbMr0cg8eL+89ZBJduH8jqfGY52BUHMmY8aFJK1x7xo2cKfHIJlV+
qCLjiqg2MUW5ZeB48uBxNIeWFdC4zkEjWebsL12bz1aMLZhHcONaR9Y8SPoBn8EetgZK/IBPxhXr
Id+xdguMGjZtKX7wuMyHw/7J1jnb8TJyICmUZfX5a7CPg9cyYR5lx8zJZQwQsh42q6zFDuuKuBHh
Exo/Zk4myi2lj2Q+S5Lrw6A6p5cv3tIgu7Uq8VjFbn1HVZ6suAcfH8QPPo4OEj34WAmdkdm/glxR
H5U5kUMmL950oPCK7DVUEtBsT5DUOZW0+UUzIQtUOCHnRtOXiiFd4SHcYZ2cTLXVldQZOVdEU2jv
kP6ozNl59NxNNGX7/KeMnPqSCWjSn+bqHBkqct0xUsRPED8Q/m+ZD4S/UpS7ecnUYVFBbsgZmyql
M4pGRT3L9mTBBZc5ZU8rPKeYre/uXmED2s/5C2slogklDumRM1dnMx2i3yq85J+fkTOWnj+2K3PO
2AGsMyrjY7jFrmjvHdJv1MyVO46Iy5yK7QM2Q5OArnzdThzSJEsv2XJI3NyQHiSwMxZKOKMyPhJe
5Ir6lu07kxXUfScv3ZFR5kjUJcumoQztavWFVhaXpVHC6hiGa6e9Jy7dkenfyBnRKCFyRpymJW/F
VA5qiBI0HhX7jZyxcsfhYjJfq1iWILd5WnYZ18gTEvHNWExAy/YaLqSZpu905ODnKj4TXvSqnDOy
aRrNppUrwTB7+uo31dC3wsvQExds2HsCVdzSQxhXLD4iz5JE8zXycNimlS/Ei+eULmhOOWkRyfuk
BP3Pfyt4OOOMa+aMG9gT3+fYsnE95XJGdpduIzRtcfTpQUZF5Ir3X8jYcMf2DooObl48hfQOvvhw
WK533trI3rtH/zGz1+xmSsaKxhE7I6oZY7p62BlpqbF9RmWRkeyhqt2gmaaBtVuXPkNQgt7HuuKf
FT8tO89YOxdfGOjI9rEq+6yk8EZzaX0rVzIf2sr22ipuKiUjY+n5/N1rM8Yn9vJ3sdRvRaodpYlp
tuBu3FLHzLlTaPzoWat2HuFcUUbkcXPe4TFBbswVoJX3VPFc+mc03qK5uS8qGeetRyPFnSfS+UWc
ppGTb12WPqJvd28HE1ztKE9Mc6mluZaRrUdw9LApi7P24wTNumKl/ZdEXCzqfGWWIeoT2eI1iOmV
FVCimvHC8T3r508cHNnF1dpAs3kD5YlpvEMXp5ZWehYufuEJ4+ZkZh89d+OBbFck8xZxL/Cra03E
QuSok0tnlF8WZu0X7SqV5Yz3rp3J275y5uh4VO2Y67Zqwsa08GUUpxYTB+/ucSlpSw==
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
	<![CDATA[
	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
	]]>
</i:pgf>
</svg>
]image/svg+xml‘	
_ data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4MTBCMkFFNTYzN0JFMjExODkxMTkyQTZFREJBQTVFNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4QjcyRkJCQTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4QjcyRkJCOTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJGM0ZBMTRFMkI3Q0UyMTE5QUJEQUNBRUIwMjA3MkI5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjgxMEIyQUU1NjM3QkUyMTE4OTExOTJBNkVEQkFBNUU1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+82nfLAAAAHdJREFUeNpibGlpSWMAgurq6lkMUNDa2loOpASZgIQxEM+ECsAkOoD4PeP///9BAjOBHJAJq4E4FIgrgCZ1giWhOnYDKReQAqBEGEiMCckokMQekE6YFcysrKwwO0BGpR8+fFgKyC4H0s+ZkO2AujodSIFdDhBgAKb9MWw+NbSPAAAAAElFTkSuQmCCO¡bplist00‘67X$versionX$objectsY$archiverT$top Ü†´%&-./012U$null€	
R$3V$classR$6R$1R$9R$4R$7R$2R$5R$0R$8ÄÄ
Ä Ä	ÄÄ ÄÄ” 
!#$WNS.base[NS.relativeÄ ÄÄ_ data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4MTBCMkFFNTYzN0JFMjExODkxMTkyQTZFREJBQTVFNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4QjcyRkJCQTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4QjcyRkJCOTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJGM0ZBMTRFMkI3Q0UyMTE5QUJEQUNBRUIwMjA3MkI5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjgxMEIyQUU1NjM3QkUyMTE4OTExOTJBNkVEQkFBNUU1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+82nfLAAAAHdJREFUeNpibGlpSWMAgurq6lkMUNDa2loOpASZgIQxEM+ECsAkOoD4PeP///9BAjOBHJAJq4E4FIgrgCZ1giWhOnYDKReQAqBEGEiMCckokMQekE6YFcysrKwwO0BGpR8+fFgKyC4H0s+ZkO2AujodSIFdDhBgAKb9MWw+NbSPAAAAAElFTkSuQmCC“'()*Z$classnameX$classesUNSURL¢+,UNSURLXNSObject#AΩG˚w'Yimage/pngG#Ôˇˇˇˇˇˇ“'(34]NSURLResponse¢5,]NSURLResponse_NSKeyedArchiver—89_WebResourceResponseÄ    # - 2 7 C I ` c j m p s v y |  Ç Ö á â ã ç è ë ì ï ó ô õ ¢ ™ ∂ ∏ ∫ ºäèö£©¨≤ªƒ∆–”‹·ÔÚ +             :              -OGâPNG

   IHDR         ƒRW”   tEXtSoftware Adobe ImageReadyq…e<  fiTXtXML:com.adobe.xmp     <?xpacket begin="Ôªø" id="W5M0MpCehiHzreSzNTczkc9d"?> <x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 5.3-c011 66.145661, 2012/02/06-14:56:27        "> <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"> <rdf:Description rdf:about="" xmlns:xmpMM="http://ns.adobe.com/xap/1.0/mm/" xmlns:stRef="http://ns.adobe.com/xap/1.0/sType/ResourceRef#" xmlns:xmp="http://ns.adobe.com/xap/1.0/" xmpMM:OriginalDocumentID="xmp.did:810B2AE5637BE211891192A6EDBAA5E5" xmpMM:DocumentID="xmp.did:8B72FBBA800211E2A4CC9051EFC5CE70" xmpMM:InstanceID="xmp.iid:8B72FBB9800211E2A4CC9051EFC5CE70" xmp:CreatorTool="Adobe Photoshop CS6 (Windows)"> <xmpMM:DerivedFrom stRef:instanceID="xmp.iid:BF3FA14E2B7CE2119ABDACAEB02072B9" stRef:documentID="xmp.did:810B2AE5637BE211891192A6EDBAA5E5"/> </rdf:Description> </rdf:RDF> </x:xmpmeta> <?xpacket end="r"?>Ûiﬂ,   wIDATx⁄bliiIc ÇÍÍÍYP–⁄⁄Z§ôÄÑ1œÑ
¿$:Ä¯=„ˇˇˇA3Åê	´Å8à+Ä&uÇ%°:v)ê†DHå	…(êƒêNòÃ¨¨¨0;@F•>|X
».“œôêÌÄ∫:HÅ]` ¶˝1l>5¥è    IENDÆB`ÇYimage/png’	
 !"_ <!--framePath //<!--frame1-->-->[about:blankOƒ<html><head><style type="text/css" id="GINGER_SOFATWARE_style">body {margin:0px; overflow: hidden; text-align:center;} #GINGER_SOFATWARE_correctionControl{position:absolute; margin:0px; padding:0px; height:0px; width:0px;} #GINGER_SOFATWARE_phraseBubble{margin:2px; margin-top:9px; -moz-box-shadow:0px 0px 3px 0px #808080 ;;-webkit-box-shadow:0px 0px 3px 0px #808080 ;;box-shadow:0px 0px 3px 0px #808080 ;;background:#fafafa; border:1px solid #fafafa} #GINGER_SOFATWARE_phraseBubbleContent{float:left; position:relative; white-space:nowrap; background-color:#ffffff;filter:-ms-filter:background-image:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#ffffff), to(#e9e9e9));background-image:-webkit-linear-gradient(top, #ffffff, #e9e9e9);background-image:-moz-linear-gradient(top, #ffffff, #e9e9e9);background-image:-ms-linear-gradient(top, #ffffff, #e9e9e9);background-image:-o-linear-gradient(top, #ffffff, #e9e9e9);padding:1px 10px; cursor:pointer; border-left:1px solid #ffffff; border-right:1px solid #dfdfdf;} #GINGER_SOFATWARE_phraseBubbleContent:hover{background:#ffffff;} #GINGER_SOFATWARE_iconBtn{float:left; border-right:1px solid #dfdfdf; padding-right:3px; background-color:#ffffff;filter:-ms-filter:background-image:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#ffffff), to(#e9e9e9));background-image:-webkit-linear-gradient(top, #ffffff, #e9e9e9);background-image:-moz-linear-gradient(top, #ffffff, #e9e9e9);background-image:-ms-linear-gradient(top, #ffffff, #e9e9e9);background-image:-o-linear-gradient(top, #ffffff, #e9e9e9);cursor:pointer;} #GINGER_SOFATWARE_iconBtn:hover{background:#ffffff;} .GINGER_SOFATWARE_ignoreAll{float:left; position:relative; padding:1px; min-width:15px; background-color:#ffffff;filter:-ms-filter:background-image:-webkit-gradient(linear, 0% 0%, 0% 100%, from(#ffffff), to(#e9e9e9));background-image:-webkit-linear-gradient(top, #ffffff, #e9e9e9);background-image:-moz-linear-gradient(top, #ffffff, #e9e9e9);background-image:-ms-linear-gradient(top, #ffffff, #e9e9e9);background-image:-o-linear-gradient(top, #ffffff, #e9e9e9);cursor:pointer; border-left:1px solid #ffffff;} .GINGER_SOFATWARE_ignoreAll div{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAYAAADgkQYQAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4MTBCMkFFNTYzN0JFMjExODkxMTkyQTZFREJBQTVFNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4QjcyRkJDMjgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4QjcyRkJDMTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJGM0ZBMTRFMkI3Q0UyMTE5QUJEQUNBRUIwMjA3MkI5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjgxMEIyQUU1NjM3QkUyMTE4OTExOTJBNkVEQkFBNUU1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+a0ZSxgAAAJtJREFUeNpibGlpEWRgYEirrq7uZEACra2tIPFVQLyHCaQAiDuAgjPRFOwGYhcgVmL8//8/A1QBSPEsIK6AKjAG8YE2pIMVQXXDFL4HYkGYApAcE5IzKpAU3IMpgCtCcgNYAcgdyG5kZmVlFURzg+vhw4elQFaDaDs7uy3MTk5Om4ECNshuAEkgKfwBUnQNJIHsBiSFP0CaAQIMALKdR/2/gB/zAAAAAElFTkSuQmCC) no-repeat center center;} .GINGER_SOFATWARE_ignoreAll:hover{background:#ffffff;} .GINGER_SOFATWARE_wordCorrection{color:#1b8697;} .GINGER_SOFATWARE_ignoreWord{position:absolute; height:0px; width:0px; top:3px; border:2px solid #ffffff; background-color:#ffffff; cursor:pointer; -moz-box-shadow:0px 0px 3px 0px #808080 ;;-webkit-box-shadow:0px 0px 3px 0px #808080 ;;box-shadow:0px 0px 3px 0px #808080 ;;-moz-border-top-right-radius:5px 5px; border-top-right-radius:5px 5px; -moz-border-top-left-radius:5px 5px; border-top-left-radius:5px 5px; -moz-border-bottom-right-radius:5px 5px; border-bottom-right-radius:5px 5px; -moz-border-bottom-left-radius:5px 5px; border-bottom-left-radius:5px 5px; } .GINGER_SOFATWARE_phraseBubbleTestSpan{position:absolute; top:0px; left:0px; z-index:-1; visibility:hidden; font-weight:bold; white-space:nowrap;} .GINGER_SOFATWARE_ignoreAllHover #GINGER_SOFATWARE_phraseBubbleContent{color:#848484;} .GINGER_SOFATWARE_unselectable{-moz-user-select: none; -khtml-user-select: none; -webkit-user-select: none; -o-user-select: none; user-select: none; }</style></head><body ginger_sofatware_stylesheet="true" class="GINGER_SOFATWARE_unselectable"><div id="GINGER_SOFATWARE_correctionControl"><div id="GINGER_SOFATWARE_phraseBubble"><div id="GINGER_SOFATWARE_iconBtn"><img id="GINGER_SOFATWARE_iconObject" src="http://cdn.gingersoftware.com/webWidget/GIcon.svg"></div><div id="GINGER_SOFATWARE_phraseBubbleContent"></div><div class="GINGER_SOFATWARE_ignoreAll"><div>&nbsp;</div></div><span class="GINGER_SOFATWARE_phraseBubbleTestSpan"></span><div style="clear:left"></div></div><img class="GINGER_SOFATWARE_ignoreWord" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4MTBCMkFFNTYzN0JFMjExODkxMTkyQTZFREJBQTVFNSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4QjcyRkJCQTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4QjcyRkJCOTgwMDIxMUUyQTRDQzkwNTFFRkM1Q0U3MCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M2IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkJGM0ZBMTRFMkI3Q0UyMTE5QUJEQUNBRUIwMjA3MkI5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjgxMEIyQUU1NjM3QkUyMTE4OTExOTJBNkVEQkFBNUU1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+82nfLAAAAHdJREFUeNpibGlpSWMAgurq6lkMUNDa2loOpASZgIQxEM+ECsAkOoD4PeP///9BAjOBHJAJq4E4FIgrgCZ1giWhOnYDKReQAqBEGEiMCckokMQekE6YFcysrKwwO0BGpR8+fFgKyC4H0s+ZkO2AujodSIFdDhBgAKb9MWw+NbSPAAAAAElFTkSuQmCC"></div></body></html>UUTF-8£$)-‘	
%&'(_;http://beej.us/guide/bgnet/output/html/singlepage/bgnet.cssOsbplist00‘noX$versionX$objectsY$archiverT$top Ü†Ø#"()012NOPQRSTUVWXYZ[\]^_`abcdghiU$null›	
 !R$6S$10R$2R$7R$3S$11R$8V$classR$4R$9R$0R$5R$1ÄÄÄ Ä Ä"ÄÄ!Ä”#$%&'WNS.base[NS.relativeÄ ÄÄ_;http://beej.us/guide/bgnet/output/html/singlepage/bgnet.css“*+,-Z$classnameX$classesUNSURL¢./UNSURLXNSObject#AΩGp|1»”345AMWNS.keysZNS.objects´6789:;<=>?@Ä	Ä
ÄÄÄÄÄÄÄÄÄ´BCDEFGHIJKLÄÄÄÄÄÄÄÄÄÄÄÄVServer\Content-TypeTVary]Last-ModifiedTEtagTDate]Accept-Ranges_Content-Encoding^Content-LengthZKeep-AliveZConnectionVApacheXtext/css_Accept-Encoding_Wed, 08 Jun 2016 22:31:20 GMT_"c4f-534cbdd5a42fe"_Tue, 26 Jul 2016 02:27:29 GMTUbytesTgzipS759_timeout=2, max=100ZKeep-Alive“*+ef\NSDictionary¢e/ˇˇˇˇˇˇˇˇXtext/css“*+jk_NSHTTPURLResponse£lm/_NSHTTPURLResponse]NSURLResponse_NSKeyedArchiver—pq_WebResourceResponseÄ    # - 2 7 ] c ~ Å Ö à ã é í ï ú ü ¢ • ® ´ ≠ Ø ± ≥ µ ∑ π ª Ω ø ¡ √   “ ﬁ ‡ ‚ ‰"'2;ADJS\^emxÑÜàäåéêíîñòö¶®™¨Æ∞≤¥∂∏∫ºæ≈“◊ÂÍÔ˝*5<EWwç≠≥∏º—‹·ÓÒ˙ 4BTWm             r              oOObody {
	background-color: white;
	color: black;
	font-family: "Times New Roman", "Times", "Georgia", serif;
	font-size: 12pt;
	margin: 35pt;
	margin-top: 10pt;
	margin-bottom: 10pt;
}

#adsense {
  float: right;
  margin-top: 20px;
  margin-left: 20px;
}


*.joetable {
	border-width: 1px;
	border-style: solid;
	padding: 0.2em;
}

*.navtable {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 0.8em;
	border-width: 1px;
	border-style: solid;
	background-color: #e7e7e7;
	border-color: #666;
	padding: 0.5em;
}

*.sect1title {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 1.7em;
	font-weight: bold;
	margin-bottom: 0.0em;
}

*.sect2title {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 1.16em;
	font-weight: bold;
	margin-top: 1.5em;
	margin-bottom: 0.0em;
}

*.sect3title {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	margin-top: 1.5em;
	margin-bottom: 0.0em;
}

*.guidetitle {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	font-size: 2em;
	margin-bottom: 0em;
}

*.guidesubtitle {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	font-style: italic;
	font-size: 1.666em;
	margin-top: 0em;
}

*.guidetitleauthor {
	font-family: "Helvetica","Arial",sans-serif;
	font-weight: bold;
	margin-bottom: 0em;
}

*.guideversion,*.guidedate {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 0.8em;
}

*.guidecopyright {
	font-family: "Helvetica","Arial",sans-serif;
	font-size: 0.666em;
}

*.guidetitleemail {
	font-family: "Courier New","Courier",monospace; 
	font-weight: bold;
	font-size: 0.8em;
}

*.mainsectbreak {
	margin-top: 1em;
	color: #000;
	border: 0px;
	background-color: #000;
	height: 1px;
}

*.mainsecthr {
	color: #000;
	border: 0px;
	background-color: #000;
	height: 0.2em;
}

*.floatleft {
	float:left;
}

*.floatright {
	float:right;
}

*.padfive {
	padding-top:5px;
	padding-left:5px;
	padding-right:5px;
	padding-bottom:5px;
}

*.type,*.const,*.var,*.email,*.func,*.tt,*.operator {
	font-family: "Courier New","Courier",monospace; 
	font-size: 0.9em;
}

*.code,*.screen {
	font-family: "Courier New","Courier",monospace; 
	font-size: 0.765em;
}

*.em1 {
	font-size: 1em;
}

*.com {
	font-weight: bold;
}

*.var {
	font-style: oblique;
}

*.func {
	font-weight: bold;
}

*.titlefunc {
	font-family: "Courier New","Courier",monospace; 
	font-weight: bold;
}

*.titletype {
	font-family: "Courier New","Courier",monospace; 
	font-weight: bold;
}

*.titlevar {
	font-style: oblique;
	font-weight: bold;
}

*.command {
	font-family: "Courier New","Courier",monospace; 
	font-weight:bold;
}

*.singleborder {
	border: #000,solid,2px;
	border-color: #222;
	border-style: solid;
	border-width: 1px;
	margin: 1em;
	padding: 1em;
}

pre.code {
	background-color: #e7e7e7;
	border-color: #000;
	border-style: solid;
	border-width: 1px;
	border-right-width: 2px;
	border-bottom-width: 2px;
	margin: 0.2em;
	padding: 0.2em;
}

pre.screen {
	font-weight: bold;
	background-color: #e0e0e0;
	border-color: #000;
	border-style: solid;
	border-right-style: dashed;
	border-bottom-style: dashed;
	border-width: 1px;
	margin: 0.2em;
	padding: 0.2em;
}
Xtext/css‘	
*+,_Ihttp://beej.us/guide/bgnet/output/html/singlepage/dataencap-120-4.736.pngO#bplist00‘efX$versionX$objectsY$archiverT$top Ü†Ø"()012JKLMNOPQRSTUVWXYZ[\_`U$null›	
 !R$6S$10R$2R$7R$3S$11R$8V$classR$4R$9R$0R$5R$1ÄÄÄ ÄÄÄÄÄ”#$%&'WNS.base[NS.relativeÄ ÄÄ_Ihttp://beej.us/guide/bgnet/output/html/singlepage/dataencap-120-4.736.png“*+,-Z$classnameX$classesUNSURL¢./UNSURLXNSObject#AΩGv'Ø»”345?IWNS.keysZNS.objects©6789:;<=>Ä	Ä
ÄÄÄÄÄÄÄ©@BCDEFGHÄÄÄÄÄÄÄÄÄÄVServer\Content-TypeTEtag]Last-ModifiedTDate]Accept-Ranges^Content-LengthZKeep-AliveZConnectionVApacheYimage/png_"1095-534cbdd5a817e"_Wed, 08 Jun 2016 22:31:20 GMT_Tue, 26 Jul 2016 02:27:29 GMTUbytesT4245_timeout=2, max=100ZKeep-Alive“*+]^\NSDictionary¢]/ï“*+ab_NSHTTPURLResponse£cd/_NSHTTPURLResponse]NSURLResponse_NSKeyedArchiver—gh_WebResourceResponseÄ    # - 2 7 X ^ y | Ä É Ü â ç ê ó ö ù † £ ¶ ® ™ ¨ Æ ∞ ≤ ¥ ∂ ∏ ∫ º æ ≈ Õ Ÿ € › ﬂ+0;DJMS\egnvÅãçèëìïóôõùß©´≠Ø±≥µ∑πª¬œ‘‚Áı!+BbÇàç¢≠≤ø¬≈ ﬁ‚ˆ/             i              1OïâPNG

   IHDR  :   H    ⁄V ˇ  \IDATx⁄Ìùpeö«?^5µCÅ’©'√Aòjà!∆[∑&TÈnàìí≠ı0îXÉÏ-%A„ñÁY…ÓYwPãZ'B‚Æßí¨+U	ñê≥÷]"bò:≠JRÇ…rlò⁄@2‰ƒµi*„—u}ÙèÈÓÈÑ…làòÎÔ?=˝ˆ€ÔèÁ}ﬁ˜}ûÔÛvrÀí8.\L!˛•+i Ûo\∏H¬¨Îë,ª£z„w´Ÿ®:““Ôπ#{£ÒM§`™ŒÿmÁ‹°Ω—xlpmi¬UÆô¸W¢π—ïAJÓuU«äè|è+Ñ/wU«éÆRQ◊÷q·⁄:7)b{faßVW∫™s„Ò·˘ÚY◊ß´Øπ™3»€<˚V“¶◊÷që&\’˘Œ£ˆñô¡qWufZf®ûûn◊√öeàS∑v™)î\Á|ˆaA–µu\|á‡Æ:≥QÌÍô3ˇ{Wu\§nÛ¨2≠V‰‰≠+Lı’ s¸3¶:É-C¯÷›Aª9–m>î-˜Ù|∞+PΩ=5ÕY¿éΩ3¶:·£@Ò'Ó†›8ëî“Wu‡P*+Iázô‚…ãÍHc∂ß¶z[œ>iﬂ?ãríﬂÁ—…‘æ˚˝QsgÓzBËh“ÁÁ,Â8àıÈŒ—8‹Ókˆ@Ïôﬁ8‡©ÿ	±g˙µWo¨,0D—¸KΩDè/kaˆ√b“6≤È¥˝#…UØ˚°˚g1[≤ßp? mÍµÂ˜‰Ω)B‰üæ2U‰´Hn{óÉ:¯ü)ËŒiMHSØ¢„Ç7ÈaÓ∏Ò¬ä]uP¨|+8ué.EQîê≠'jÊ%÷ƒ“„¶√Mä¢‚oR•Fø1˝`—˝≠bkâ‚é~˝I]ç¢(ä“‰ Û:≈^†ävEQ“EYoõÚ·3zEöª¨"?a™qZ·⁄§ôD⁄ï˛ê¢å{e˝qEÒöúÛOáìÍÌÈ–˝\Hz\p˜∑∂ÍúÖﬁ…û/µ›´-µŸç≠kÓ≥ÕºRó€äΩ‡ã∞._ ƒEÍ™r±lãFêmÕ@@⁄óc„\«’áÇûK`X0%iÈ#¿Uá¸WÅÕ÷ä‰ÜU€:|RS˙ˆˆ¶∫"=˘T
Áf’	ì+§Ωa=T”;“&2÷‹≥}ò%;tìÌÌì∂Á‡´ˇú®"w?‡	zÙ‘ë2ÑOÅÿÂÆﬂ ¥=µﬂ*é#dH|ÆÓ˙˛O‡˛1≤ÜPHóbü’K4túÙ TVBÜDoHó∫è"?ÚÖe”∫
{∂‹óE†y£@·9#\32÷WÈΩzs3 e¿∏ 4ÜJK!ªèO!ãΩÒÚc_Xˆ¢”™ï,VB!ƒﬂ˛Wm%x—‡«£]ÁF«Æåg¯rñØ’~∞ó¯  >UÔ§Æ”C£C_ˇÔ‚Öæº¢Î™ég'dÛõ†≠3ﬂM¯˝¿‹ZhM‘üBxu”4‹_9µrE1X∫ÌÙÏ‹ô¸§≤y}ø∞;*Û,w◊≠bÓ$w û`∞4rø<¸ÏASG=œˆªW´ø:T	Dû˙≥…Ûn›¶*ﬁÀ˚Ù§£G8#B˝+f≥e€ìN4—¥∞…Rk}s4ôgËh¨oúêÖà4÷GS*GÍh¨èﬁ Ìõs·„t‘rº‰‘§ 0t⁄◊FÎ‡{`lí≤GÌ ï£…Ÿäû7#›1P/Ü≈S®[S™óc=fÁ}xWâ∫Âv⁄◊í –2`1[™6qcT'ZòQVµaÂVQ÷gœ]Æ*[úπ%6´œú3gŒúl	§⁄•k¬U+3ö≥3Êd‘ÍÂîY ëÎóf¨W≠Yú˘¥4Ì∫„©Ä?•ıfm.Ú≥NÓáììÙÓ†:ÒàlÀ1·ùÅµ0`ëHß›√~Rª^R/'Ìv¨∫‹⁄ßÍ˜ùÚæWõ∫ÍDka¯ Í˝ôï–ì©bÈcñΩº~ï⁄Ë£wòZ—qgUü¶ﬁ+öı‘√≤,À}óà‰Ó˛âº÷'…Rª^N´πú»ùU⁄ﬁóﬂ™;–w˙3k·∞÷ûÏ⁄¥u'/Yt)*›ÎpÿIE≤@˛Úz´»7∂ó6≠y÷zΩ´Å1’sÆà~s¬Iªáù•Ÿ\W‘ÀÄït'!DÌ2ƒ$@Ã-.ÈN˜[©SÇˇ¸ﬁË^J oÀ‰jUF≤ÓÅº`"è:;äÉc=HOÏ`Û†∏bπßø˚WÚÜ”öY∞˚◊ÁâJÍc18⁄£ôª_ÎÌ°≠°88ÈC™>¢ó”J\ÓÈˇÏ∑Ú@Y›vÄ®∂;ÎÌ~©6›àÕeu5‹#»ÚY"=¢ΩHüÂna≤ÍDÈÖ‡†‡òﬂÁ¨:—Ñ]£ﬁ´É$‰%íÇÊÕhp8¥Q#É∫7ùRÁwP√®*œêzrc–!<XY¶*^Î&ué˙SUùÛúˇ®Yûˇ›ÒãKtÍ J;Æ’Úãªhk-’ö˘4,yß(¢zKª¥hJQ‹◊∆±jƒÌµbo{Fää:VÂØ˚A˛Ÿ>Z#öM´Ü‹˝Ö@—ÊÁ;Eı⁄ wƒFºMc˜~úv¨Ô‰•˜¶∞§èn’i—ñ¸ÅÅ∏Ãja˙9‰ZU⁄â°∏ØïjÕÚﬂÎ–Ä#êÎI6uæü<†™òÊ_0ø‡‡JÉ	Ó§UUùçâ†E·e√I,›V…ˇdî†¢(äB%%%%"%Iú˘◊î&»±ö≈‰5´ë jQÂ–º]…Âh^ÀMê}!Xr¡ÃXÊ¨UÏòå4Z≤?Aˇ›ÑâX7È‘¶÷¡"Ì◊qkY¶Óä–ühñû¨QÇ ôqΩ$F‘v%ö¢√‘ó.5ˇ†ˆvº+A˛—nj˙3%∏#© ù ≠Ií—∏ÂAMÇèt¿qMSì)¡d%Ìú‚¸{[ªnm”I∫Ó`Ø1#≈◊ÀËãîö_	|íÂ@ôj”π¢G˜3[;·C€˝ª√ú:Q»¥!˙Î_AË…4ﬂŒ2ÏOcK¯*˙Z'øhMNZöÛ¢Ω‡¢lY¶Ïvï=EÍèæ’˘/9Ly%ÕJÃ66”é”Ω_ˇE•)McØSΩ'zœèK¿WNõËV˘m¿á√©ä0‡O»2j0ﬁGM~§(ÒôYuÚˇ‡ü§ú<˝ üAÆâéz8”¢:Ú}pı´+‡=îÓfwÊ'Ó{RÓ·©ê≤¬yÄÏæî_Xùÿ<ìZ…Ëcâ⁄È7ﬁ:ïÏ$Ä65Ô~“+Ôpù	‡§:ªÉ@YÎ‹˚≤*ŸÏ·Qk.ã∑˜éìi∫¬TŒUc:ƒ2∑UvÒMm/ˆúòn˝éëÊ‚ÁJ”Y¡˙nùÍ+°g¨—_ÕS2[…Z"‰Ë~$Y=sT=È≥«hööƒÉ<){X+ZoKd:·‚÷§ˇIÅ©H¬	Ë≥uxlZT'Ê˙ñÊ,xhÇñ$¬/“$é+w·˘ê≥ Îo”Û◊û≥œ¥â±ﬁ9|Yˆ_≥íMq®àJ≥†£4ô[‰7≥–âÂ™1ú\Ì›©;ÁˇòSŒOwRäÊÖ€}œLS9’”°9¬'{:O2©Œ%XËòkP≤¨:?œ˙kTö˙RU=¡é}⁄>ƒÉÏ}êW5'Îrüá∏™&?∞ºi,W›?—µ~YÜáÓ ‹õ∫Í¯∑˜Œ;o∫´©vÔéN88Cº™èMì\õû(ô&º»È"S·«\/C˛úˇMü€÷é¡G4ke∑º´.ﬁ⁄1¿àEYÏ´Nùj≥7©d≥ˆ•Ú)"Œ»RóiìOµwŸ√+ÈsΩù3?A¯ùy2;Æ:˚`ÔM§9∫†ÙUß˘Ô¥Ñ–fÄﬂ´7ˇ¢^ﬁ’XM≥ï0÷àCÍ˙§EÖõÏ÷yj™s’¥Îg®ßIRÚÅéÈQùì±â∂∏xc° ⁄åZ˜8sÜ—Äp—M§91)·˜«#µŸ4Ÿ˚ ˛lﬁa"GÂ#«Ùëñ‘í4/©^]ÆñàST3ná#‹´Ôû,oQ7ôeR„ñ¥"Eê+M'Ü§˙-∆ò.Ñv„Qw˝4÷7,A˛ëVOmÅdVzz’)ƒWo¶EGõ©Ú“ÃÃ9s◊Ï“ùÒ£†…Óóﬂà<ÆiïﬂláojåD"Q¯ã∂äu4V'π¸◊µuíçü‹™[<¿`ÀÅNºì˛gâ7~ ˜=öf–µ6ñaÚÏ_CÁÉØ´ΩóèΩÒ{ô˘˙.Q$»“Û{¢Zzh±Æè«ÜÄ≥0<öÎ#üàiõΩo¢/9<ˇ^∆¿èûªß@:≥Á=ÿ•JH:Ú1\™áﬁ°Ëy	Ñfu"∆>‚*ÏπïI>i˝LΩæ‰i;Åt¯‹®à=!:Á∏GÓ¥qﬁ˙|˜L`%c•„ƒ÷√~®j©˙¸®çz\—¿{Ô5;…’I_T¥∂7r
õmA"1æ£¥XÄP±é gpï: ∞æ&¨û	)ä¢á@,è'~ÔIp€•5MuaïoREi__\\,Í5î! k9˘¶rv î◊45’ÑΩ B‚0q»◊¨œWùc{ ¬˛gëé'ﬂµµ÷:ßØ™åf±%Ë¥}â)1◊R^ù Ëwhâ•@[HÂå%øÜ0üMˆZNhR]¥ıF«“z-r^c§é&˚ik-Ôß≥…&’q:Pm:˜mjª†él±©BΩÌZYñ#Ú%ÌN√i£94\+ßŒ‚úóõÇK#˘¶ŸU7nWù\[GöÙ êÅÚ	UG9≤»(ÿA8Bni”5≈A%®Œàei?ì,m[îÈÇ%ˇ≥>kºîbWØixƒ$,”y˛“≥D¨_3\P•ÀT{ÕéD˙d1¨’Å$¬1d˙{∞Kúî ÒÅ
çJ´8)
Å€%Ä\Õﬂ¸≥á4k'´˛·Gyªy=÷Îﬁÿ?+ Ää”√Äê´ÕÊÌœ~§ï⁄hY◊≈Œù«N Äw›ﬂØMﬁv3]ˆ-P∑âCÔIŸk&·Yzü;9∞8ò≥Œ†k6Ø‚#ÿhø˝[ãÀ∑|"rÍ≤â◊ø‡QT]€˛„w øw≥·¶d$måÉ∂∏ëwŸ⁄çÊL‚¡G4ßBÿÛ”±–«˛è^–By˝@¡õ’öƒ˝[e°≈,≤‚ÔT˛V,Í…Iô0Ï==oa÷¬¥©~k9Y,ä|6ña'pòÊˇàÿ2’S ◊A˝–Œô1ë≥˚ö
ı¥èys32V&À<æ≥=z—ªlcÖüf’02µ.;;ê≠ûÄ|π3*- ´|X§>ëû!µ∆*;à/˝í«∂ë9µ(≤¶Bö˙˝”„æN\étøZV«Â∫ZÍI‰Hû!61˙å’dª$≈EöpU«Ö´:.\’qÒùÄ˚ßôf⁄g¢í´ÆÍÃ:xÿ∑œ]u\§ÅüˇrfÍπª¿UùYÜ  oß^◊Lv·nX7ÊµÙŒ∫>}Ì™ŒL‡âe≥∞S9ÆÍÃƒz^‰nXˇowEêæqU«éªûﬁB*XÌ™é€∑ª2pùsÆ≠ìÊ_π”’çÛ/ÃF’ˇtÕ⁄ç9˛YiÎ¯›ëum7∑≠„…tÖ‡"x˛¢5(GÙ    IENDÆB`Ç‘	
./0_Bhttp://beej.us/guide/bgnet/output/html/singlepage/cs-120-3.334.pngObplist00‘efX$versionX$objectsY$archiverT$top Ü†Ø"()012JKLMNOPQRSTUVWXYZ[\_`U$null›	
 !R$6S$10R$2R$7R$3S$11R$8V$classR$4R$9R$0R$5R$1ÄÄÄ ÄÄÄÄÄ”#$%&'WNS.base[NS.relativeÄ ÄÄ_Bhttp://beej.us/guide/bgnet/output/html/singlepage/cs-120-3.334.png“*+,-Z$classnameX$classesUNSURL¢./UNSURLXNSObject#AΩGÉ7π»”345?IWNS.keysZNS.objects©6789:;<=>Ä	Ä
ÄÄÄÄÄÄÄ©@BCDEFGHÄÄÄÄÄÄÄÄÄÄVServer\Content-TypeTEtag]Last-ModifiedTDate]Accept-Ranges^Content-LengthZKeep-AliveZConnectionVApacheYimage/png_"1db5-534cbdd5a817e"_Wed, 08 Jun 2016 22:31:20 GMT_Tue, 26 Jul 2016 02:27:30 GMTUbytesT7605_timeout=2, max=100ZKeep-Alive“*+]^\NSDictionary¢]/µ“*+ab_NSHTTPURLResponse£cd/_NSHTTPURLResponse]NSURLResponse_NSKeyedArchiver—gh_WebResourceResponseÄ    # - 2 7 X ^ y | Ä É Ü â ç ê ó ö ù † £ ¶ ® ™ ¨ Æ ∞ ≤ ¥ ∂ ∏ ∫ º æ ≈ Õ Ÿ € › ﬂ$)4=CFLU^`gozÑÜàäåéêíîñ†¢§¶®™¨Æ∞≤¥ª»Õ€‡Ó˝$;[{ÅÜõ¶´∏ªæ√◊€Ô˝(             i              *OµâPNG

   IHDR  ê   †    Ÿe	  |IDATx⁄Ì}}tezÔìQxH≤ûpŸT…8|Ï&ïìK>å¬/€(µó≈h€úSeCï≥€•[" °{€û=ôzª‹õt|πúÖ˘dπªΩêó≤,»1»$D&5a¥InmgD6-£∆Óàe%gÙ‹?f$À∂lkd;]Ù¸Òh>ﬂﬂ˚|?ÔÛÇ*òÙ4	äÓ◊èÖı¥ó¥H≈~SÏN…l∂âmHL¯Èâ7ûÛ‚m5±«ëí)Ïè·˘éùÍD*ã $€Oô6ô4“ä(.8Æäîc-JRÄƒE‘¸œ¢Tôbs@"Å¬ø¢
DHNQT’É”»3›≠V  óëçπ7ãﬂ¸€ıcù·j∑ˇ}›MÔ?’ÏöˆÚÑÛ[WiÀ÷Ä<ﬁ∞cΩR‚8w`GêY£TmÍ €©G€k*
øÌ∑bµ3ª+øUì≠r»,iêYö,€˛«ıU@fN˚ù≥%˛ìu≥ ˙™Ä$QgCp?∑Ä§^ôÕ!Ã‚b¶∂™‘gBCâY˝»öü¨ràÌ|Ã⁄*áîMÌ≥˛ùØ™22‰¥≠˝y$;'å[∂ñ-â}˜Õ9∏kbImêy•Æ{Ü∆pZÊƒÜ™R/o.g&ˇ-c»¥úlõ ÏÃ≥≤ é	cøÓ‹U+´<:ÿS¸xo}ÁMœd_∂Ë= :ÍmnˇpS'åˇÙl^Tø?¥◊◊^~Sv◊ìGó’BV†¯∫í≤i”VuüVQêßE¶çTÙ)àìÃàjÑQòß”a“I’∆\WS∏eë<IÓ’«™Da∂üHcdçiåHaV'
qDÇüà¸^πQöë«]_	Ä,∞#◊v6,F˝u¿?°	¿»gá±∏õU—≥âæù¿ßwa«O∂‹˚ùFD±f‹ı†”aK@ˆN‚ûƒ˛ÄOÏ ÄÂO≠©éè¨√Òu ^ﬂä>> K‡¸óû=wÑö?tMPê{ƒ⁄™R/Ézä>9≤Ä„ò”Èt:kú}YdˇÇØ√ØW }∏jpÿÈt:k4æ«% i¬Ó´rHYtfa—√}|-Äù›w˜p˜ç˜Ï¸Ê∂Wu3–(·ÿ'–»ˇ˛Éº¸üˇÿ˛Í7ÍU˜cÎÏY1é◊∂ÿêÀˇ´_j›Ú¢áìõ÷Xwßª∏ÌÓÀﬁ≥√˛„õÔ¿≠WˇÍé«ˇÀ=ó]ÓΩ|@π·èø∞Ù7«ïç/,¡w;◊çΩ√Æﬂ˝B’S/áC^ﬂ]‚ôÀûo∂ì·mØCl)≤X∂T‰T¡“ç]@ïCÊíí'∂ Ÿã8îbùtæ˙lê≤h±B—Ïπ·?ßjü$3–Ä¿ßH„∑#∆ØÃ¢ÖWa)ã⁄+,cyv9{më‡n™∂
HyvÔÍºgò:u:1î<?tˆ?4´wañ/≠´[÷‡\u£√à8*P†e_ëï˘◊x,vÊ§:A¡|a•√±ÄY∞ã`Å%¿bcZf¯‚g)>w∑¶˛wñ„˘¨Re„'cOØÔ;’ó_Ωb1ª¸ökóñ¢,Rˇv˛¬pbË„°±å≈∏÷ﬁæv}mê“)=÷e
~ÂÍÎ]´ff´¶NùN|‘.œ5¸Õõ\Ç≥
»Ù6lœëûò9lús≠À˘Â’≥8ô≥g{é∞—r`swmπ˚˙* ìé÷ë»±∑Õ±‚7ﬂævı–∑g=´nTù$˙b«ﬁÃ=È˜ÓtVô8R›á^6¿`nmlºmÆ÷<ÌŸöwÍS|ÿ6…7o˝∫£
H4¯[æ“¥nth≤O}oñ«)3÷wÃû|Áµ√ ∞|Î∂ö* Öh0[∑Oê˜Ã™5‘u∫Hx,{¸≠ÓàÄ!Wê.çñ÷‚cüúM·ï8?I∫0Û∆Û° ¬dè¢Ûï;ªÄijìúÚœﬁ√‚S.°÷§& `˝ Á∑»!Ï¿∂MäëNÈK)¢ Ä)ÄDˇ<b¿òn]»7Kœ+©Å@ƒÄÒıõG¢ÖÓ
Q\∂9 ∫*≥M¢P–:Dîûùy™ªµíŒãz 0¢NDA•„¡(DVµ7 `Ã1Q–«ºÆÍ)"
{/-ÎF[∏˚Äík∏<>""∑ho@≠E$"“∏‡ò◊q•√AD⁄lHÿ¬‰ç
 √ @Q$Láa"=ê"¢êñ%-™r0&""¢ ó∂ RãWrQ‹ÁnãP‹Î˚|2•É˛∞G$"
C#"9ùàH˜™ñÊlQYf	&1^≤òç}πÙ1£ëËÜõxïZò7+yŸVÅmR=˙É/Q»¯B—˘$»äœilì‰Eø „ÛÚD
'¯XCdâÜ,é@!"›∞Akœ(äûOúÆé∆‰ÚE""≠öÆëÃ©§7˘)Œƒâ¸n¢/ilÿê…öV?l. 	qUëà$!â~R Söë…')∆yçÆ"b‡!Ù[8E_·,∏r®‰S5©†hÇ◊âH1Êø√0<âMD§*DF1ë0ß\ö	€@dÜyXûÁ˘VR†qj
ë gí*Q ¨€"jÉR˜∂Y ƒ“HÖ=yD¬D§ MD‚Òx\&âKÈ"r˚yË0TCh6Y>“£Ë'…≠•#y@$A'Ÿ‡ê ì&"íx¢(SDß.£~éÁÁÆêΩﬂoJÆV¢∞Ñ`P&J≥û`–À**'%7ßÖ!äLcBík~ë–p:iÁo„ŸØÍcZ¢œ∑±ÇD§ú‹Í#] Sû˜ê«˙‘¨7¨GÑíçö†Âéòö» £êﬂÌvª%"í=ºGRà˙[˘&Q%"jÀIBÈ¸,©µ;cà›ﬁÏíœ≈nov&ﬂx»ï|Nπrc3Ä=Ω¨ÈjÏlÅ∏w∆°∑‰™;v‹Ô Ì•V7∆[œBe_˚—[(Ò}◊ΩªØ≠å‡¢“§I~"ÿr-uQ.ÙLr^º6∑/.˚~Zó.¸^?ÿ˙O3/” '˝^yæˇ£““J±gJ≠WÏ}jÃü?˙"{©ÉÔ[.{.—£.˛ö]R¸óΩçñ ãˇ¸’]•¶^KØè€ﬁ8œ…ê_˜]˜Á˘%ﬁªÂ•iŒ¯À¬
∑ÅÁûsn]ÚÛ«JØ{èïò‹˛Ÿ´Û<-¿∑Áª·ƒ7¶=c≈
ˇ∫Ä√.¿ﬂPr9DÊÒüŸ™éaJZP	/È#s6l Ä°O„•‚xµ™¨M™à9Ÿ˙ÒsæÛæõæoaMmb[ïCfu÷º?ŒÚ¨ﬂ˘VÊºÛÕä·ëä K«˛π·_úH‚*yê˜{ï°G*Bd≈æ:~∆£Û¶ß!7$KWCÔ;íUô-rΩ=¡p⁄˘œßèhxzüÖôwÔÀe^M-q÷_öuSí<ˇÔékWÂπ®k'Ÿ Ì"4_:@◊å7é´Voxæ◊˘K+w9\ñ4HîÃ⁄lÊ÷ﬂˇ≥π(ì?!€µk◊p◊7,Ÿ÷i69:68hƒÈ^\s	9D<1·Psœ¯ˆ<jÈScè[toC ∑rh‰ùß/âÄü$Û(ªŒ1≥≠ÄÊ„¡ZäªıûIli+#ß	Aí,ÊD“”eΩ€Z&§bXÄ#JZx¥Ãyh18©»jˇŒ lÂù√ÚÎ}|j ºf §V.›hi≤÷ó?eˆ©∫≠}S√nã˜ql∞⁄ô4µCCÎ! ó´˘áØÕ£ipÔ3Ç~˚∫Ì[ ©Avjﬂ∂¯h,˚≥ãó9ZWÜÜÓê˜Yª‡‡ ÑC9˝U”<Ät>¥Ωò{ì-Ô˝Q DÅ2£°Q†°‹7X15'ƒÇKJÕ{›ˇ†≈gˇÿZ‘}È}+¶rÆ¶|∞†ãõëË8û¨˚€n,E.—çzs*&:ﬂUØ¯R„∂ìˆú¡=µ©W~°.¯ﬁñÈtà aúºLâÄ±ıô™(£*D	äbh¥DSî4ëíƒêô@O+
VQE— –!Å»‘E“úPrI◊,ÍÆ∏äÁjS|Ê†IÛ “,
 örêJõyâ[≠Ì‘Ç, Ñ
uH—'∂\ër/Ãb0LnBÊªµÂŒ˜Õ(0ä©†«∑hê©J‚¥`”í˘í+‘T∑E@†H1´Ä<<Ä&s ü 0<'ê»O°PŒò	s xè¿ ¨bñA ‡yƒßDûƒˆ`îêhÄYb°µÄ1˙J˛§(üUDD£u5àXDú¢v ‚ñTR˘–¨Ÿ8  F‘&îvÄ”DÊs„$,ÑpöH!NéÈ<ò~""ôº
)M@´Y¨§)4 >≥Hl¸ÑÃ·åÖ∫‡§∏û9óf¿rG4-Ãõ«î∏ê‚Òx<Æ[DOOg˛JDz∏¥¸∫∑à åGí«ªÉ5ˇé‰F§@[:èóü∆˛S„Û i<†òøÅÔühˆ$Õ Åb2«øy] ÃJç7Ÿ!
Äç‰ç7á<ÁøXıC¬ÅÈ¥Ç'@rÄ„K´Ù	ã—}9G,ê;]((åLŸÕ˘≤§H^ê©ú)˘0/˜LîJ$ƒâ¨*ç—%QÄW«˝((),ï‡GNHz∫¬Sü[8tÆDQ§Õ¨s`È‹êµj’8©9Èl
.?ˆë¬Ä’
Ü\""rùıE√7 æX%”ª¿Z ¿á`÷¿£¿Åú7∞êMè√õ≥˙“0Í%!ît»zpöÚÑl4∂ÏØK_gﬁµ—r|∞±1Û∆ÎùÉ¿àò| û∂ıÊ>–ÏupÚp-?®&Î ¸-¯] –1Çoû ]bnî=
¯KÙC˛/ª≈N˝–t∑3}p9 ƒﬁÅ–\ê±»òÔñ3n»ΩÔ∫r<êﬂ»”Üß^fÎêÈ¬ç•ï¬Ωqc[GsÛÅòt¯_ﬂu©∑ÅG
Ê ∂éπy'∂ xlj ‡ó¿ã/\¬89Ç‚˝VäÃ‹OÄbßfb0∫¿DMNÈbW_}ı’W_Ìp8÷ u ≤}`øn^–¨6bí¿mÂƒYk˜MÀWıuË¸ù∂øªcIw‹Wn#◊¿; ¢„:?Òµ é^¸&‡4ÄûˇÉ&„Ë¯∏Ü`Œ÷R£ΩPLRú¡-9Nπ›~D”4M”FFFF @\√¶úâÂp8fºÉU˙„í*∆v^ˇÚOzK8µΩe”v É Œçs¶Œ ¿{`
B.‡8ê›<cL¨åı\ éLL*"≤X@)- æÛa- ÙÉ˘E·	Îå(b˛’zr8‰bíÈÖíÙŒo◊∏ûy‰Ω%î<¨Ω∂|@V≤ñ≥uÒV4d∏I¿)‡P|F9ò
Lîî'&õ§E Y|T<@∏)òZ ˇÅÂ[äú‘0˙Lád.&i-)’QZÑjÕŸ§´ÒâC?ü˛ÃL˘ÒM‡§f|>k/ÖÙAŒ⁄1≈(´ı!ıÿ}y-Û´	÷H8g©"k-≤£Jè©öÛ∫d!ŒeãDoÕeqkç9 àI^QbµaÕÔM=—s¿’>–10ıô_;cQáBˆØ ÓNC˛˜åˇÍà)√GuÑñ88à'Írf«?:ÆM6&E i‘ø+D≥ ≤1uct…zåü8YÿUÊ?è‰l´”≈u“4m]©¡Óèù™}{[◊œnË8?ıâo÷[{ÖWæ¥?ï√Ê;ˇ¯QÄYÙÂK≤SYSYÆ'ª;˛{y≥x8ìœ√Lù *à´xrT°ˆ~ı;ÌÊ±∫d5h~≤d êPG=éXÅÙäY‰PÈÈ÷Ê©«Ø{ÙÓ÷?õR$•:¨ñ¨⁄”ﬁ5–€˘¯™ÉÄ 8˛lÎIfìΩùªñ9›«çnòÜ˘Á˝ãwæ‘q&õäuÓøÓÆÀßKã,©‡ãjD$Kn”≥ÊÃ.t–œM2QZë›PÅ˚ŸöÛ^# #F‚q≈íßne-â◊+)S7P$´ûzaåX
œS[.n;v…Ä1ÜïƒòLπ∞|ºx
∑h\W6¬µœå∆l˝πêàPÛ·Äs`´∑„Õÿ0ÈÊóµZDµàﬂòSπn=t¢sapÅÇ·Àe kÌ¢„cÙ
C)DDrKŒmÒÖÕ®G !’ü_©¬˘¬z!:3⁄$ˇj‡}˙∏(¢öè—ìÍg&MÜLàœ rƒ˛ ëÊ¶
iµFÀâeÈÒHPíB„"j∫	J°®•¨j4(#ÒÈã.C∞ËrÑ‘·ûè?≠ªﬁYüÎ~◊ìq4@¶lﬁÊœæS>Y\«ªMì®W√ùÊ˘©(Æ…Jôsg∞ní,¯7Æx	3¶û˛•cJ∑øÔœÎC&‰RQ@Rß,m’˛ù?Â?>3Ÿ"û‰Î%}§ ±kmÔ‡[ñNˇÚ@£ÎÏd?Üä!ª÷ˆ∫¨5•‹≤©G?äL<LUƒ∂ƒì˙!ˆ†ã[™w5‘=”◊æß®7˛≠û*áÃòñXï˚Ùıÿ ∑˝ûCé* 3¶∫Êå•a‹;y,≤„˛ ¡√∆v≤∑§¨^“ªΩ~ÛDIóïTôç7{ﬂjæ5Ê˘ [“ªíá5˚j™ÄÃ ´uYåI˛’èˆ^Ôz·'„M¨ÌŸ
¬√ﬁK⁄,∫◊i é\wÙJÀûÜ∫Ê˘ãe\ÅùÁó8y◊§°ìÿ"+ôîƒõ]›ëW ﬂ_ıqqﬁÁ Y∞˚R=+ëZ]¸áÔNÍv,∑4∫…ü +v8[S»ª‰‘mvú´oü˚Ro#∆]¬V„*√,∑ªè¨>E∏1ëb≠Ï~∫ ‰jsùÖBâ¥¿Ï¥∂æJ=Ê ⁄o ÷=†ä◊›g—i^nmŸR«∂U«∂z)\í~eŸ^·üè)∑ö@ùWlÃ@j'Ä⁄Ë”≥3\sœmmDîÊB AkS6›daÍâAçà$ﬂhÁ9‚ÀÂê0¶^Â©)QËDD"ØQòùïw3Dç«IkD§ÜeùàHß9è«u5WâH1VÖ‹Df>ã≠Âv,øïÆIna¶Ì˘˙y∞
QøøIlÈRKìò&…+I)MDr@Ä∏± J6 §ça¸`xç‡ò&çH«	-2&0ñëÑåLnäëÛ ∆k•`ΩﬂZuªjc[CyæPÙrÒÄDDº'ËGêH‰¸Ô•ê ^‰ÉD∆ÎtÌi›‰µ $Cà*˝$≥a]·$Rò0©ÓV“yë“\aC[a“
í˝Ó`…∂“ƒªﬂœÒB°V˜îµoNî74∫ÓˆÀÈ†L:/E"£íØU'±ïTÑà¸–â(nÊœ˝n[ ¬KR8è«√F+ÓHàH‚”í!5n3Û&Úé1π≈Y⁄rcÏH˙Eè–6≥>À∫»‰,,πÖc‹2E¡Û<œá…Á#í‹F#kCd•çN ‘‚≥ ∆⁄!Cfgqç(Õycbç≈:F3d ÄÛ#≤R¢∫YÏø,»ÒÊÕe’z˜f≈3Z˜”%≠≠çt>DD˝Jùy"œ‚Ç6 D3ä¢ı3¢⁄/5•#(≤ü”àD÷\ß(Ö(Ü‰ Ä‡âó˛ãÄƒsì¬\eU◊™»/ÌÂ8øèâ‹ú$	B0ËÊ$1-Çπ.⁄ê2 " oã,Xo(MAlKîà¥º——‰ùF¿¯’0ﬁ~ö
f4≈¸ oOo»ÔÎDÚ˚√i
°P  Ö˝ÅH †ë Dà»◊DvY%L∫˘ˇÒÇ(Ã™D!c”#çe¬D§y¿[⁄ÃX‘˙∏ôµ∞nZÒ3 <ª≈ã"Q⁄µ SPD%Í7ﬂoéé‹
 m•@¢Œ–·*}ª
é(Õ#]ÍmÛFm]Ÿ ni:Skˆ£+I∏k¡@Àº¬1oK.Éè¿¥LK—=3éHËnµD4ÊéKŸåøhD˛‡°A Ï7wﬁ9óQŒlÕî©W^z} wÔÆòoö˜ÌªèzI¿~uõªXZ§˜≠Ω≥îÃ-ì6âMtõhløÔN;‰≥m∞¡}Êç_ ÓÆ-wèœ&„≥2iSµgVNÓÃâ∑éø7 ‹ˆÌ≤•∫ êzÂoΩ&˘Õø'‹8:õãcô¥Á« õ<“”s‘XsŒ7?X›‡æ¸≤+l¥™`\ko_kt…}xÔÏm<?p÷»ßNıæk¬~ÛÌæb´ ˚  ±w^;¨Âbè7or÷Øû≈MÁ{O˘t"vÊ§Ÿ†Ñπµ±Ò∂:ÿçÏÄl¸®¸¡ØrΩr¡^øbeÉs?£Æ“©¡xl‡T	 ‹ÊMwl¥g¡ØÌ 1E¸âc±˚
´1úuuÀXû]~Õ‚kJ…ÏÖÛC√ '…‰Ös˝I¯VØp5‘√∂dS@  Ûcw<!üU¥q?∞_¿R÷·∏‚™EK√¿ ôﬂ"}q‰bJK®Ík÷¨æﬁµjq∑›Wäÿ∏rQ6WÌ$„ß Ø?—√∆T◊4ñZÊt’ euuKú_^m»ºÑfs<lÃ!	g94t˛BbxË„Ùgø…h∏i˙∑yiƒ,¬B\Ö• XG›≤ãŸ˙%◊.ùh@e‘T)ãæˆBIKv2∞–Q˙(ÔzpK[Yq6_õ`W@:á«kﬂ.¨¸Ÿ‚›Ëâ,~®»¸TF√˝é.«íNÁ˝ €}Ãıu–qÎÖ∑ú˜;ÄXÁ–íf≤Ø≈ú˜è1ÀŒÙÏ®RÜIèèjm∆IœÌªwΩ|Ô˘√G\)7€à◊ﬂs‹ƒ¢ÒŒ Û‡G[{N∆k≥ã∂*çùÕ–˛§«sÌÕ|ÌlÛâìcˆ∂9  [“ƒâŒ
ëƒ©D^?π4ëŒ¥Ë§ J~∑F$H$#@‰àx#£Ôt"!HïC6ï®?û∞0-Æ˝u-§ÁıééE=®W∑ı89≤ØN˛tÚŸ}µ¿⁄w—«~–ú¿ «⁄S@‚‡÷C_ª‚b‡a;3àMŸ=!rî€$‘E›››¯6√Wn‹<Ä>ŒdÖS∏¿9é‹]»kÅó˝‚Ú˝Ë„í›››Œ±õªÆ˙AUdYYíÆEò—„a.@~ûà$^1i"Öâí[$2˛Cöó—•‚;Y®UëeïNLh(˜¡z ´Òt
©NúÈÆI7‡ƒ`zü<P#‡«Ÿ‰<∞!€∑	»Ωù) ÆöµÉœfêøp0∂´ !3'£r;»1„ßÀÚ¨H:+r<+ëƒp¨_ß~®D24ûq˜âÀÕŒ2ÅœGë√·ﬁI*eœÍ+@F¡
nPóû5räe’fOûø∂Œ8æp˘)ê∏hﬂpØ]Éãlb#ƒJcCÔ£|Ã°uås[r{Ü9ä-„ÌÜ}±oË$ìô6)’.¯ˇ.¥c_@ˆ/ﬁ=W∑NnÆRF0;W^RÚπΩU@ †ˆa˚é€ÁêÏ≈Áúsq„‘A˚"mÁÏ@ç„¯üœ…ç”Œ*áîM=ç¯\ë›{{%ˇ˚tª⁄û™r»®„NÁÁàÎ*†˚ùv≈lsùù•`E9th≥È#&∑øYdÜfÍês˙f˙KÍzV◊ıl¨†Ω*≤ÄZgr€4<‘ÅüùBÁ˛!Éz§¶⁄÷∞£À÷ﬂZ)uYŸöa≤•"©‡Ó3F∆ëzeG◊°gE˜«D/WoÁ]P1úºx1ä.›L≤é·l·;Pª[6¢[€›qÎ¯Ë{‚¸ªh•P≥s†®‹˙A‘±∑»W‘b«n‡rÏJé9<ÿkÛœ¨®R“å£}√ÿ	ﬁÛ?ßk⁄µ%Òáy´*1Ï≤ø(® r`√µË»ªÓŸÕôç?›5[‡|	˚ëÄæ>˚$U•§ î÷(°í˚!È*yC‘™TãÊÑ∫NÔn«ÓÅñ<é,jÀ+@¸?ƒÍì'bùÌx    IENDÆB`Ç’	
2345P_<http://beej.us/guide/bgnet/output/html/singlepage/bgnet.htmlO §§<!-- HTML generated by Beej's bgconv Python script --><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Beej's Guide to Network Programming</title>
<link rel="stylesheet" href="bgnet.css" type="text/css">
<style type="text/css"></style><style type="text/css" id="GINGER_SOFATWARE_style">.GINGER_SOFATWARE_noMark { background : transparent; }  .GINGER_SOFATWARE_wrapper{ position: absolute; overflow: hidden; margin: 0px; padding: 0px; border: 0px solid transparent } .GINGER_SOFATWARE_contour { position : absolute; margin: 0px; }  .GINGER_SOFATWARE_richText { margin : 0px; padding-bottom: 3px; border-width: 0px; border-color: transparent; display: block; color: transparent; -webkit-text-fill-color: transparent; overflow: hidden; white-space: pre-wrap;}  .GINGER_SOFATWARE_inputWrapper .GINGER_SOFATWARE_richText {position: absolute;}  .GINGER_SOFATWARE_canvas { display:none; background-repeat:no-repeat;}  .GINGER_SOFATWARE_control .GINGER_SOFATWARE_correct, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_SpellingCorrect, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_spelling {border-top-left-radius:2px; border-top-right-radius:2px; border-bottom-right-radius:2px; border-bottom-left-radius:2px;} .GINGER_SOFATWARE_control .GINGER_SOFATWARE_correct, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_SpellingCorrect, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_spelling {background-image:url(data:image/gif;base64,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)!important;} .GINGER_SOFATWARE_control .GINGER_SOFATWARE_correct.GINGER_SOFATWARE_synonym, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_SpellingCorrect.GINGER_SOFATWARE_synonym, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_spelling.GINGER_SOFATWARE_synonym {background-image:url(data:image/gif;base64,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)!important;} .GINGER_SOFATWARE_control .GINGER_SOFATWARE_correct.GINGER_SOFATWARE_noSuggestion, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_SpellingCorrect.GINGER_SOFATWARE_noSuggestion, .GINGER_SOFATWARE_control .GINGER_SOFATWARE_spelling.GINGER_SOFATWARE_noSuggestion {background-image:url(data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAABRJREFUeNpiOP301X8AAAAA//8DAAizA5qLCNxsAAAAAElFTkSuQmCC)!important;} .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_correct, .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_SpellingCorrect, .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_spelling {position:relative; background-image:none!important;} .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_markHighlightLeft { position : absolute; left:-2px; top:0px; bottom:0px; width:2px;} .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_markHighlightRight { position : absolute; right:-2px; top:0px; bottom:0px; width:2px;} .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_markHighlightTop { position : absolute; left:0px; right:0px; top:-2px; height:3px;} .GINGER_SOFATWARE_richText .GINGER_SOFATWARE_markHighlightBottom { position : absolute; left:0px; right:0px; bottom:-2px; height:3px;}</style></head>

<body bgcolor="#ffffff" ginger_sofatware_stylesheet="true" ginger_sofatware_doc="true">


<div id="adsense">
<script type="text/javascript"><!--
google_ad_client = "pub-8191228291510015";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text";
//2007-05-05: bgnet
google_ad_channel = "6194029036";
google_color_border = "336699";
google_color_bg = "FFFFFF";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//-->
</script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div><br>

    <h1 class="guidetitle">Beej's Guide to Network Programming</h1>

    <h2 class="guidesubtitle">Using Internet Sockets</h2>



    
        <p><b class="guidetitleauthor">Brian "Beej Jorgensen" Hall</b><br>

        <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>
    

    

    </p><p><span class="guideversion">Version 3.0.21</span><br>

    <span class="guidedate">June 8, 2016</span><br>


    </p><p><small class="guidecopyright">Copyright ¬© 2015  Brian "Beej Jorgensen" Hall</small></p>


    

    

    

<hr class="mainsectbreak">
<h2 class="sect1title">Contents</h2><hr class="mainsecthr">
<dl>
<dt>1. <a href="#intro">Intro</a></dt>
<dd>1.1. <a href="#audience">Audience</a></dd>
<dd>1.2. <a href="#platform">Platform and Compiler</a></dd>
<dd>1.3. <a href="#homepage">Official Homepage and Books For Sale</a></dd>
<dd>1.4. <a href="#solaris">Note for Solaris/SunOS Programmers</a></dd>
<dd>1.5. <a href="#windows">Note for Windows Programmers</a></dd>
<dd>1.6. <a href="#emailpolicy">Email Policy</a></dd>
<dd>1.7. <a href="#mirroring">Mirroring</a></dd>
<dd>1.8. <a href="#xlate">Note for Translators</a></dd>
<dd>1.9. <a href="#copyright">Copyright and Distribution</a></dd>
<p></p><dt>2. <a href="#theory">What is a socket?</a></dt>
<dd>2.1. <a href="#twotypes">Two Types of Internet Sockets</a></dd>
<dd>2.2. <a href="#lowlevel">Low level Nonsense and Network Theory</a></dd>
<p></p><dt>3. <a href="#ipstructsdata">IP Addresses, <nobr><tt class="type">struct</tt></nobr>s, and Data Munging</a></dt>
<dd>3.1. <a href="#ipaddrs1">IP Addresses, versions 4 and 6</a></dd>
<dd>3.2. <a href="#byteorder">Byte Order</a></dd>
<dd>3.3. <a href="#structs"><nobr><tt class="type">struct</tt></nobr>s</a></dd>
<dd>3.4. <a href="#ipaddrs2">IP Addresses, Part Deux</a></dd>
<p></p><dt>4. <a href="#ip4to6">Jumping from IPv4 to IPv6</a></dt>
<p></p><dt>5. <a href="#syscalls">System Calls or Bust</a></dt>
<dd>5.1. <a href="#getaddrinfo"><b><tt class="func">getaddrinfo()</tt></b>‚ÄîPrepare to launch!</a></dd>
<dd>5.2. <a href="#socket"><b><tt class="func">socket()</tt></b>‚ÄîGet the File Descriptor!</a></dd>
<dd>5.3. <a href="#bind"><b><tt class="func">bind()</tt></b>‚ÄîWhat port am I on?</a></dd>
<dd>5.4. <a href="#connect"><b><tt class="func">connect()</tt></b>‚ÄîHey, you!</a></dd>
<dd>5.5. <a href="#listen"><b><tt class="func">listen()</tt></b>‚ÄîWill somebody please call
me?</a></dd>
<dd>5.6. <a href="#accept"><b><tt class="func">accept()</tt></b>‚Äî"Thank you for calling port
3490."</a></dd>
<dd>5.7. <a href="#sendrecv"><b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b>‚ÄîTalk to me,
baby!</a></dd>
<dd>5.8. <a href="#sendtorecv"><b><tt class="func">sendto()</tt></b> and
<b><tt class="func">recvfrom()</tt></b>‚ÄîTalk to me, DGRAM-style</a></dd>
<dd>5.9. <a href="#closedown"><b><tt class="func">close()</tt></b> and
<b><tt class="func">shutdown()</tt></b>‚ÄîGet outta my face!</a></dd>
<dd>5.10. <a href="#getpeername"><b><tt class="func">getpeername()</tt></b>‚ÄîWho are you?</a></dd>
<dd>5.11. <a href="#gethostname"><b><tt class="func">gethostname()</tt></b>‚ÄîWho am I?</a></dd>
<p></p><dt>6. <a href="#clientserver">Client-Server Background</a></dt>
<dd>6.1. <a href="#simpleserver">A Simple Stream Server</a></dd>
<dd>6.2. <a href="#simpleclient">A Simple Stream Client</a></dd>
<dd>6.3. <a href="#datagram">Datagram Sockets</a></dd>
<p></p><dt>7. <a href="#advanced">Slightly Advanced Techniques</a></dt>
<dd>7.1. <a href="#blocking">Blocking</a></dd>
<dd>7.2. <a href="#select"><b><tt class="func">select()</tt></b>‚ÄîSynchronous I/O Multiplexing</a></dd>
<dd>7.3. <a href="#sendall">Handling Partial <b><tt class="func">send()</tt></b>s</a></dd>
<dd>7.4. <a href="#serialization">Serialization‚ÄîHow to Pack Data</a></dd>
<dd>7.5. <a href="#sonofdataencap">Son of Data Encapsulation</a></dd>
<dd>7.6. <a href="#broadcast">Broadcast Packets‚ÄîHello, World!</a></dd>
<p></p><dt>8. <a href="#faq">Common Questions</a></dt>
<p></p><dt>9. <a href="#man">Man Pages</a></dt>
<dd>9.1. <a href="#acceptman"><b><tt class="func">accept()</tt></b></a></dd>
<dd>9.2. <a href="#bindman"><b><tt class="func">bind()</tt></b></a></dd>
<dd>9.3. <a href="#connectman"><b><tt class="func">connect()</tt></b></a></dd>
<dd>9.4. <a href="#closeman"><b><tt class="func">close()</tt></b></a></dd>
<dd>9.5. <a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b>, <b><tt class="func">freeaddrinfo()</tt></b>,
<b><tt class="func">gai_strerror()</tt></b></a></dd>
<dd>9.6. <a href="#gethostnameman"><b><tt class="func">gethostname()</tt></b></a></dd>
<dd>9.7. <a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b>, <b><tt class="func">gethostbyaddr()</tt></b></a></dd>
<dd>9.8. <a href="#getnameinfoman"><b><tt class="func">getnameinfo()</tt></b></a></dd>
<dd>9.9. <a href="#getpeernameman"><b><tt class="func">getpeername()</tt></b></a></dd>
<dd>9.10. <a href="#errnoman"><i><tt class="var">errno</tt></i></a></dd>
<dd>9.11. <a href="#fcntlman"><b><tt class="func">fcntl()</tt></b></a></dd>
<dd>9.12. <a href="#htonsman"><b><tt class="func">htons()</tt></b>, <b><tt class="func">htonl()</tt></b>,
<b><tt class="func">ntohs()</tt></b>, <b><tt class="func">ntohl()</tt></b></a></dd>
<dd>9.13. <a href="#inet_ntoaman"><b><tt class="func">inet_ntoa()</tt></b>, <b><tt class="func">inet_aton()</tt></b>,
<b><tt class="func">inet_addr</tt></b></a></dd>
<dd>9.14. <a href="#inet_ntopman"><b><tt class="func">inet_ntop()</tt></b>, <b><tt class="func">inet_pton()</tt></b></a></dd>
<dd>9.15. <a href="#listenman"><b><tt class="func">listen()</tt></b></a></dd>
<dd>9.16. <a href="#perrorman"><b><tt class="func">perror()</tt></b>, <b><tt class="func">strerror()</tt></b></a></dd>
<dd>9.17. <a href="#pollman"><b><tt class="func">poll()</tt></b></a></dd>
<dd>9.18. <a href="#recvman"><b><tt class="func">recv()</tt></b>, <b><tt class="func">recvfrom()</tt></b></a></dd>
<dd>9.19. <a href="#selectman"><b><tt class="func">select()</tt></b></a></dd>
<dd>9.20. <a href="#setsockoptman"><b><tt class="func">setsockopt()</tt></b>, <b><tt class="func">getsockopt()</tt></b></a></dd>
<dd>9.21. <a href="#sendman"><b><tt class="func">send()</tt></b>, <b><tt class="func">sendto()</tt></b></a></dd>
<dd>9.22. <a href="#shutdownman"><b><tt class="func">shutdown()</tt></b></a></dd>
<dd>9.23. <a href="#socketman"><b><tt class="func">socket()</tt></b></a></dd>
<dd>9.24. <a href="#sockaddr_inman"><nobr><tt class="type">struct sockaddr</tt></nobr> and pals</a></dd>
<p></p><dt>10. <a href="#reference">More References</a></dt>
<dd>10.1. <a href="#books">Books</a></dd>
<dd>10.2. <a href="#webref">Web References</a></dd>
<dd>10.3. <a href="#rfcs">RFCs</a></dd>
<p><a href="#zindex">Index</a>
</p></dl><p>









</p><hr class="mainsectbreak"><h2 class="sect1title">1. <a name="intro">Intro</a></h2><hr class="mainsecthr">


<p>Hey!  Socket programming got you down?  Is this stuff just a little
too difficult to figure out from the <b class="com">man</b> pages?  You want to
do cool Internet programming, but you don't have time to wade through a
gob of <nobr><tt class="type">struct</tt></nobr>s trying to figure out if you have to call
<b><tt class="func">bind()</tt></b> before you <b><tt class="func">connect()</tt></b>, etc., etc.</p>

<p>Well, guess what!  I've already done this nasty business, and I'm
dying to share the information with everyone!  You've come to the right
place.  This document should give the average competent C programmer the
edge s/he needs to get a grip on this networking noise.</p>

<p>And check it out: I've finally caught up with the future (just in the
nick of time, too!) and have updated the Guide for IPv6!  Enjoy!</p>






<h3 class="sect2title">1.1. <a name="audience">Audience</a></h3>


<p>This document has been written as a tutorial, not a complete
reference.  It is probably at its best when read by individuals who are
just starting out with socket programming and are looking for a
foothold.  It is certainly not the <i>complete and total</i> guide
to sockets programming, by any means.</p>

<p>Hopefully, though, it'll be just enough for those man pages to start
making sense... <tt>:-)</tt></p>








<h3 class="sect2title">1.2. <a name="platform">Platform and Compiler</a></h3>


<p>The code contained within this document was compiled on a Linux PC
using Gnu's <a name="indexId434909-2"></a><b class="com">gcc</b> compiler.  It
should, however, build on just about any platform that uses
<b class="com">gcc</b>.  Naturally, this doesn't apply if you're programming for
Windows‚Äîsee the <a href="#windows">section on Windows
programming</a>, below.</p>








<h3 class="sect2title">1.3. <a name="homepage">Official Homepage and Books For Sale</a></h3>


<p>This official location of this document is <tt class="tt"><a href="http://beej.us/guide/bgnet/" target="_blank">http://beej.us/guide/bgnet/</a></tt>. There you will
also find example code and translations of the guide into various
languages.</p>

<p>To buy nicely bound print copies (some call them "books"), visit
<tt class="tt"><a href="http://beej.us/guide/url/bgbuy" target="_blank">http://beej.us/guide/url/bgbuy</a></tt>.  I'll appreciate the purchase
because it helps sustain my document-writing lifestyle!</p>








<h3 class="sect2title">1.4. <a name="solaris">Note for Solaris/SunOS Programmers</a></h3>


<p>When compiling for <a name="indexId434909-3"></a>Solaris or <a name="indexId434909-4"></a>SunOS, you need to specify some extra command-line switches
for linking in the proper libraries.  In order to do this, simply add
"<tt class="tt"><nobr>-lnsl</nobr> <nobr>-lsocket</nobr> <nobr>-lresolv</nobr></tt>" to the end of the compile command,
like so:</p>

<pre class="screen">$ cc -o server server.c -lnsl -lsocket -lresolv</pre>


<p>If you still get errors, you could try further adding a
"<tt class="tt">-lxnet</tt>" to the end of that command line.  I don't know what
that does, exactly, but some people seem to need it.</p>

<p>Another place that you might find problems is in the call to
<b><tt class="func">setsockopt()</tt></b>.  The prototype differs from that on my Linux
box, so instead of:</p>

<pre class="code">int yes=1;</pre>


<p>enter this:</p>

<pre class="code">char yes='1';</pre>


<p>As I don't have a Sun box, I haven't tested any of the above
information‚Äîit's just what people have told me through email.</p>








<h3 class="sect2title">1.5. <a name="windows">Note for Windows Programmers</a></h3>


<p>At this point in the guide, historically, I've done a bit of bagging
on <a name="indexId434909-5"></a>Windows, simply due to the fact that I don't like
it very much.  But I should really be fair and tell you that Windows has
a huge install base and is obviously a perfectly fine operating
system.</p>

<p>They say absence makes the heart grow fonder, and in this case, I
believe it to be true.  (Or maybe it's age.)  But what I can say is that
after a decade-plus of not using Microsoft OSes for my personal work,
I'm much happier!  As such, I can sit back and safely say, "Sure, feel
free to use Windows!"  ...Ok yes, it does make me grit my teeth to say
that.</p>

<p>So I still encourage you to try <a name="indexId434909-6"></a><a href="http://www.linux.com/" target="_blank">Linux</a>, <a href="http://www.bsd.org/" target="_blank">BSD</a>, or
some flavor of Unix, instead.</p>

<p>But people like what they like, and you Windows folk will be pleased
to know that this information is generally applicable to you guys, with
a few minor changes, if any.</p>

<p>One cool thing you can do is install <a name="indexId434909-7"></a><a href="http://www.cygwin.com/" target="_blank">Cygwin</a>, which is a collection of Unix tools
for Windows.  I've heard on the grapevine that doing so allows all these
programs to compile unmodified.</p>

<p>But some of you might want to do things the Pure Windows Way.  That's
very gutsy of you, and this is what you have to do: run out and get Unix
immediately!  No, no‚ÄîI'm kidding.  I'm supposed to be
Windows-friendly(er) these days...</p>

<p>This is what you'll have to do (unless you install <a href="http://www.cygwin.com/" target="_blank">Cygwin</a>!): first, ignore pretty
much all of the system header files I mention in here.  All you need to
include is:</p>

<pre class="code"><a name="indexId434909-8"></a>#include &lt;winsock.h&gt;</pre>


<p>Wait!  You also have to make a call to <a name="indexId434909-9"></a><b><tt class="func">WSAStartup()</tt></b> before doing anything else
with the sockets library.  The code to do that looks something like
this:</p>

<pre class="code">#include &lt;winsock.h&gt;

{
    WSADATA wsaData;   // if this doesn't work
    //WSAData wsaData; // then try this instead

    // MAKEWORD(1,1) for Winsock 1.1, MAKEWORD(2,0) for Winsock 2.0:

    if (WSAStartup(MAKEWORD(1,1), &amp;wsaData) != 0) {
        fprintf(stderr, "WSAStartup failed.\n");
        exit(1);
    }</pre>


<p>You also have to tell your compiler to link in the Winsock library,
usually called <i><tt class="var">wsock32.lib</tt></i> or <i><tt class="var">winsock32.lib</tt></i>,
or <i><tt class="var">ws2_32.lib</tt></i> for Winsock 2.0.  Under VC++, this can be
done through the <tt class="tt">Project</tt> menu, under <tt class="tt">Settings...</tt>.
Click the <tt class="tt">Link</tt> tab, and look for the box titled "Object/library
modules".  Add "wsock32.lib" (or whichever lib is your preference) to
that list.</p>

<p>Or so I hear.</p>

<p>Finally, you need to call <a name="indexId434909-10"></a><b><tt class="func">WSACleanup()</tt></b> when you're all through
with the sockets library.  See your online help for details.</p>

<p>Once you do that, the rest of the examples in this tutorial should
generally apply, with a few exceptions.  For one thing, you can't use
<b><tt class="func">close()</tt></b> to close a socket‚Äîyou need to use <a name="indexId434909-11"></a><b><tt class="func">closesocket()</tt></b>, instead.  Also, <a name="indexId434909-12"></a><b><tt class="func">select()</tt></b> only works with socket
descriptors, not file descriptors (like <tt class="const">0</tt> for
<tt class="tt">stdin</tt>).</p>

<p>There is also a socket class that you can use, <a name="indexId434909-13"></a><nobr><tt class="type">CSocket</tt></nobr>.  Check your compilers help pages
for more information.</p>

<p>To get more information about Winsock, read the <a name="indexId434909-14"></a><a href="http://tangentsoft.net/wskfaq/" target="_blank">Winsock FAQ</a> and go from
there.</p>

<p>Finally, I hear that Windows has no <a name="indexId434909-15"></a><b><tt class="func">fork()</tt></b> system call which is, unfortunately,
used in some of my examples.  Maybe you have to link in a POSIX library
or something to get it to work, or you can use <a name="indexId434909-16"></a><b><tt class="func">CreateProcess()</tt></b> instead.
<b><tt class="func">fork()</tt></b> takes no arguments, and <b><tt class="func">CreateProcess()</tt></b>
takes about 48 billion arguments.  If you're not up to that, the <a name="indexId434909-17"></a><b><tt class="func">CreateThread()</tt></b> is a little easier to
digest...unfortunately a discussion about multithreading is beyond the
scope of this document.  I can only talk about so much, you know!</p>








<h3 class="sect2title">1.6. <a name="emailpolicy">Email Policy</a></h3>


<p>I'm generally available to help out with <a name="indexId434909-18"></a>email questions so feel free to write in, but I can't guarantee a
response.  I lead a pretty busy life and there are times when I just
can't answer a question you have.  When that's the case, I usually just
delete the message.  It's nothing personal; I just won't ever have the
time to give the detailed answer you require.</p>

<p>As a rule, the more complex the question, the less likely I am to
respond.  If you can narrow down your question before mailing it and be
sure to include any pertinent information (like platform, compiler,
error messages you're getting, and anything else you think might help me
troubleshoot), you're much more likely to get a response.  For more
pointers, read ESR's document, <a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank">How To Ask
Questions The Smart Way</a>.</p>

<p>If you don't get a response, hack on it some more, try to find the
answer, and if it's still elusive, then write me again with the
information you've found and hopefully it will be enough for me to help
out.</p>

<p>Now that I've badgered you about how to write and not write me, I'd
just like to let you know that I <i>fully</i> appreciate all the
praise the guide has received over the years.  It's a real morale boost,
and it gladdens me to hear that it is being used for good! <tt>:-)</tt>
Thank you!</p>









<h3 class="sect2title">1.7. <a name="mirroring">Mirroring</a></h3>


<p><a name="indexId434909-19"></a>You are more than welcome to mirror this site,
whether publicly or privately.  If you publicly mirror the site and want
me to link to it from the main page, drop me a line at
<tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>.</p>









<h3 class="sect2title">1.8. <a name="xlate">Note for Translators</a></h3>


<p><a name="indexId434909-20"></a>If you want to translate the guide into
another language, write me at <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt> and I'll link to
your translation from the main page. Feel free to add your name and
contact info to the translation.</p>

<p>Please note the license restrictions in the Copyright and
Distribution section, below.</p>

<p>If you want me to host the translation, just ask. I'll also link to
it if you want to host it; either way is fine.</p>








<h3 class="sect2title">1.9. <a name="copyright">Copyright and Distribution</a></h3>


<p>Beej's Guide to Network Programming is Copyright ¬© 2015
Brian "Beej Jorgensen" Hall.</p>

<p>With specific exceptions for source code and translations, below,
this work is licensed under the Creative Commons Attribution-
Noncommercial- No Derivative Works 3.0 License. To view a copy of this
license, visit <tt class="tt"><a href="http://creativecommons.org/licenses/by-nc-nd/3.0/" target="_blank">http://creativecommons.org/licenses/by-nc-nd/3.0/</a></tt> or send a letter to Creative
Commons, 171 Second Street, Suite 300, San Francisco, California, 94105,
USA.</p>

<p>One specific exception to the "No Derivative Works" portion of the
license is as follows: this guide may be freely translated into any
language, provided the translation is accurate, and the guide is
reprinted in its entirety.  The same license restrictions apply to the
translation as to the original guide.  The translation may also include
the name and contact information for the translator.</p>

<p>The C source code presented in this document is hereby granted to the
public domain, and is completely free of any license restriction.</p>

<p>Educators are freely encouraged to recommend or supply copies of this
guide to their students.</p>

<p>Contact <tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt> for more information.</p>



 








<hr class="mainsectbreak"><h2 class="sect1title">2. <a name="theory">What is a socket?</a></h2><hr class="mainsecthr">


<p>You hear talk of "<a name="indexId434909-21"></a>sockets" all the time, and
perhaps you are wondering just what they are exactly.  Well, they're
this: a way to speak to other programs using standard Unix <a name="indexId434909-22"></a>file descriptors.</p>

<p>What?</p>

<p>Ok‚Äîyou may have heard some Unix hacker state, "Jeez,
<i>everything</i> in Unix is a file!"  What that person may have
been talking about is the fact that when Unix programs do any sort of
I/O, they do it by reading or writing to a file descriptor.  A file
descriptor is simply an integer associated with an open file.  But (and
here's the catch), that file can be a network connection, a FIFO, a
pipe, a terminal, a real on-the-disk file, or just about anything else.
Everything in Unix <i>is</i> a file!  So when you want to
communicate with another program over the Internet you're gonna do it
through a file descriptor, you'd better believe it.</p>

<p>"Where do I get this file descriptor for network communication, Mr.
Smarty-Pants?" is probably the last question on your mind right now, but
I'm going to answer it anyway: You make a call to the <a name="indexId434909-23"></a><b><tt class="func">socket()</tt></b> system routine.  It returns the
<a name="indexId434909-24"></a>socket descriptor, and you communicate
through it using the specialized <a name="indexId434909-25"></a><b><tt class="func">send()</tt></b>
and <a name="indexId434909-26"></a><b><tt class="func">recv()</tt></b> (<b class="com"><a href="#sendman">man
send</a></b>, <b class="com"><a href="#recvman">man recv</a></b>)
socket calls.</p>

<p>"But, hey!" you might be exclaiming right about now.  "If it's a file
descriptor, why in the name of Neptune can't I just use the normal <a name="indexId434909-27"></a><b><tt class="func">read()</tt></b> and <a name="indexId434909-28"></a><b><tt class="func">write()</tt></b> calls to communicate through the
socket?"  The short answer is, "You can!"  The longer answer is, "You
can, but <a name="indexId434909-29"></a><b><tt class="func">send()</tt></b> and <a name="indexId434909-30"></a><b><tt class="func">recv()</tt></b> offer much greater control over your
data transmission."</p>

<p>What next?  How about this: there are all kinds of sockets.  There
are <a name="indexId434909-31"></a>DARPA Internet addresses (Internet
Sockets), path names on a local node (Unix Sockets), CCITT X.25
addresses (X.25 Sockets that you can safely ignore), and probably many
others depending on which Unix flavor you run.  This document deals only
with the first: Internet Sockets.</p>







<h3 class="sect2title">2.1. <a name="twotypes">Two Types of Internet Sockets</a></h3>


<p>What's this?  <a name="indexId434909-32"></a>There are two types of Internet
sockets?  Yes.  Well, no.  I'm lying.  There are more, but I didn't want
to scare you.  I'm only going to talk about two types here.  Except for
this sentence, where I'm going to tell you that "<a name="indexId434909-33"></a><a name="indexId434909-34"></a>Raw Sockets" are also very powerful and
you should look them up.</p>

<p>All right, already.  What are the two types?  One is "<a name="indexId434909-35"></a>Stream Sockets"; the other is
"<a name="indexId434909-36"></a>Datagram Sockets", which
may hereafter be referred to as "<tt class="const">SOCK_STREAM</tt>" and
"<tt class="const">SOCK_DGRAM</tt>", respectively.  Datagram sockets are
sometimes called "connectionless sockets".  (Though they can be <a name="indexId434909-37"></a><b><tt class="func">connect()</tt></b>'d if you really want.  See
<b><tt class="func"><a href="#connect">connect()</a></tt></b>, below.)</p>

<p>Stream sockets are reliable two-way connected communication streams.
If you output two items into the socket in the order "1, 2", they will
arrive in the order "1, 2" at the opposite end.  They will also be
error-free.  I'm so certain, in fact, they will be error-free, that I'm
just going to put my fingers in my ears and chant <i>la la la la</i>
if anyone tries to claim otherwise.</p>

<p>What uses <a name="indexId434909-38"></a>stream sockets?  Well, you may
have heard of the <a name="indexId434909-39"></a><b class="com">telnet</b> application, yes?
It uses stream sockets.  All the characters you type need to arrive in
the same order you type them, right?  Also, web browsers use the <a name="indexId434909-40"></a>HTTP protocol which uses stream sockets to get
pages.  Indeed, if you telnet to a web site on port 80, and type
"<tt class="tt">GET / HTTP/1.0</tt>" and hit RETURN twice, it'll dump the HTML back
at you!</p>

<p>How do stream sockets achieve this high level of data transmission
quality?  They use a protocol called "The Transmission Control
Protocol", otherwise known as <a name="indexId434909-41"></a>"TCP" (see <a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC 793</a> for extremely detailed info
on TCP.)  TCP makes sure your data arrives sequentially and error-free.
You may have heard "TCP" before as the better half of "TCP/IP" where <a name="indexId434909-42"></a> "IP" stands for "Internet Protocol" (see <a href="http://tools.ietf.org/html/rfc791" target="_blank">RFC 791</a>.)  IP deals primarily with
Internet routing and is not generally responsible for data
integrity.</p>

<p>Cool.  <a name="indexId434909-43"></a>What about Datagram sockets?  Why
are they called connectionless?  What is the deal, here, anyway?  Why
are they unreliable?  Well, here are some facts: if you send a datagram,
it may arrive.  It may arrive out of order.  If it arrives, the data
within the packet will be error-free.</p>

<p>Datagram sockets also use IP for routing, but they don't use TCP;
they use the "User Datagram Protocol", or <a name="indexId434909-44"></a>"UDP" (see
<a href="http://tools.ietf.org/html/rfc768" target="_blank">RFC 768</a>.)</p>

<p>Why are they connectionless?  Well, basically, it's because you don't
have to maintain an open connection as you do with stream sockets.  You
just build a packet, slap an IP header on it with destination
information, and send it out.  No connection needed.  They are generally
used either when a TCP stack is unavailable or when a few dropped
packets here and there don't mean the end of the Universe.  Sample
applications: <b class="com">tftp</b> (trivial file transfer protocol, a little
brother to FTP), <b class="com">dhcpcd</b> (a DHCP client), multiplayer games,
streaming audio, video conferencing, etc.</p>

<p>"Wait a minute!  <b class="com">tftp</b> and <b class="com">dhcpcd</b> are used to
transfer binary applications from one host to another!  Data can't be
lost if you expect the application to work when it arrives!  What kind
of dark magic is this?"</p>

<p>Well, my human friend, <b class="com">tftp</b> and similar programs have
their own protocol on top of UDP.  For example, the tftp protocol says
that for each packet that gets sent, the recipient has to send back a
packet that says, "I got it!" (an "ACK" packet.)  If the sender of the
original packet gets no reply in, say, five seconds, he'll re-transmit
the packet until he finally gets an ACK.  This acknowledgment procedure
is very important when implementing reliable <tt class="const">SOCK_DGRAM</tt>
applications.</p>

<p>For unreliable applications like games, audio, or video, you just
ignore the dropped packets, or perhaps try to cleverly compensate for
them.  (Quake players will know the manifestation this effect by the
technical term: <i>accursed lag</i>.  The word "accursed", in this
case, represents any extremely profane utterance.)</p>

<p>Why would you use an unreliable underlying protocol?  Two reasons:
speed and speed.  It's way faster to fire-and-forget than it is to keep
track of what has arrived safely and make sure it's in order and all
that.  If you're sending chat messages, TCP is great; if you're sending
40 positional updates per second of the players in the world, maybe it
doesn't matter so much if one or two get dropped, and UDP is a good
choice.</p>









<h3 class="sect2title">2.2. <a name="lowlevel">Low level Nonsense and Network Theory</a></h3>


<p>Since I just mentioned layering of protocols, it's time to talk
about how networks really work, and to show some examples of how <a name="indexId434909-45"></a><tt class="const">SOCK_DGRAM</tt> packets are built.
Practically, you can probably skip this section.  It's good background,
however.</p>

<a name="figure1"><center>
<div><img src="dataencap-120-4.736.png" alt="[Encapsulated Protocols Diagram]"></div>

<p><b>Data Encapsulation.</b></p>
</center>


</a><p><a name="figure1">Hey, kids, it's time to learn about </a><a name="indexId434909-46"></a><i><a href="#figure1">Data
Encapsulation</a></i>!  This is very very important.  It's so
important that you might just learn about it if you take the networks
course here at Chico State <tt>;-)</tt>.  Basically, it says this: a packet
is born, the packet is wrapped ("encapsulated") in a <a name="indexId434909-47"></a>header (and rarely a <a name="indexId434909-48"></a>footer) by the
first protocol (say, the <a name="indexId434909-49"></a>TFTP protocol), then the whole
thing (TFTP header included) is encapsulated again by the next protocol
(say, <a name="indexId434909-50"></a>UDP), then again by the next (<a name="indexId434909-51"></a>IP),
then again by the final protocol on the hardware (physical) layer (say,
<a name="indexId434909-52"></a>Ethernet).</p>

<p>When another computer receives the packet, the hardware strips the
Ethernet header, the kernel strips the IP and UDP headers, the TFTP
program strips the TFTP header, and it finally has the data.</p>

<p>Now I can finally talk about the infamous <a name="indexId434909-53"></a><i>Layered Network Model</i> (aka "ISO/OSI").  This Network
Model describes a system of network functionality that has many
advantages over other models.  For instance, you can write sockets
programs that are exactly the same without caring how the data is
physically transmitted (serial, thin Ethernet, AUI, whatever) because
programs on lower levels deal with it for you.  The actual network
hardware and topology is transparent to the socket programmer.</p>

<p>Without any further ado, I'll present the layers of the full-blown
model.  Remember this for network class exams:</p>

<ul>

<li>Application</li>

<li>Presentation</li>

<li>Session</li>

<li>Transport</li>

<li>Network</li>

<li>Data Link</li>

<li>Physical</li>

</ul>


<p>The Physical Layer is the hardware (serial, Ethernet, etc.).  The
Application  Layer is just about as far from the physical layer as you
can imagine‚Äîit's the place where users interact with the
network.</p>

<p>Now, this model is so general you could probably use it as an
automobile repair guide if you really wanted to.  A layered model more
consistent with Unix might be:</p>

<ul>

<li>Application Layer (<i>telnet, ftp, etc.</i>)</li>

<li>Host-to-Host Transport Layer (<i>TCP, UDP</i>)</li>

<li>Internet Layer (<i>IP and routing</i>)</li>

<li>Network Access Layer (<i>Ethernet, wi-fi, or whatever</i>)</li>

</ul>


<p>At this point in time, you can probably see how these layers
correspond to the encapsulation of the original data.</p>

<p>See how much work there is in building a simple packet?  Jeez!
And you have to type in the packet headers yourself using
"<b class="com">cat</b>"!  Just kidding.  All you have to do for stream sockets
is <a name="indexId434909-54"></a><b><tt class="func">send()</tt></b> the data out.  All you have to
do for datagram sockets is encapsulate the packet in the method of your
choosing and <a name="indexId434909-55"></a><b><tt class="func">sendto()</tt></b> it out.  The
kernel builds the Transport Layer and Internet Layer on for you and the
hardware does the Network Access Layer.  Ah, modern technology.</p>

<p>So ends our brief foray into network theory.  Oh yes, I forgot to
tell you everything I wanted to say about routing: nothing!  That's
right, I'm not going to talk about it at all.  The router strips the
packet to the IP header, consults its routing table, <a name="indexId434909-56"></a>blah blah blah.  Check out the <a href="http://tools.ietf.org/html/rfc791" target="_blank">IP RFC</a> if you really really care.  If
you never learn about it, well, you'll live.</p>



 






<hr class="mainsectbreak"><h2 class="sect1title">3. <a name="ipstructsdata">IP Addresses, <nobr><b><tt class="titletype">struct</tt></b></nobr>s, and Data Munging</a></h2><hr class="mainsecthr">


<p>Here's the part of the game where we get to talk code for a
change.</p>

<p>But first, let's discuss more non-code!  Yay!  First I want to talk
about <a name="indexId434909-57"></a>IP addresses and ports for just a tad so we have
that sorted out.  Then we'll talk about how the sockets API stores and
manipulates IP addresses and other data.</p>



<h3 class="sect2title">3.1. <a name="ipaddrs1">IP Addresses, versions 4 and 6</a></h3>


<p>In the good old days back when Ben Kenobi was still called Obi Wan
Kenobi, there was a wonderful network routing system called The Internet
Protocol Version 4, also called <a name="indexId434909-58"></a>IPv4.  It had addresses
made up of four bytes (A.K.A. four "octets"), and was commonly written
in "dots and numbers" form, like so: <tt class="tt">192.0.2.111</tt>.</p>

<p>You've probably seen it around.</p>

<p>In fact, as of this writing, virtually every site on the Internet
uses IPv4.</p>

<p>Everyone, including Obi Wan, was happy.  Things were great, until
some naysayer by the name of Vint Cerf warned everyone that we were
about to run out of IPv4 addresses!</p>

<p>(Besides warning everyone of the Coming IPv4 Apocalypse Of Doom And
Gloom, <a name="indexId434909-59"></a><a href="http://en.wikipedia.org/wiki/Vinton_Cerf" target="_blank">Vint Cerf</a> is
also well-known for being The Father Of The Internet.  So I really am in
no position to second-guess his judgment.)</p>

<p>Run out of addresses?  How could this be?  I mean, there are like
billions of IP addresses in a 32-bit IPv4 address.  Do we really have
billions of computers out there?</p>

<p>Yes.</p>

<p>Also, in the beginning, when there were only a few computers and
everyone thought a billion was an impossibly large number, some big
organizations were generously allocated millions of IP addresses for
their own use.  (Such as Xerox, MIT, Ford, HP, IBM, GE, AT&amp;T, and
some little company called Apple, to name a few.)</p>

<p>In fact, if it weren't for several stopgap measures, we would have
run out a long time ago.</p>

<p>But now we're living in an era where we're talking about every human
having an IP address, every computer, every calculator, every phone,
every parking meter, and (why not) every puppy dog, as well.</p>

<p>And so, <a name="indexId434909-60"></a>IPv6 was born.  Since Vint Cerf is probably
immortal (even if his physical form should pass on, heaven forbid, he is
probably already existing as some kind of hyper-intelligent <a href="http://en.wikipedia.org/wiki/ELIZA" target="_blank">ELIZA</a> program out in the depths of the
Internet2), no one wants to have to hear him say again "I told you so"
if we don't have enough addresses in the next version of the Internet
Protocol.</p>

<p>What does this suggest to you?</p>

<p>That we need a <i>lot</i> more addresses.  That we need not just
twice as many addresses, not a billion times as many, not a thousand
trillion times as many, but <i>79 MILLION BILLION TRILLION times as
many possible addresses!</i>  That'll show 'em!</p>

<p>You're saying, "Beej, is that true?  I have every reason to
disbelieve large numbers."  Well, the difference between 32 bits and 128
bits might not sound like a lot; it's only 96 more bits, right?  But
remember, we're talking powers here: 32 bits represents some 4 billion
numbers (2<sup><small>32</small></sup>), while 128 bits represents about 340
trillion trillion trillion numbers (for real, 2<sup><small>128</small></sup>).
That's like a million IPv4 Internets for <i>every single star in the
Universe</i>.</p>

<p>Forget this dots-and-numbers look of IPv4, too; now we've got a
hexadecimal representation, with each two-byte chunk separated by a
colon, like this: <tt class="tt">2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551</tt>.</p>

<p>That's not all!  Lots of times, you'll have an IP address with lots
of zeros in it, and you can compress them between two colons.  And you
can leave off leading zeros for each byte pair.  For instance, each of
these pairs of addresses are equivalent:</p>

<pre class="screen">2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
</pre>


<p>The address <tt class="tt">::1</tt> is the <i>loopback address</i>.  It
always means "this machine I'm running on now".  In IPv4, the loopback
address is 127.0.0.1.</p>

<p>Finally, there's an IPv4-compatibility mode for IPv6 addresses that
you might come across.  If you want, for example, to represent the IPv4
address 192.0.2.33 as an IPv6 address, you use the following notation:
"<tt class="tt">::ffff:192.0.2.33</tt>".</p>

<p>We're talking serious fun.</p>

<p>In fact, it's such serious fun, that the Creators of IPv6 have quite
cavalierly lopped off trillions and trillions of addresses for reserved
use, but we have so many, frankly, who's even counting anymore?  There
are plenty left over for every man, woman, child, puppy, and parking
meter on every planet in the galaxy.  And believe me, every planet in
the galaxy has parking meters.  You know it's true.</p>



<h4 class="sect3title">3.1.1. <a name="netslash">Subnets</a></h4>


<p>For organizational reasons, it's sometimes convenient to declare that
"this first part of this IP address up through this bit is the
<i>network portion</i> of the IP address, and the remainder is the
<i>host portion</i>.</p>

<p>For instance, with IPv4, you might have <tt class="tt">192.0.2.12</tt>, and we could say
that the first three bytes are the network and the last byte was the
host.  Or, put another way, we're talking about host <tt class="tt">12</tt> on
network <tt class="tt">192.0.2.0</tt> (see how we zero out the byte that was the
host.)</p>

<p>And now for more outdated information!  Ready?  In the Ancient Times,
there were "classes" of subnets, where the first one, two, or three
bytes of the address was the network part.  If you were lucky enough to
have one byte for the network and three for the host, you could have
24 bits-worth of hosts on your network (16 million or so).  That was a
"Class A" network.  On the opposite end was a "Class C", with three
bytes of network, and one byte of host (256 hosts, minus a couple that
were reserved.)</p>

<p>So as you can see, there were just a few Class As, a huge pile of
Class Cs, and some Class Bs in the middle.</p>

<p>The network portion of the IP address is described by something
called the <i>netmask</i>, which you bitwise-AND with the IP address
to get the network number out of it.  The netmask usually looks
something like <tt class="tt">255.255.255.0</tt>.  (E.g. with that netmask, if your
IP is <tt class="tt">192.0.2.12</tt>, then your network is <tt class="tt">192.0.2.12</tt> AND
<tt class="tt">255.255.255.0</tt> which gives <tt class="tt">192.0.2.0</tt>.)</p>

<p>Unfortunately, it turned out that this wasn't fine-grained enough for
the eventual needs of the Internet; we were running out of Class C
networks quite quickly, and we were most definitely out of Class As, so
don't even bother to ask.  To remedy this, The Powers That Be allowed
for the netmask to be an arbitrary number of bits, not just 8, 16, or
24.  So you might have a netmask of, say <tt class="tt">255.255.255.252</tt>, which
is 30 bits of network, and 2 bits of host allowing for four hosts on the
network.  (Note that the netmask is <i>ALWAYS</i> a bunch of 1-bits
followed by a bunch of 0-bits.)</p>

<p>But it's a bit unwieldy to use a big string of numbers like
<tt class="tt">255.192.0.0</tt> as a netmask.  First of all, people don't have an
intuitive idea of how many bits that is, and secondly, it's really not
compact.  So the New Style came along, and it's much nicer.  You just
put a slash after the IP address, and then follow that by the number of
network bits in decimal.  Like this: <tt class="tt">192.0.2.12/30</tt>.</p>

<p>Or, for IPv6, something like this: <tt class="tt">2001:db8::/32</tt> or
<tt class="tt">2001:db8:5413:4028::9db9/64</tt>.</p>





<h4 class="sect3title">3.1.2. <a name="portnums">Port Numbers</a></h4>


<p>If you'll kindly remember, I presented you earlier with the <a href="#lowlevel">Layered Network Model</a> which had the Internet
Layer (IP) split off from the Host-to-Host Transport Layer (TCP and
UDP).  Get up to speed on that before the next paragraph.</p>

<p>Turns out that besides an IP address (used by the IP layer), there
is another address that is used by TCP (stream sockets) and,
coincidentally, by UDP (datagram sockets).  It is the <i>port
number</i>.  It's a 16-bit number that's like the local address for
the connection.</p>

<p>Think of the IP address as the street address of a hotel, and the
port number as the room number.  That's a decent analogy; maybe later
I'll come up with one involving the automobile industry.</p>

<p>Say you want to have a computer that handles incoming mail AND web
services‚Äîhow do you differentiate between the two on a computer
with a single IP address?</p>

<p>Well, different services on the Internet have different well-known
port numbers.  You can see them all in <a href="http://www.iana.org/assignments/port-numbers" target="_blank">the Big
IANA Port List</a> or, if you're on a Unix box, in your
<i><tt class="var">/etc/services</tt></i> file.  HTTP (the web) is port 80, telnet is
port 23, SMTP is port 25, the game <a href="http://en.wikipedia.org/wiki/Doom_(video_game)" target="_blank">DOOM</a>
used port 666, etc. and so on.  Ports under 1024 are often considered
special, and usually require special OS privileges to use.</p>

<p>And that's about it!</p>

 

 



<h3 class="sect2title">3.2. <a name="byteorder">Byte Order</a></h3>


<p><a name="indexId434909-61"></a>By Order of the Realm!  There shall be two
byte orderings, hereafter to be known as Lame and Magnificent!</p>

<p>I joke, but one really is better than the other.  <tt>:-)</tt></p>

<p>There really is no easy way to say this, so I'll just blurt it out:
your computer might have been storing bytes in reverse order behind your
back.  I know!  No one wanted to have to tell you.</p>

<p>The thing is, everyone in the Internet world has generally agreed
that if you want to represent the two-byte hex number, say
<tt class="tt">b34f</tt>, you'll store it in two sequential bytes <tt class="tt">b3</tt>
followed by <tt class="tt">4f</tt>.  Makes sense, and, as <a href="http://en.wikipedia.org/wiki/Wilford_Brimley" target="_blank">Wilford Brimley</a> would tell you, it's the Right
Thing To Do.  This number, stored with the big end first, is called
<i>Big-Endian</i>.</p>

<p>Unfortunately, a few computers scattered here and there throughout
the world, namely anything with an Intel or Intel-compatible processor,
store the bytes reversed, so <tt class="tt">b34f</tt> would be stored in memory as
the sequential bytes <tt class="tt">4f</tt> followed by <tt class="tt">b3</tt>.  This storage
method is called <i>Little-Endian</i>.</p>

<p>But wait, I'm not done with terminology yet!  The more-sane
<i>Big-Endian</i> is also called <i>Network Byte Order</i>
because that's the order us network types like.</p>

<p>Your computer stores numbers in <i>Host Byte Order</i>.  If it's
an Intel 80x86, Host Byte Order is Little-Endian.  If it's a Motorola
68k, Host Byte Order is Big-Endian.  If it's a PowerPC, Host Byte Order
is...  well, it depends!</p>

<p>A lot of times when you're building packets or filling out data
structures you'll need to make sure your two- and four-byte numbers are
in Network Byte Order.  But how can you do this if you don't know the
native Host Byte Order?</p>

<p>Good news!  You just get to assume the Host Byte Order isn't right,
and you always run the value through a function to set it to Network
Byte Order.  The function will do the magic conversion if it has to, and
this way your code is portable to machines of differing endianness.</p>

<p>All righty.  There are two types of numbers that you can convert:
<nobr><tt class="type">short</tt></nobr> (two bytes) and <nobr><tt class="type">long</tt></nobr> (four bytes).
These functions work for the <nobr><tt class="type">unsigned</tt></nobr> variations as well.
Say you want to convert a <nobr><tt class="type">short</tt></nobr> from Host Byte Order to
Network Byte Order.  Start with "h" for "host", follow it with "to",
then "n" for "network", and "s" for "short": h-to-n-s, or
<b><tt class="func">htons()</tt></b> (read: "Host to Network Short").</p>

<p>It's almost too easy...</p>

<p>You can use every combination of "n", "h", "s", and "l" you want,
not counting the really stupid ones.  For example, there is NOT a
<b><tt class="func">stolh()</tt></b> ("Short to Long Host") function‚Äînot at this
party, anyway.  But there are:</p>

<p>
</p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="20%%"><p><a name="indexId434909-62"></a><b><tt class="func">htons()</tt></b></p></td>
<td valign="top" align="left" width="78%%"><p><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">s</tt></b>hort</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-63"></a><b><tt class="func">htonl()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">l</tt></b>ong</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-64"></a><b><tt class="func">ntohs()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">s</tt></b>hort</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-65"></a><b><tt class="func">ntohl()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">l</tt></b>ong</p></td>
</tr>

</tbody></table></center>

<p></p>

<p>Basically, you'll want to convert the numbers to Network Byte Order
before they go out on the wire, and convert them to Host Byte Order as
they come in off the wire.</p>

<p>I don't know of a 64-bit variant, sorry.  And if you want to do
floating point, check out the section on <a href="#serialization">Serialization</a>, far below.</p>

<p>Assume the numbers in this document are in Host Byte Order unless I
say otherwise.</p>

 



<h3 class="sect2title">3.3. <a name="structs"><nobr><b><tt class="titletype">struct</tt></b></nobr>s</a></h3>


<p>Well, we're finally here.  It's time to talk about programming.
In this section, I'll cover various data types used by the sockets
interface, since some of them are a real bear to figure out.</p>

<p>First the easy one: a <a name="indexId434909-66"></a>socket descriptor.
A socket descriptor is the following type:</p>

<pre class="code">int</pre>


<p>Just a regular <nobr><tt class="type">int</tt></nobr>.</p>

<p>Things get weird from here, so just read through and bear with
me.</p>

<p>My First Struct<sup><small>TM</small></sup>‚Äî<a name="indexId434909-67"></a><nobr><tt class="type">struct
addrinfo</tt></nobr>.  This structure is a more recent invention, and is used
to prep the socket address structures for subsequent use.  It's also
used in host name lookups, and service name lookups.  That'll make more
sense later when we get to actual usage, but just know for now that it's
one of the first things you'll call when making a connection.</p>

<pre class="code">struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for "any"
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // linked list, next node
};</pre>


<p>You'll load this struct up a bit, and then call <a name="indexId434909-68"></a><b><tt class="func">getaddrinfo()</tt></b>.  It'll return a pointer
to a new linked list of these structures filled out with all the goodies
you need.</p>

<p>You can force it to use IPv4 or IPv6 in the <i><tt class="var">ai_family</tt></i>
field, or leave it as <tt class="const">AF_UNSPEC</tt> to use whatever.  This is
cool because your code can be IP version-agnostic.</p>

<p>Note that this is a linked list: <i><tt class="var">ai_next</tt></i> points at the
next element‚Äîthere could be several results for you to choose
from.  I'd use the first result that worked, but you might have
different business needs; I don't know everything, man!</p>

<p>You'll see that the <i><tt class="var">ai_addr</tt></i> field in the <nobr><tt class="type">struct
addrinfo</tt></nobr> is a pointer to a <a name="indexId434909-69"></a><nobr><tt class="type">struct sockaddr</tt></nobr>.  This is where we start getting
into the nitty-gritty details of what's inside an IP address
structure.</p>

<p>You might not usually need to write to these structures; oftentimes,
a call to <b><tt class="func">getaddrinfo()</tt></b> to fill out your <nobr><tt class="type">struct
addrinfo</tt></nobr> for you is all you'll need.  You <i>will</i>,
however, have to peer inside these <nobr><tt class="type">struct</tt></nobr>s to get the
values out, so I'm presenting them here.</p>

<p>(Also, all the code written before <nobr><tt class="type">struct addrinfo</tt></nobr> was
invented we packed all this stuff by hand, so you'll see a lot of IPv4
code out in the wild that does exactly that.  You know, in old versions
of this guide and so on.)</p>

<p>Some <nobr><tt class="type">struct</tt></nobr>s are IPv4, some are IPv6, and some are both.
I'll make notes of which are what.</p>

<p>Anyway, the <nobr><tt class="type">struct sockaddr</tt></nobr> holds socket address
information for many types of sockets.</p>

<pre class="code">struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx
    char              sa_data[14];  // 14 bytes of protocol address
}; 
</pre>


<p><i><tt class="var">sa_family</tt></i> can be a variety of things, but it'll be <a name="indexId434909-70"></a><tt class="const">AF_INET</tt> (IPv4) or <a name="indexId434909-71"></a><tt class="const">AF_INET6</tt> (IPv6) for everything we do in
this document.  <i><tt class="var">sa_data</tt></i> contains a destination address
and port number for the socket.  This is rather unwieldy since you don't
want to tediously pack the address in the <i><tt class="var">sa_data</tt></i> by
hand.</p>

<p>To deal with <nobr><tt class="type">struct sockaddr</tt></nobr>, programmers created a
parallel structure: <a name="indexId434909-72"></a><nobr><tt class="type">struct
sockaddr_in</tt></nobr> ("in" for "Internet") to be used with IPv4.</p>

<p>And <i>this is the important</i> bit: a pointer to a <nobr><tt class="type">struct
sockaddr_in</tt></nobr> can be cast to a pointer to a <nobr><tt class="type">struct
sockaddr</tt></nobr> and vice-versa.  So even though <b><tt class="func">connect()</tt></b>
wants a <nobr><tt class="type">struct sockaddr*</tt></nobr>, you can still use a <nobr><tt class="type">struct
sockaddr_in</tt></nobr> and cast it at the last minute!</p>

<pre class="code">// (IPv4 only--see struct sockaddr_in6 for IPv6)

struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET
    unsigned short int sin_port;    // Port number
    struct in_addr     sin_addr;    // Internet address
    unsigned char      sin_zero[8]; // Same size as struct sockaddr
};
</pre>


<p>This structure makes it easy to reference elements of the socket
address.  Note that <i><tt class="var">sin_zero</tt></i> (which is included to pad
the structure to the length of a <nobr><tt class="type">struct sockaddr</tt></nobr>) should be
set to all zeros with the function <b><tt class="func">memset()</tt></b>.  Also, notice
that <i><tt class="var">sin_family</tt></i> corresponds to <i><tt class="var">sa_family</tt></i>
in a <nobr><tt class="type">struct sockaddr</tt></nobr> and should be set to
"<tt class="const">AF_INET</tt>".  Finally, the <i><tt class="var">sin_port</tt></i> must be
in <a name="indexId434909-73"></a><i>Network Byte Order</i> (by using <a name="indexId434909-74"></a><b><tt class="func">htons()</tt></b>!)</p>

<p>Let's dig deeper!  You see the <i><tt class="var">sin_addr</tt></i> field is a
<nobr><tt class="type">struct in_addr</tt></nobr>.  What is that thing?  Well, not to be
overly dramatic, but it's one of the scariest unions of all time:</p>

<pre class="code">// (IPv4 only--see struct in6_addr for IPv6)

// Internet address (a structure for historical reasons)
struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
};</pre>


<p>Whoa!  Well, it <i>used</i> to be a union, but now those days
seem to be gone.  Good riddance.  So if you have declared
<i><tt class="var">ina</tt></i> to be of type <nobr><tt class="type">struct sockaddr_in</tt></nobr>, then
<i><tt class="var">ina.sin_addr.s_addr</tt></i> references the 4-byte IP address (in
Network Byte Order).  Note that even if your system still uses the
God-awful union for <nobr><tt class="type">struct in_addr</tt></nobr>, you can still reference
the 4-byte IP address in exactly the same way as I did above (this due
to <tt class="tt">#define</tt>s.)</p>

<p>What about <a name="indexId434909-75"></a>IPv6?  Similar <nobr><tt class="type">struct</tt></nobr>s exist
for it, as well:</p>

<pre class="code">// (IPv6 only--see struct sockaddr_in and struct in_addr for IPv4)

struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port number, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};</pre>


<p>Note that IPv6 has an IPv6 address and a port number, just like IPv4
has an IPv4 address and a port number.</p>

<p>Also note that I'm not going to talk about the IPv6 flow information
or Scope ID fields for the moment... this is just a starter guide.
<tt>:-)</tt></p>

<p>Last but not least, here is another simple structure, <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> that is designed
to be large enough to hold both IPv4 and IPv6 structures.  (See, for
some calls, sometimes you don't know in advance if it's going to fill
out your <nobr><tt class="type">struct sockaddr</tt></nobr> with an IPv4 or IPv6 address.  So
you pass in this parallel structure, very similar to <nobr><tt class="type">struct
sockaddr</tt></nobr> except larger, and then cast it to the type you
need:</p>

<pre class="code">struct sockaddr_storage {
    sa_family_t  ss_family;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};</pre>


<p>What's important is that you can see the address family in the
<i><tt class="var">ss_family</tt></i> field‚Äîcheck this to see if it's
<tt class="const">AF_INET</tt> or <tt class="const">AF_INET6</tt> (for IPv4 or
IPv6).  Then you can cast it to a <nobr><tt class="type">struct sockaddr_in</tt></nobr> or
<nobr><tt class="type">struct sockaddr_in6</tt></nobr> if you wanna.</p>

 






<h3 class="sect2title">3.4. <a name="ipaddrs2">IP Addresses, Part Deux</a></h3>


<p>Fortunately for you, there are a bunch of functions that allow you to
manipulate <a name="indexId434909-76"></a>IP addresses.  No need to figure them out by
hand and stuff them in a <nobr><tt class="type">long</tt></nobr> with the
<tt class="tt">&lt;&lt;</tt> operator.</p>

<p>First, let's say you have a <nobr><tt class="type">struct sockaddr_in ina</tt></nobr>, and
you have an IP address "<tt class="tt">10.12.110.57</tt>" or
"<tt class="tt">2001:db8:63b3:1::3490</tt>" that you want to store into it.  The
function you want to use, <a name="indexId434909-77"></a>
<b><tt class="func">inet_pton()</tt></b>, converts an IP address in numbers-and-dots
notation into either a <nobr><tt class="type">struct in_addr</tt></nobr> or a <nobr><tt class="type">struct
in6_addr</tt></nobr> depending on whether you specify <tt class="const">AF_INET</tt>
or <tt class="const">AF_INET6</tt>.  ("pton" stands for "presentation to
network"‚Äîyou can call it "printable to network" if that's easier
to remember.)  The conversion can be made as follows:</p>

<pre class="code">struct sockaddr_in sa; // IPv4
struct sockaddr_in6 sa6; // IPv6

inet_pton(AF_INET, "10.12.110.57", &amp;(sa.sin_addr)); // IPv4
inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &amp;(sa6.sin6_addr)); // IPv6</pre>


<p>(Quick note: the old way of doing things used a function called <a name="indexId434909-78"></a><b><tt class="func">inet_addr()</tt></b> or another function called
<a name="indexId434909-79"></a><b><tt class="func">inet_aton()</tt></b>; these are now obsolete
and don't work with IPv6.)</p>

<p>Now, the above code snippet isn't very robust because there is no
error checking.  See, <b><tt class="func">inet_pton()</tt></b> returns
<tt class="const">-1</tt> on error, or 0 if the address is messed up.  So check
to make sure the result is greater than 0 before using!</p>

<p>All right, now you can convert string IP addresses to their binary
representations.  What about the other way around?  What if you have a
<nobr><tt class="type">struct in_addr</tt></nobr> and you want to print it in numbers-and-dots
notation?   (Or a <nobr><tt class="type">struct in6_addr</tt></nobr> that you want in, uh,
"hex-and-colons" notation.)  In this case, you'll want to use the
function <a name="indexId434909-80"></a><b><tt class="func">inet_ntop()</tt></b> ("ntop" means
"network to presentation"‚Äîyou can call it "network to printable"
if that's easier to remember), like this:</p>

<pre class="code">// IPv4:

char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something

inet_ntop(AF_INET, &amp;(sa.sin_addr), ip4, INET_ADDRSTRLEN);

printf("The IPv4 address is: %s\n", ip4);


// IPv6:

char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something

inet_ntop(AF_INET6, &amp;(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);

printf("The address is: %s\n", ip6);</pre>


<p>When you call it, you'll pass the address type (IPv4 or IPv6), the
address, a pointer to a string to hold the result, and the maximum
length of that string.  (Two macros conveniently hold the size of the
string you'll need to hold the largest IPv4 or IPv6 address:
<tt class="const">INET_ADDRSTRLEN</tt> and <tt class="const">INET6_ADDRSTRLEN</tt>.)</p>

<p>(Another quick note to mention once again the old way of doing
things: the historical function to do this conversion was called <a name="indexId434909-81"></a><b><tt class="func">inet_ntoa()</tt></b>.  It's also obsolete and
won't work with IPv6.)</p>

<p>Lastly, these functions only work with numeric IP
addresses‚Äîthey won't do any nameserver DNS lookup on a hostname,
like "www.example.com".  You will use <b><tt class="func">getaddrinfo()</tt></b> to do
that, as you'll see later on.</p>



<h4 class="sect3title">3.4.1. <a name="privnet">Private (Or Disconnected) Networks</a></h4>


<p><a name="indexId434909-82"></a>Lots of places have a <a name="indexId434909-83"></a>firewall that hides the network from the rest of the
world for their own protection.  And often times, the firewall
translates "internal" IP addresses to "external" (that everyone else in
the world knows) IP addresses using a process called <i>Network
Address Translation</i>, or <a name="indexId434909-84"></a>NAT.</p>

<p>Are you getting nervous yet?  "Where's he going with all this weird
stuff?"</p>

<p>Well, relax and buy yourself a non-alcoholic (or alcoholic) drink,
because as a beginner, you don't even have to worry about NAT, since
it's done for you transparently.  But I wanted to talk about the network
behind the firewall in case you started getting confused by the network
numbers you were seeing.</p>

<p>For instance, I have a firewall at home.  I have two static IPv4
addresses allocated to me by the DSL company, and yet I have seven
computers on the network.  How is this possible?  Two computers can't
share the same IP address, or else the data wouldn't know which one to
go to!</p>

<p>The answer is: they don't share the same IP addresses.  They are on a
private network with 24 million IP addresses allocated to it.  They are
all just for me.  Well, all for me as far as anyone else is concerned.
Here's what's happening:</p>

<p>If I log into a remote computer, it tells me I'm logged in from
192.0.2.33 which is the public IP address my ISP has provided to me.
But if I ask my local computer what its IP address is, it says 10.0.0.5.
Who is translating the IP address from one to the other?  That's right,
the firewall!  It's doing NAT!</p>

<p>10.<i>x</i>.<i>x</i>.<i>x</i> is one of a few reserved
networks that are only to be used either on fully disconnected networks,
or on networks that are behind firewalls.  The details of which private
network numbers are available for you to use are outlined in <a href="http://tools.ietf.org/html/rfc1918" target="_blank">RFC 1918</a>,
but some common ones you'll see are <a name="indexId434909-85"></a>10.<i>x</i>.<i>x</i>.<i>x</i> and <a name="indexId434909-86"></a>192.168.<i>x</i>.<i>x</i>, where <i>x</i>
is 0-255, generally.  Less common is
172.<i>y</i>.<i>x</i>.<i>x</i>, where <i>y</i> goes
between 16 and 31.</p>

<p>Networks behind a NATing firewall don't <i>need</i> to be on one
of these reserved networks, but they commonly are.</p>

<p>(Fun fact!  My external IP address isn't really 192.0.2.33.  The
192.0.2.<i>x</i> network is reserved for make-believe "real" IP
addresses to be used in documentation, just like this guide!
Wowzers!)</p>

<p><a name="indexId434909-87"></a>IPv6 has private networks, too, in a sense.  They'll
start with <tt class="tt">fd<i>xx</i>:</tt> (or maybe in the future
<tt class="tt">fc<i>XX</i>:</tt>), as per <a href="http://tools.ietf.org/html/rfc4193" target="_blank">RFC 4193</a>.  NAT and IPv6 don't
generally mix, however (unless you're doing the IPv6 to IPv4 gateway
thing which is beyond the scope of this document)‚Äîin theory
you'll have so many addresses at your disposal that you won't need to
use NAT any longer.  But if you want to allocate addresses for yourself
on a network that won't route outside, this is how to do it.</p>

 

 

 






<hr class="mainsectbreak"><h2 class="sect1title">4. <a name="ip4to6">Jumping from IPv4 to IPv6</a></h2><hr class="mainsecthr">


<p><a name="indexId434909-88"></a>But I just want to know what to change in my code to
get it going with IPv6!  Tell me now!</p>

<p>Ok! Ok!</p>

<p>Almost everything in here is something I've gone over, above, but
it's the short version for the impatient.  (Of course, there is more
than this, but this is what applies to the guide.)</p>

<ol>

<li>First of all, try to use <a name="indexId434909-89"></a><a href="#getaddrinfo"><b><tt class="func">getaddrinfo()</tt></b></a> to get all the
<nobr><tt class="type">struct sockaddr</tt></nobr> info, instead of packing the structures by
hand.  This will keep you IP version-agnostic, and will eliminate many
of the subsequent steps.</li>


<li>Any place that you find you're hard-coding anything related to the
IP version, try to wrap up in a helper function.</li>


<li>Change <tt class="const">AF_INET</tt> to <tt class="const">AF_INET6</tt>.</li>


<li>Change <tt class="const">PF_INET</tt> to <tt class="const">PF_INET6</tt>.</li>


<li><p>Change <tt class="const">INADDR_ANY</tt> assignments to
<tt class="const">in6addr_any</tt> assignments, which are slightly
different:</p>

<pre class="code">struct sockaddr_in sa;
struct sockaddr_in6 sa6;

sa.sin_addr.s_addr = INADDR_ANY;  // use my IPv4 address
sa6.sin6_addr = in6addr_any; // use my IPv6 address</pre>


<p>Also, the value <tt class="const">IN6ADDR_ANY_INIT</tt> can be used as an
initializer when the <nobr><tt class="type">struct in6_addr</tt></nobr> is declared, like
so:</p>

<pre class="code">struct in6_addr ia6 = IN6ADDR_ANY_INIT;</pre>

<p></p> 
</li>


<li>Instead of <nobr><tt class="type">struct sockaddr_in</tt></nobr> use <nobr><tt class="type">struct
sockaddr_in6</tt></nobr>, being sure to add "6" to the fields as appropriate
(see <a href="#structs"><nobr><tt class="type">struct</tt></nobr>s</a>, above).  There is
no <i><tt class="var">sin6_zero</tt></i> field.</li>


<li>Instead of <nobr><tt class="type">struct in_addr</tt></nobr> use <nobr><tt class="type">struct
in6_addr</tt></nobr>, being sure to add "6" to the fields as appropriate (see
<a href="#structs"><nobr><tt class="type">struct</tt></nobr>s</a>, above).</li>


<li>Instead of <b><tt class="func">inet_aton()</tt></b> or <b><tt class="func">inet_addr()</tt></b>, use
<b><tt class="func">inet_pton()</tt></b>.</li>


<li>Instead of <b><tt class="func">inet_ntoa()</tt></b>, use
<b><tt class="func">inet_ntop()</tt></b>.</li>


<li>Instead of <b><tt class="func">gethostbyname()</tt></b>, use the superior
<b><tt class="func">getaddrinfo()</tt></b>.</li>


<li>Instead of <b><tt class="func">gethostbyaddr()</tt></b>, use the superior <a name="indexId434909-90"></a><b><tt class="func">getnameinfo()</tt></b> (although
<b><tt class="func">gethostbyaddr()</tt></b> can still work with IPv6).</li>


<li><tt class="const">INADDR_BROADCAST</tt> no longer works.  Use IPv6 multicast
instead.</li>


</ol>


<p><i>Et voila</i>!</p>








<hr class="mainsectbreak"><h2 class="sect1title">5. <a name="syscalls">System Calls or Bust</a></h2><hr class="mainsecthr">


<p>This is the section where we get into the system calls (and other
library calls) that allow you to access the network functionality of a
Unix box, or any box that supports the sockets API for that matter (BSD,
Windows, Linux, Mac, what-have-you.)  When you call one of these
functions, the kernel takes over and does all the work for you
automagically.</p>

<p>The place most people get stuck around here is what order to call
these things in.  In that, the <b class="com">man</b> pages are no use,
as you've probably discovered.  Well, to help with that dreadful
situation, I've tried to lay out the system calls in the following
sections in <i>exactly</i> (approximately) the same order
that you'll need to call them in your programs.</p>

<p>That, coupled with a few pieces of sample code here and there,
some milk and cookies (which I fear you will have to supply yourself),
and some raw guts and courage, and you'll be beaming data around the
Internet like the Son of Jon Postel!</p>

<p><i>(Please note that for brevity, many code snippets below do not
include necessary error checking.  And they very commonly assume that
the result from calls to <b><tt class="func">getaddrinfo()</tt></b> succeed and return a
valid entry in the linked list.  Both of these situations are properly
addressed in the stand-alone programs, though, so use those as a
model.)</i></p>






<h3 class="sect2title">5.1. <a name="getaddrinfo"><b><tt class="titlefunc">getaddrinfo()</tt></b>‚ÄîPrepare to launch!</a></h3>


<p><a name="indexId434909-91"></a>This is a real workhorse of a function with
a lot of options, but usage is actually pretty simple.  It helps set up
the <nobr><tt class="type">struct</tt></nobr>s you need later on.</p>

<p>A tiny bit of history: it used to be that you would use a function
called <b><tt class="func">gethostbyname()</tt></b> to do DNS lookups.  Then you'd
load that information by hand into a <nobr><tt class="type">struct sockaddr_in</tt></nobr>,
and use that in your calls.</p>

<p>This is no longer necessary, thankfully.  (Nor is it desirable, if
you want to write code that works for both IPv4 and IPv6!)  In these
modern times, you now have the function <b><tt class="func">getaddrinfo()</tt></b> that
does all kinds of good stuff for you, including DNS and service name
lookups, and fills out the <nobr><tt class="type">struct</tt></nobr>s you need, besides!</p>

<p>Let's take a look!</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *node,     // e.g. "www.example.com" or IP
                const char *service,  // e.g. "http" or port number
                const struct addrinfo *hints,
                struct addrinfo **res);</pre>


<p>You give this function three input parameters, and it gives you a
pointer to a linked-list, <i><tt class="var">res</tt></i>, of results.</p>

<p>The <i><tt class="var">node</tt></i> parameter is the host name to connect to, or
an IP address.</p>

<p>Next is the parameter <i><tt class="var">service</tt></i>, which can be a port
number, like "80", or the name of a particular service (found in <a href="http://www.iana.org/assignments/port-numbers" target="_blank">The IANA Port List</a> or the
<i><tt class="var">/etc/services</tt></i> file on your Unix machine) like "http" or
"ftp" or "telnet" or "smtp" or whatever.</p>

<p>Finally, the <i><tt class="var">hints</tt></i> parameter points to a <nobr><tt class="type">struct
addrinfo</tt></nobr> that you've already filled out with relevant
information.</p>

<p>Here's a sample call if you're a server who wants to listen on your
host's IP address, port 3490.  Note that this doesn't actually do any
listening or network setup; it merely sets up structures we'll use
later:</p>

<pre class="code">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

if ((status = getaddrinfo(NULL, "3490", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(status));
    exit(1);
}

// servinfo now points to a linked list of 1 or more struct addrinfos

// ... do everything until you don't need servinfo anymore ....

freeaddrinfo(servinfo); // free the linked-list</pre>


<p>Notice that I set the <i><tt class="var">ai_family</tt></i> to
<tt class="const">AF_UNSPEC</tt>, thereby saying that I don't care if we use
IPv4 or IPv6.  You can set it to <tt class="const">AF_INET</tt> or
<tt class="const">AF_INET6</tt> if you want one or the other specifically.</p>

<p>Also, you'll see the <tt class="const">AI_PASSIVE</tt> flag in there; this
tells <b><tt class="func">getaddrinfo()</tt></b> to assign the address of my local host
to the socket structures.  This is nice because then you don't have to
hardcode it.  (Or you can put a specific address in as the first
parameter to <b><tt class="func">getaddrinfo()</tt></b> where I currently have
<tt class="const">NULL</tt>, up there.)</p>

<p>Then we make the call.  If there's an error
(<b><tt class="func">getaddrinfo()</tt></b> returns non-zero), we can print it out using
the function <b><tt class="func">gai_strerror()</tt></b>, as you see.  If everything
works properly, though, <i><tt class="var">servinfo</tt></i> will point to a linked list
of <nobr><tt class="type">struct addrinfo</tt></nobr>s, each of which contains a <nobr><tt class="type">struct
sockaddr</tt></nobr> of some kind that we can use later!  Nifty!</p>

<p>Finally, when we're eventually all done with the linked list that
<b><tt class="func">getaddrinfo()</tt></b> so graciously allocated for us, we can (and
should) free it all up with a call to <b><tt class="func">freeaddrinfo()</tt></b>.</p>

<p>Here's a sample call if you're a client who wants to connect to a
particular server, say "www.example.net" port 3490.  Again, this doesn't
actually connect, but it sets up the structures we'll use later:</p>

<pre class="code">int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&amp;hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

// get ready to connect
status = getaddrinfo("www.example.net", "3490", &amp;hints, &amp;servinfo);

// servinfo now points to a linked list of 1 or more struct addrinfos

// etc.</pre>


<p>I keep saying that <i><tt class="var">servinfo</tt></i> is a linked list with all
kinds of address information.  Let's write a quick demo program to show
off this information.  <a href="http://beej.us/guide/bgnet/examples/showip.c" target="_blank">This short
program</a> will print the IP addresses for whatever host you
specify on the command line:</p>

<pre class="code">/*
** showip.c -- show IP addresses for a host given on the command line
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netinet/in.h&gt;

int main(int argc, char *argv[])
{
    struct addrinfo hints, *res, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"usage: showip hostname\n");
        return 1;
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // AF_INET or AF_INET6 to force version
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(argv[1], NULL, &amp;hints, &amp;res)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
        return 2;
    }

    printf("IP addresses for %s:\n\n", argv[1]);

    for(p = res;p != NULL; p = p-&gt;ai_next) {
        void *addr;
        char *ipver;

        // get the pointer to the address itself,
        // different fields in IPv4 and IPv6:
        if (p-&gt;ai_family == AF_INET) { // IPv4
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)p-&gt;ai_addr;
            addr = &amp;(ipv4-&gt;sin_addr);
            ipver = "IPv4";
        } else { // IPv6
            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p-&gt;ai_addr;
            addr = &amp;(ipv6-&gt;sin6_addr);
            ipver = "IPv6";
        }

        // convert the IP to a string and print it:
        inet_ntop(p-&gt;ai_family, addr, ipstr, sizeof ipstr);
        printf("  %s: %s\n", ipver, ipstr);
    }

    freeaddrinfo(res); // free the linked list

    return 0;
}</pre>


<p>As you see, the code calls <b><tt class="func">getaddrinfo()</tt></b> on whatever you
pass on the command line, that fills out the linked list pointed to by
<i><tt class="var">res</tt></i>, and then we can iterate over the list and print stuff
out or do whatever.</p>

<p>(There's a little bit of ugliness there where we have to dig into the
different types of <nobr><tt class="type">struct sockaddr</tt></nobr>s depending on the IP
version.  Sorry about that!  I'm not sure of a better way around
it.)</p>

<p>Sample run!  Everyone loves screenshots:</p>

<pre class="screen">$ <b class="com">showip www.example.net</b>
IP addresses for www.example.net:

  IPv4: 192.0.2.88

$ <b class="com">showip ipv6.example.com</b>
IP addresses for ipv6.example.com:

  IPv4: 192.0.2.101
  IPv6: 2001:db8:8c00:22::171</pre>


<p>Now that we have that under control, we'll use the results we get
from <b><tt class="func">getaddrinfo()</tt></b> to pass to other socket functions and,
at long last, get our network connection established!  Keep reading!</p>

 






<h3 class="sect2title">5.2. <a name="socket"><b><tt class="titlefunc">socket()</tt></b>‚ÄîGet the File Descriptor!</a></h3>


<p>I guess I can put it off no longer‚ÄîI have to talk about the
<a name="indexId434909-92"></a><b><tt class="func">socket()</tt></b> system call.  Here's the
breakdown:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol); 
</pre>


<p>But what are these arguments?  They allow you to say what kind of
socket you want (IPv4 or IPv6, stream or datagram, and TCP or UDP).</p>

<p>It used to be people would hardcode these values, and you can
absolutely still do that.  (<i><tt class="var">domain</tt></i> is
<tt class="const">PF_INET</tt> or <tt class="const">PF_INET6</tt>, <i><tt class="var">type</tt></i>
is <tt class="const">SOCK_STREAM</tt> or <tt class="const">SOCK_DGRAM</tt>, and
<i><tt class="var">protocol</tt></i> can be set to <tt class="const">0</tt> to choose the
proper protocol for the given <tt class="const">type</tt>.  Or you can call
<b><tt class="func">getprotobyname()</tt></b> to look up the protocol you want, "tcp" or
"udp".)</p>

<p>(This <tt class="const">PF_INET</tt> thing is a close relative of the <a name="indexId434909-93"></a><tt class="const">AF_INET</tt> that you can use when initializing
the <i><tt class="var">sin_family</tt></i> field in your <nobr><tt class="type">struct sockaddr_in</tt></nobr>.
In fact, they're so closely related that they actually have the same
value, and many programmers will call <b><tt class="func">socket()</tt></b> and pass
<tt class="const">AF_INET</tt> as the first argument instead of
<b><tt class="func">PF_INET</tt></b>.  Now, get some milk and cookies, because it's
times for a story.  Once upon a time, a long time ago, it was thought
that maybe an address family (what the "AF" in "<tt class="const">AF_INET</tt>"
stands for) might support several protocols that were referred to by
their protocol family (what the "PF" in "<tt class="const">PF_INET</tt>" stands
for).  That didn't happen.  And they all lived happily ever after, The
End.  So the most correct thing to do is to use <tt class="const">AF_INET</tt>
in your <nobr><tt class="type">struct sockaddr_in</tt></nobr> and <tt class="const">PF_INET</tt> in
your call to <b><tt class="func">socket()</tt></b>.)</p>

<p>Anyway, enough of that.  What you really want to do is use the values
from the results of the call to <b><tt class="func">getaddrinfo()</tt></b>, and feed
them into <b><tt class="func">socket()</tt></b> directly like this:</p>

<pre class="code">int s;
struct addrinfo hints, *res;

// do the lookup
// [pretend we already filled out the "hints" struct]
getaddrinfo("www.example.com", "http", &amp;hints, &amp;res);

// [again, you should do error-checking on getaddrinfo(), and walk
// the "res" linked list looking for valid entries instead of just
// assuming the first one is good (like many of these examples do.)
// <a href="#clientserver">See the section on client/server</a> for real examples.]

s = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</pre>


<p><b><tt class="func">socket()</tt></b> simply returns to you a <i>socket
descriptor</i> that you can use in later system calls, or
<tt class="const">-1</tt> on error.  The global variable <i><tt class="var">errno</tt></i> is set
to the error's value (see the <a href="#errnoman"><i><tt class="var">errno</tt></i></a> man page for more details, and a
quick note on using <i><tt class="var">errno</tt></i> in multithreaded programs.)</p>

<p>Fine, fine, fine, but what good is this socket?  The answer is
that it's really no good by itself, and you need to read on and make
more system calls for it to make any sense.</p>








<h3 class="sect2title">5.3. <a name="bind"><b><tt class="titlefunc">bind()</tt></b>‚ÄîWhat port am I on?</a></h3>


<p><a name="indexId434909-94"></a>Once you have a socket, you might have to associate
that socket with a <a name="indexId434909-95"></a>port on your local machine.  (This
is commonly done if you're going to <a name="indexId434909-96"></a><b><tt class="func">listen()</tt></b> for incoming connections on a
specific port‚Äîmultiplayer network games do this when they tell
you to "connect to 192.168.5.10 port 3490".)  The port number is used by
the kernel to match an incoming packet to a certain process's socket
descriptor.  If you're going to only be doing a <a name="indexId434909-97"></a><b><tt class="func">connect()</tt></b> (because you're the client, not
the server), this is probably be unnecessary.  Read it anyway, just for
kicks.</p>

<p>Here is the synopsis for the <b><tt class="func">bind()</tt></b> system
call:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *my_addr, int addrlen);
</pre>


<p><i><tt class="var">sockfd</tt></i> is the socket file descriptor returned by
<b><tt class="func">socket()</tt></b>.  <i><tt class="var">my_addr</tt></i> is a pointer to a
<nobr><tt class="type">struct sockaddr</tt></nobr> that contains information about your
address, namely, port and <a name="indexId434909-98"></a>IP address.
<i><tt class="var">addrlen</tt></i> is the length in bytes of that address.</p>

<p>Whew.  That's a bit to absorb in one chunk.  Let's have an
example that binds the socket to the host the program is running on,
port 3490:</p>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<p>By using the <tt class="const">AI_PASSIVE</tt> flag, I'm telling the program
to bind to the IP of the host it's running on.  If you want to bind to a
specific local IP address, drop the <tt class="const">AI_PASSIVE</tt> and put an
IP address in for the first argument to <b><tt class="func">getaddrinfo()</tt></b>.</p>

<p><b><tt class="func">bind()</tt></b> also returns <tt class="const">-1</tt>
on error and sets <i><tt class="var">errno</tt></i> to the error's
value.</p>

<p>Lots of old code manually packs the <nobr><tt class="type">struct sockaddr_in</tt></nobr>
before calling <b><tt class="func">bind()</tt></b>.  Obviously this is IPv4-specific,
but there's really nothing stopping you from doing the same thing with
IPv6, except that using <b><tt class="func">getaddrinfo()</tt></b> is going to be
easier, generally.  Anyway, the old code looks something like this:</p>

<pre class="code">// !!! THIS IS THE OLD WAY !!!

int sockfd;
struct sockaddr_in my_addr;

sockfd = socket(PF_INET, SOCK_STREAM, 0);

my_addr.sin_family = AF_INET;
my_addr.sin_port = htons(MYPORT);     // short, network byte order
my_addr.sin_addr.s_addr = inet_addr("10.12.110.57");
memset(my_addr.sin_zero, '\0', sizeof my_addr.sin_zero);

bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof my_addr);</pre>


<p>In the above code, you could also assign <tt class="const">INADDR_ANY</tt> to
the <i><tt class="var">s_addr</tt></i> field if you wanted to bind to your local IP
address (like the <tt class="const">AI_PASSIVE</tt> flag, above.)  The IPv6
version of <tt class="const">INADDR_ANY</tt> is a global variable
<i><tt class="var">in6addr_any</tt></i> that is assigned into the <i><tt class="var">sin6_addr</tt></i>
field of your <nobr><tt class="type">struct sockaddr_in6</tt></nobr>.  (There is also a macro
<tt class="const">IN6ADDR_ANY_INIT</tt> that you can use in a variable
initializer.)</p>

<p>Another thing to watch out for when calling <b><tt class="func">bind()</tt></b>:
don't go underboard with your port numbers.  <a name="indexId434909-99"></a>All ports
below 1024 are RESERVED (unless you're the superuser)!  You can have any
port number above that, right up to 65535 (provided they aren't already
being used by another program.)</p>

<p>Sometimes, you might notice, you try to rerun a server and
<b><tt class="func">bind()</tt></b> fails, claiming <a name="indexId434909-100"></a>"Address
already in use." What does that mean?  Well, a little bit of a socket
that was connected is still hanging around in the kernel, and it's
hogging the port.  You can either wait for it to clear (a minute or so),
or add code to your program allowing it to reuse the port, like
this:</p>

<pre class="code"><a name="indexId434909-101"></a><a name="indexId434909-102"></a>int yes=1;
//char yes='1'; // Solaris people use this

// lose the pesky "Address already in use" error message
if (setsockopt(listener,SOL_SOCKET,SO_REUSEADDR,&amp;yes,sizeof yes) == -1) {
    perror("setsockopt");
    exit(1);
} 
</pre>


<p><a name="indexId434909-103"></a>One small extra final note about
<b><tt class="func">bind()</tt></b>: there are times when you won't absolutely have to
call it.  If you are <a name="indexId434909-104"></a><b><tt class="func">connect()</tt></b>ing to a
remote machine and you don't care what your local port is (as is the
case with <b class="com">telnet</b> where you only care about the remote port),
you can simply call <b><tt class="func">connect()</tt></b>, it'll check to see if the
socket is unbound, and will <b><tt class="func">bind()</tt></b> it to an unused local
port if necessary.</p>








<h3 class="sect2title">5.4. <a name="connect"><b><tt class="titlefunc">connect()</tt></b>‚ÄîHey, you!</a></h3>


<p><a name="indexId434909-105"></a>Let's just pretend for a few minutes that you're
a telnet application.  Your user commands you (just like in the movie
<a name="indexId434909-106"></a><i>TRON</i>) to get a socket file descriptor.  You
comply and call <b><tt class="func">socket()</tt></b>.  Next, the user tells you to
connect to "<tt class="tt">10.12.110.57</tt>" on port "<tt class="tt">23</tt>" (the standard
telnet port.)  Yow!  What do you do now?</p>

<p>Lucky for you, program, you're now perusing the section on
<b><tt class="func">connect()</tt></b>‚Äîhow to connect to a remote host.  So read
furiously onward!  No time to lose!</p>

<p>The <b><tt class="func">connect()</tt></b> call is as follows:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 
</pre>


<p><i><tt class="var">sockfd</tt></i> is our friendly neighborhood socket
file descriptor, as returned by the <b><tt class="func">socket()</tt></b> call,
<i><tt class="var">serv_addr</tt></i> is a <nobr><tt class="type">struct sockaddr</tt></nobr>
containing the destination port and IP address, and
<i><tt class="var">addrlen</tt></i> is the length in bytes of the server address
structure.</p>

<p>All of this information can be gleaned from the results of the
<b><tt class="func">getaddrinfo()</tt></b> call, which rocks.</p>

<p>Is this starting to make more sense?  I can't hear you from here, so
I'll just have to hope that it is.  Let's have an example where we make
a socket connection to "www.example.com", port 3490:</p>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect!

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<p>Again, old-school programs filled out their own <nobr><tt class="type">struct
sockaddr_in</tt></nobr>s to pass to <b><tt class="func">connect()</tt></b>.  You can do that
if you want to.  See the similar note in the <a href="#bind"><b><tt class="func">bind()</tt></b> section</a>, above.</p>

<p>Be sure to check the return value from
<b><tt class="func">connect()</tt></b>‚Äîit'll return <tt class="const">-1</tt> on error
and set the variable <i><tt class="var">errno</tt></i>.</p>

<p><a name="indexId434909-107"></a>Also, notice that we didn't call
<b><tt class="func">bind()</tt></b>.  Basically, we don't care about our local port
number; we only care where we're going (the remote port).  The kernel
will choose a local port for us, and the site we connect to will
automatically get this information from us.  No worries.</p>








<h3 class="sect2title">5.5. <a name="listen"><b><tt class="titlefunc">listen()</tt></b>‚ÄîWill somebody please call
me?</a></h3>


<p><a name="indexId434909-108"></a>Ok, time for a change of pace.  What if you don't
want to connect to a remote host.  Say, just for kicks, that you want to
wait for incoming connections and handle them in some way.  The process
is two step: first you <b><tt class="func">listen()</tt></b>, then you
<a name="indexId434909-109"></a><b><tt class="func">accept()</tt></b> (see below.)</p>

<p>The listen call is fairly simple, but requires a bit of
explanation:</p>

<pre class="code">int listen(int sockfd, int backlog); 
</pre>


<p><i><tt class="var">sockfd</tt></i> is the usual socket file descriptor
from the <b><tt class="func">socket()</tt></b> system call.
<a name="indexId434909-110"></a><i><tt class="var">backlog</tt></i> is the number of
connections allowed on the incoming queue.  What does that mean?  Well,
incoming connections are going to wait in this queue until you
<b><tt class="func">accept()</tt></b> them (see below) and this is the limit on how many
can queue up.  Most systems silently limit this number to about 20; you
can probably get away with setting it to <tt class="const">5</tt> or
<tt class="const">10</tt>.</p>

<p>Again, as per usual, <b><tt class="func">listen()</tt></b> returns
<tt class="const">-1</tt> and sets <i><tt class="var">errno</tt></i> on
error.</p>

<p>Well, as you can probably imagine, we need to call
<b><tt class="func">bind()</tt></b> before we call <b><tt class="func">listen()</tt></b> so that the
server is running on a specific port.  (You have to be able to tell your
buddies which port to connect to!)  So if you're going to be listening
for incoming connections, the sequence of system calls you'll make
is:</p>

<pre class="code">getaddrinfo();
socket();
bind();
listen();
/* accept() goes here */ 
</pre>


<p>I'll just leave that in the place of sample code, since it's
fairly self-explanatory.  (The code in the <b><tt class="func">accept()</tt></b>
section, below, is more complete.)  The really tricky part of this whole
sha-bang is the call to <b><tt class="func">accept()</tt></b>.</p>








<h3 class="sect2title">5.6. <a name="accept"><b><tt class="titlefunc">accept()</tt></b>‚Äî"Thank you for calling port
3490."</a></h3>


<p><a name="indexId434909-111"></a>Get ready‚Äîthe <b><tt class="func">accept()</tt></b> call
is kinda weird!  What's going to happen is this: someone far far away
will try to <b><tt class="func">connect()</tt></b> to your machine on a port that you
are <b><tt class="func">listen()</tt></b>ing on.  Their connection will be queued up
waiting to be <b><tt class="func">accept()</tt></b>ed.  You call <b><tt class="func">accept()</tt></b>
and you tell it to get the pending connection.  It'll return to you a
<i>brand new socket file descriptor</i> to use for this single
connection!  That's right, suddenly you have <i>two socket file
descriptors</i> for the price of one!  The original one is still
listening for more new connections, and the newly created one is finally
ready to <b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b>.  We're there! </p>

<p>The call is as follows:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 
</pre>


<p><i><tt class="var">sockfd</tt></i> is the
<b><tt class="func">listen()</tt></b>ing socket descriptor.  Easy enough.
<i><tt class="var">addr</tt></i> will usually be a pointer to a local
<nobr><tt class="type">struct sockaddr_storage</tt></nobr>.  This is where the information
about the incoming connection will go (and with it you can determine
which host is calling you from which port).  <i><tt class="var">addrlen</tt></i> is a
local integer variable that should be set to <tt class="tt">sizeof(struct
sockaddr_storage)</tt> before its address is passed to
<b><tt class="func">accept()</tt></b>.  <b><tt class="func">accept()</tt></b> will not put more than
that many bytes into <i><tt class="var">addr</tt></i>.  If it puts fewer in, it'll
change the value of <i><tt class="var">addrlen</tt></i> to reflect that.</p>

<p>Guess what?  <b><tt class="func">accept()</tt></b> returns <tt class="const">-1</tt> and sets
<i><tt class="var">errno</tt></i> if an error occurs.  Betcha didn't figure that.</p>

<p>Like before, this is a bunch to absorb in one chunk, so here's a
sample code fragment for your perusal:</p>

<pre class="code">#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MYPORT "3490"  // the port users will be connecting to
#define BACKLOG 10     // how many pending connections queue will hold

int main(void)
{
    struct sockaddr_storage their_addr;
    socklen_t addr_size;
    struct addrinfo hints, *res;
    int sockfd, new_fd;

    // !! don't forget your error checking for these calls !!

    // first, load up address structs with getaddrinfo():

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

    getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

    // make a socket, bind it, and listen on it:

    sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
    bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
    listen(sockfd, BACKLOG);

    // now accept an incoming connection:

    addr_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

    // ready to communicate on socket descriptor new_fd!
    .
    .
    .</pre>


<p>Again, note that we will use the socket descriptor
<i><tt class="var">new_fd</tt></i> for all <b><tt class="func">send()</tt></b> and
<b><tt class="func">recv()</tt></b> calls.  If you're only getting one single connection
ever, you can <b><tt class="func">close()</tt></b> the listening <i><tt class="var">sockfd</tt></i>
in order to prevent more incoming connections on the same port, if you
so desire.</p>








<h3 class="sect2title">5.7. <a name="sendrecv"><b><tt class="titlefunc">send()</tt></b> and <b><tt class="titlefunc">recv()</tt></b>‚ÄîTalk to me,
baby!</a></h3>


<p>These two functions are for communicating over stream sockets or
connected datagram sockets.  If you want to use regular unconnected
datagram sockets, you'll need to see the section on <a href="#sendtorecv"><b><tt class="func">sendto()</tt></b> and
<b><tt class="func">recvfrom()</tt></b></a>, below.</p>

<p><a name="indexId434909-112"></a>The <b><tt class="func">send()</tt></b> call:</p>

<pre class="code">int send(int sockfd, const void *msg, int len, int flags); 
</pre>


<p><i><tt class="var">sockfd</tt></i> is the socket descriptor you want to
send data to (whether it's the one returned by
<b><tt class="func">socket()</tt></b> or the one you got with
<b><tt class="func">accept()</tt></b>.) <i><tt class="var">msg</tt></i> is a pointer
to the data you want to send, and <i><tt class="var">len</tt></i> is the
length of that data in bytes.  Just set <i><tt class="var">flags</tt></i> to
<tt class="const">0</tt>.  (See the <b><tt class="func">send()</tt></b> man page
for more information concerning flags.)</p>

<p>Some sample code might be:</p>

<pre class="code">char *msg = "Beej was here!";
int len, bytes_sent;
.
.
.
len = strlen(msg);
bytes_sent = send(sockfd, msg, len, 0);
.
.
. 
</pre>


<p><b><tt class="func">send()</tt></b> returns the number of bytes actually
sent out‚Äî<i>this might be less than the number you told it to
send!</i>  See, sometimes you tell it to send a whole gob of data and
it just can't handle it.  It'll fire off as much of the data as it can,
and trust you to send the rest later.  Remember, if the value returned
by <b><tt class="func">send()</tt></b> doesn't match the value in <i><tt class="var">len</tt></i>,
it's up to you to send the rest of the string.  The good news is this:
if the packet is small (less than 1K or so) it will <i>probably</i>
manage to send the whole thing all in one go.  Again, <tt class="const">-1</tt>
is returned on error, and <i><tt class="var">errno</tt></i> is set to the error
number.</p>

<p><a name="indexId434909-113"></a>The <b><tt class="func">recv()</tt></b> call is similar in many
respects:</p>

<pre class="code">int recv(int sockfd, void *buf, int len, int flags);</pre>


<p><i><tt class="var">sockfd</tt></i> is the socket descriptor to read
from, <i><tt class="var">buf</tt></i> is the buffer to read the information
into, <i><tt class="var">len</tt></i> is the maximum length of the buffer,
and <i><tt class="var">flags</tt></i> can again be set to
<tt class="const">0</tt>.  (See the <b><tt class="func">recv()</tt></b> man page
for flag information.)</p>

<p><b><tt class="func">recv()</tt></b> returns the number of bytes actually
read into the buffer, or <tt class="const">-1</tt> on error (with
<i><tt class="var">errno</tt></i> set, accordingly.)</p>

<p>Wait!  <b><tt class="func">recv()</tt></b> can return
<tt class="const">0</tt>.  This can mean only one thing: the remote side
has closed the connection on you!  A return value of
<tt class="const">0</tt> is <b><tt class="func">recv()</tt></b>'s way of letting
you know this has occurred.</p>

<p>There, that was easy, wasn't it?  You can now pass data back and
forth on stream sockets!  Whee!  You're a Unix Network
Programmer!</p>








<h3 class="sect2title">5.8. <a name="sendtorecv"><b><tt class="titlefunc">sendto()</tt></b> and
<b><tt class="titlefunc">recvfrom()</tt></b>‚ÄîTalk to me, DGRAM-style</a></h3>


<p><a name="indexId434909-114"></a>"This is all fine and dandy," I hear you
saying, "but where does this leave me with unconnected datagram
sockets?"  No problemo, amigo.  We have just the thing.</p>

<p>Since datagram sockets aren't connected to a remote host, guess which
piece of information we need to give before we send a packet?  That's
right!  The destination address!  Here's the scoop:</p>

<pre class="code">int sendto(int sockfd, const void *msg, int len, unsigned int flags,
           const struct sockaddr *to, socklen_t tolen); </pre>


<p>As you can see, this call is basically the same as the call to
<b><tt class="func">send()</tt></b> with the addition of two other pieces of
information.  <i><tt class="var">to</tt></i> is a pointer to a <nobr><tt class="type">struct
sockaddr</tt></nobr> (which will probably be another <nobr><tt class="type">struct
sockaddr_in</tt></nobr> or <nobr><tt class="type">struct sockaddr_in6</tt></nobr> or <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> that you cast at the last minute) which contains
the destination <a name="indexId434909-115"></a>IP address and <a name="indexId434909-116"></a>port.
<i><tt class="var">tolen</tt></i>, an <nobr><tt class="type">int</tt></nobr> deep-down, can simply be set
to <tt class="tt">sizeof *to</tt> or <tt class="tt">sizeof(struct sockaddr_storage)</tt>.</p>

<p>To get your hands on the destination address structure, you'll
probably either get it from <b><tt class="func">getaddrinfo()</tt></b>, or from
<b><tt class="func">recvfrom()</tt></b>, below, or you'll fill it out by hand.</p>

<p>Just like with <b><tt class="func">send()</tt></b>,
<b><tt class="func">sendto()</tt></b> returns the number of bytes actually sent
(which, again, might be less than the number of bytes you told it to
send!), or <tt class="const">-1</tt> on error.</p>

<p>Equally similar are <b><tt class="func">recv()</tt></b> and
<a name="indexId434909-117"></a><b><tt class="func">recvfrom()</tt></b>.  The synopsis of
<b><tt class="func">recvfrom()</tt></b> is:</p>

<pre class="code">int recvfrom(int sockfd, void *buf, int len, unsigned int flags,
             struct sockaddr *from, int *fromlen); </pre>


<p>Again, this is just like <b><tt class="func">recv()</tt></b> with the
addition of a couple fields.  <i><tt class="var">from</tt></i> is a pointer to a
local <a name="indexId434909-118"></a><nobr><tt class="type">struct sockaddr_storage</tt></nobr>
that will be filled with the IP address and port of the originating
machine.  <i><tt class="var">fromlen</tt></i> is a pointer to a local
<nobr><tt class="type">int</tt></nobr> that should be initialized to <tt class="tt">sizeof *from</tt> or
<tt class="tt">sizeof(struct sockaddr_storage)</tt>.  When the function returns,
<i><tt class="var">fromlen</tt></i> will contain the length of the address actually
stored in <i><tt class="var">from</tt></i>.</p>

<p><b><tt class="func">recvfrom()</tt></b> returns the number of bytes
received, or <tt class="const">-1</tt> on error (with
<i><tt class="var">errno</tt></i> set accordingly.)</p>

<p>So, here's a question: why do we use <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> as the socket type?  Why not <nobr><tt class="type">struct
sockaddr_in</tt></nobr>?  Because, you see, we want to not tie ourselves down
to IPv4 or IPv6.  So we use the generic <nobr><tt class="type">struct
sockaddr_storage</tt></nobr> which we know will be big enough for either.</p>

<p>(So... here's another question: why isn't <nobr><tt class="type">struct
sockaddr</tt></nobr> itself big enough for any address?  We even cast the
general-purpose <nobr><tt class="type">struct sockaddr_storage</tt></nobr> to the
general-purpose <nobr><tt class="type">struct sockaddr</tt></nobr>!  Seems extraneous and
redundant, huh.  The answer is, it just isn't big enough, and I'd guess
that changing it at this point would be Problematic.  So they made a new
one.)</p>

<p>Remember, if you <a name="indexId434909-119"></a><b><tt class="func">connect()</tt></b> a datagram
socket, you can then simply use <b><tt class="func">send()</tt></b> and
<b><tt class="func">recv()</tt></b> for all your transactions.  The socket itself is
still a datagram socket and the packets still use UDP, but the socket
interface will automatically add the destination and source information
for you.</p>










<h3 class="sect2title">5.9. <a name="closedown"><b><tt class="titlefunc">close()</tt></b> and
<b><tt class="titlefunc">shutdown()</tt></b>‚ÄîGet outta my face!</a></h3>


<p>Whew!  You've been <b><tt class="func">send()</tt></b>ing and
<b><tt class="func">recv()</tt></b>ing data all day long, and you've had it.
You're ready to close the connection on your socket descriptor.  This is
easy.  You can just use the regular Unix file descriptor
<a name="indexId434909-120"></a><b><tt class="func">close()</tt></b> function:</p>

<pre class="code">close(sockfd); 
</pre>


<p>This will prevent any more reads and writes to the socket.  Anyone
attempting to read or write the socket on the remote end will receive an
error.</p>

<p>Just in case you want a little more control over how the socket
closes, you can use the <a name="indexId434909-121"></a><b><tt class="func">shutdown()</tt></b>
function.  It allows you to cut off communication in a certain
direction, or both ways (just like <b><tt class="func">close()</tt></b> does.)
Synopsis:</p>

<pre class="code">int shutdown(int sockfd, int how); 
</pre>


<p><i><tt class="var">sockfd</tt></i> is the socket file descriptor you
want to shutdown, and <i><tt class="var">how</tt></i> is one of the
following:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="10%%"><p><tt class="const">0</tt></p></td>
<td valign="top" align="left" width="88%%"><p>Further receives are disallowed</p></td>
</tr>

<tr><td valign="top" align="left"><p><tt class="const">1</tt></p></td>
<td valign="top" align="left"><p>Further sends are disallowed</p></td>
</tr>

<tr><td valign="top" align="left"><p><tt class="const">2</tt></p></td>
<td valign="top" align="left"><p>Further sends and receives are disallowed (like <b><tt class="func">close()</tt></b>)</p></td>
</tr>

</tbody></table></center>
<p></p>

<p><b><tt class="func">shutdown()</tt></b> returns <tt class="const">0</tt> on
success, and <tt class="const">-1</tt> on error (with
<i><tt class="var">errno</tt></i> set accordingly.)</p>

<p>If you deign to use <b><tt class="func">shutdown()</tt></b> on unconnected
datagram sockets, it will simply make the socket unavailable for further
<b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b> calls
(remember that you can use these if you <b><tt class="func">connect()</tt></b>
your datagram socket.)</p>

<p>It's important to note that <b><tt class="func">shutdown()</tt></b>
doesn't actually close the file descriptor‚Äîit just changes its
usability.  To free a socket descriptor, you need to use
<b><tt class="func">close()</tt></b>.</p>

<p>Nothing to it.</p>

<p>(Except to remember that if you're using <a name="indexId434909-122"></a>Windows
and <a name="indexId434909-123"></a>Winsock that you should call <a name="indexId434909-124"></a><b><tt class="func">closesocket()</tt></b> instead of
<b><tt class="func">close()</tt></b>.)</p>









<h3 class="sect2title">5.10. <a name="getpeername"><b><tt class="titlefunc">getpeername()</tt></b>‚ÄîWho are you?</a></h3>


<p><a name="indexId434909-125"></a>This function is so easy.</p>

<p>It's so easy, I almost didn't give it its own section.  But here
it is anyway.</p>

<p>The function <b><tt class="func">getpeername()</tt></b> will tell you who is at the other end
of a connected stream socket.  The synopsis:</p>

<pre class="code">#include &lt;sys/socket.h&gt;

int getpeername(int sockfd, struct sockaddr *addr, int *addrlen); 
</pre>


<p><i><tt class="var">sockfd</tt></i> is the descriptor of the connected
stream socket, <i><tt class="var">addr</tt></i> is a pointer to a
<nobr><tt class="type">struct sockaddr</tt></nobr> (or a <nobr><tt class="type">struct sockaddr_in</tt></nobr>) that
will hold the information about the other side of the connection, and
<i><tt class="var">addrlen</tt></i> is a pointer to an <nobr><tt class="type">int</tt></nobr>, that
should be initialized to <tt class="tt">sizeof *addr</tt> or <tt class="tt">sizeof(struct
sockaddr)</tt>.</p>

<p>The function returns <tt class="const">-1</tt> on error and sets
<i><tt class="var">errno</tt></i> accordingly.</p>

<p>Once you have their address, you can use <a name="indexId434909-126"></a><b><tt class="func">inet_ntop()</tt></b>, <a name="indexId434909-127"></a><b><tt class="func">getnameinfo()</tt></b>, or <a name="indexId434909-128"></a><b><tt class="func">gethostbyaddr()</tt></b> to print or get more
information.  No, you can't get their login name.  (Ok, ok.  If the
other computer is running an ident daemon, this is possible.  This,
however, is beyond the scope of this document.  Check out <a href="http://tools.ietf.org/html/rfc1413" target="_blank">RFC 1413</a> for more info.)</p>









<h3 class="sect2title">5.11. <a name="gethostname"><b><tt class="titlefunc">gethostname()</tt></b>‚ÄîWho am I?</a></h3>


<p><a name="indexId434909-129"></a>Even easier than <b><tt class="func">getpeername()</tt></b>
is the function <b><tt class="func">gethostname()</tt></b>.  It returns the name of the
computer that your program is running on.  The name can then be used by
<a name="indexId434909-130"></a><b><tt class="func">gethostbyname()</tt></b>, below, to
determine the <a name="indexId434909-131"></a>IP address of your local machine.</p>

<p>What could be more fun?  I could think of a few things, but they
don't pertain to socket programming.  Anyway, here's the
breakdown:</p>

<pre class="code">#include &lt;unistd.h&gt;

int gethostname(char *hostname, size_t size); 
</pre>


<p>The arguments are simple: <i><tt class="var">hostname</tt></i> is a
pointer to an array of chars that will contain the hostname upon the
function's return, and <i><tt class="var">size</tt></i> is the length in
bytes of the <i><tt class="var">hostname</tt></i> array.</p>

<p>The function returns <tt class="const">0</tt> on successful
completion, and <tt class="const">-1</tt> on error, setting
<i><tt class="var">errno</tt></i> as usual.</p>



  







<hr class="mainsectbreak"><h2 class="sect1title">6. <a name="clientserver">Client-Server Background</a></h2><hr class="mainsecthr">


<p><a name="indexId434909-132"></a>It's a client-server world, baby.  Just
about everything on the network deals with client processes talking to
server processes and vice-versa.  Take <b class="com">telnet</b>, for instance.
When you connect to a remote host on port 23 with telnet (the client), a
program on that host (called <b class="com">telnetd</b>, the server) springs to
life.  It handles the incoming telnet connection, sets you up with a
login prompt, etc.</p>

<a name="figure2"><center>
    <div><img src="cs-120-3.334.png" alt="[Client-Server Interaction Diagram]"></div>

    <p><b>Client-Server Interaction.</b></p>
</center>


</a><p><a name="figure2">The exchange of information between client and server is
summarized in </a><a href="#figure2">the above diagram</a>.</p>

<p>Note that the client-server pair can speak
<tt class="const">SOCK_STREAM</tt>, <tt class="const">SOCK_DGRAM</tt>, or
anything else (as long as they're speaking the same thing.)  Some good
examples of client-server pairs are
<b class="com">telnet</b>/<b class="com">telnetd</b>,
<b class="com">ftp</b>/<b class="com">ftpd</b>, or
<b class="com">Firefox</b>/<b class="com">Apache</b>.  Every time you use
<b class="com">ftp</b>, there's a remote program,
<b class="com">ftpd</b>, that serves you.</p>

<p>Often, there will only be one server on a machine, and that server
will handle multiple clients using <a name="indexId434909-133"></a><b><tt class="func">fork()</tt></b>.  The basic routine is: server will
wait for a connection, <b><tt class="func">accept()</tt></b> it, and <b><tt class="func">fork()</tt></b>
a child process to handle it.  This is what our sample server does in
the next section.</p>







<h3 class="sect2title">6.1. <a name="simpleserver">A Simple Stream Server</a></h3>


<p><a name="indexId434909-134"></a>All this server does is send the string
"<tt class="tt">Hello, world!</tt>" out over a stream connection.  All you need
to do to test this server is run it in one window, and telnet to it from
another with:</p>

<pre class="screen">$ telnet remotehostname 3490</pre>


<p>where <tt class="tt">remotehostname</tt> is the name of the machine you're
running it on.</p>

<p><a href="http://beej.us/guide/bgnet/examples/server.c" target="_blank">The server code</a>:</p>

<pre class="code">/*
** server.c -- a stream socket server demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;

#define PORT "3490"  // the port users will be connecting to

#define BACKLOG 10     // how many pending connections queue will hold

void sigchld_handler(int s)
{
    // waitpid() might overwrite errno, so we save and restore it:
    int saved_errno = errno;

    while(waitpid(-1, NULL, WNOHANG) &gt; 0);

    errno = saved_errno;
}


// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd, new_fd;  // listen on sock_fd, new connection on new_fd
    struct addrinfo hints, *servinfo, *p;
    struct sockaddr_storage their_addr; // connector's address information
    socklen_t sin_size;
    struct sigaction sa;
    int yes=1;
    char s[INET6_ADDRSTRLEN];
    int rv;

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("server: socket");
            continue;
        }

        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes,
                sizeof(int)) == -1) {
            perror("setsockopt");
            exit(1);
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("server: bind");
            continue;
        }

        break;
    }

    freeaddrinfo(servinfo); // all done with this structure

    if (p == NULL)  {
        fprintf(stderr, "server: failed to bind\n");
        exit(1);
    }

    if (listen(sockfd, BACKLOG) == -1) {
        perror("listen");
        exit(1);
    }

    sa.sa_handler = sigchld_handler; // reap all dead processes
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    if (sigaction(SIGCHLD, &amp;sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    printf("server: waiting for connections...\n");

    while(1) {  // main accept() loop
        sin_size = sizeof their_addr;
        new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;sin_size);
        if (new_fd == -1) {
            perror("accept");
            continue;
        }

        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s);
        printf("server: got connection from %s\n", s);

        if (!fork()) { // this is the child process
            close(sockfd); // child doesn't need the listener
            if (send(new_fd, "Hello, world!", 13, 0) == -1)
                perror("send");
            close(new_fd);
            exit(0);
        }
        close(new_fd);  // parent doesn't need this
    }

    return 0;
}</pre>


<p>In case you're curious, I have the code in one big
<b><tt class="func">main()</tt></b> function for (I feel) syntactic clarity.
Feel free to split it into smaller functions if it makes you feel
better.</p>

<p>(Also, this whole <a name="indexId434909-135"></a><b><tt class="func">sigaction()</tt></b>
thing might be new to you‚Äîthat's ok.  The code that's there is
responsible for reaping <a name="indexId434909-136"></a>zombie processes that
appear as the <b><tt class="func">fork()</tt></b>ed child processes exit.  If you make
lots of zombies and don't reap them, your system administrator will
become agitated.)</p>

<p>You can get the data from this server by using the client
listed in the next section.</p>









<h3 class="sect2title">6.2. <a name="simpleclient">A Simple Stream Client</a></h3>


<p><a name="indexId434909-137"></a>This guy's even easier than the server.  All
this client does is connect to the host you specify on the command line,
port 3490.  It gets the string that the server sends.</p>

<p><a href="http://beej.us/guide/bgnet/examples/client.c" target="_blank">The client
source</a>:</p>

<pre class="code">/*
** client.c -- a stream socket client demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;

#include &lt;arpa/inet.h&gt;

#define PORT "3490" // the port client will be connecting to 

#define MAXDATASIZE 100 // max number of bytes we can get at once 

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(int argc, char *argv[])
{
    int sockfd, numbytes;  
    char buf[MAXDATASIZE];
    struct addrinfo hints, *servinfo, *p;
    int rv;
    char s[INET6_ADDRSTRLEN];

    if (argc != 2) {
        fprintf(stderr,"usage: client hostname\n");
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(argv[1], PORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and connect to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("client: socket");
            continue;
        }

        if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("client: connect");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "client: failed to connect\n");
        return 2;
    }

    inet_ntop(p-&gt;ai_family, get_in_addr((struct sockaddr *)p-&gt;ai_addr),
            s, sizeof s);
    printf("client: connecting to %s\n", s);

    freeaddrinfo(servinfo); // all done with this structure

    if ((numbytes = recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) {
        perror("recv");
        exit(1);
    }

    buf[numbytes] = '\0';

    printf("client: received '%s'\n",buf);

    close(sockfd);

    return 0;
}</pre>


<p>Notice that if you don't run the server before you run the client,
<b><tt class="func">connect()</tt></b> returns
<a name="indexId434909-138"></a>"Connection refused".  Very
useful.</p>









<h3 class="sect2title">6.3. <a name="datagram">Datagram Sockets</a></h3>


<p>We've already covered the basics of UDP datagram sockets with our
discussion of <b><tt class="func">sendto()</tt></b> and <b><tt class="func">recvfrom()</tt></b>, above,
so I'll just present a couple of sample programs: <i><tt class="var">talker.c</tt></i>
and <i><tt class="var">listener.c</tt></i>.</p>

<p><a name="indexId434909-139"></a><b class="com">listener</b> sits on a machine
waiting for an incoming packet on port 4950.  <b class="com">talker</b> sends a
packet to that port, on the specified machine, that contains whatever
the user enters on the command line.</p>

<p>Here is the <a href="http://beej.us/guide/bgnet/examples/listener.c" target="_blank">source for
<i><tt class="var">listener.c</tt></i></a>:</p>

<pre class="code">/*
** listener.c -- a datagram sockets "server" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define MYPORT "4950"    // the port users will be connecting to

#define MAXBUFLEN 100

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    int sockfd;
    struct addrinfo hints, *servinfo, *p;
    int rv;
    int numbytes;
    struct sockaddr_storage their_addr;
    char buf[MAXBUFLEN];
    socklen_t addr_len;
    char s[INET6_ADDRSTRLEN];

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC; // set to AF_INET to force IPv4
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE; // use my IP

    if ((rv = getaddrinfo(NULL, MYPORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and bind to the first we can
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("listener: socket");
            continue;
        }

        if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
            close(sockfd);
            perror("listener: bind");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "listener: failed to bind socket\n");
        return 2;
    }

    freeaddrinfo(servinfo);

    printf("listener: waiting to recvfrom...\n");

    addr_len = sizeof their_addr;
    if ((numbytes = recvfrom(sockfd, buf, MAXBUFLEN-1 , 0,
        (struct sockaddr *)&amp;their_addr, &amp;addr_len)) == -1) {
        perror("recvfrom");
        exit(1);
    }

    printf("listener: got packet from %s\n",
        inet_ntop(their_addr.ss_family,
            get_in_addr((struct sockaddr *)&amp;their_addr),
            s, sizeof s));
    printf("listener: packet is %d bytes long\n", numbytes);
    buf[numbytes] = '\0';
    printf("listener: packet contains \"%s\"\n", buf);

    close(sockfd);

    return 0;
}</pre>


<p>Notice that in our call to <b><tt class="func">getaddrinfo()</tt></b> we're finally
using <tt class="const">SOCK_DGRAM</tt>.  Also, note that there's no need to
<b><tt class="func">listen()</tt></b> or <b><tt class="func">accept()</tt></b>.  This is one of the
perks of using unconnected datagram sockets!</p>

<p><a name="indexId434909-140"></a>Next comes the <a href="http://beej.us/guide/bgnet/examples/talker.c" target="_blank">source for <i><tt class="var">talker.c</tt></i></a>:</p>


<pre class="code">/*
** talker.c -- a datagram "client" demo
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT "4950"    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct addrinfo hints, *servinfo, *p;
    int rv;
    int numbytes;

    if (argc != 3) {
        fprintf(stderr,"usage: talker hostname message\n");
        exit(1);
    }

    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_DGRAM;

    if ((rv = getaddrinfo(argv[1], SERVERPORT, &amp;hints, &amp;servinfo)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
        return 1;
    }

    // loop through all the results and make a socket
    for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
        if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
                p-&gt;ai_protocol)) == -1) {
            perror("talker: socket");
            continue;
        }

        break;
    }

    if (p == NULL) {
        fprintf(stderr, "talker: failed to create socket\n");
        return 2;
    }

    if ((numbytes = sendto(sockfd, argv[2], strlen(argv[2]), 0,
             p-&gt;ai_addr, p-&gt;ai_addrlen)) == -1) {
        perror("talker: sendto");
        exit(1);
    }

    freeaddrinfo(servinfo);

    printf("talker: sent %d bytes to %s\n", numbytes, argv[1]);
    close(sockfd);

    return 0;
}</pre>



<p>And that's all there is to it!  Run <b class="com">listener</b> on some
machine, then run <b class="com">talker</b> on another.  Watch them communicate!
Fun G-rated excitement for the entire nuclear family!</p>

<p>You don't even have to run the server this time!  You can run
<b class="com">talker</b> by itself, and it just happily fires packets off into
the ether where they disappear if no one is ready with a
<b><tt class="func">recvfrom()</tt></b> on the other side.  Remember: data sent using
UDP datagram sockets isn't guaranteed to arrive!</p>

<p>Except for one more tiny detail that I've mentioned many times in the
past: <a name="indexId434909-141"></a>connected datagram
sockets.  I need to talk about this here, since we're in the datagram
section of the document.  Let's say that <b class="com">talker</b> calls
<b><tt class="func">connect()</tt></b> and specifies the <b class="com">listener</b>'s address.
From that point on, <b class="com">talker</b> may only sent to and receive from
the address specified by <b><tt class="func">connect()</tt></b>.  For this reason, you
don't have to use <b><tt class="func">sendto()</tt></b> and <b><tt class="func">recvfrom()</tt></b>; you
can simply use <b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b>.</p>



 







<hr class="mainsectbreak"><h2 class="sect1title">7. <a name="advanced">Slightly Advanced Techniques</a></h2><hr class="mainsecthr">


<p>These aren't <i>really</i> advanced, but they're
getting out of the more basic levels we've already covered.  In fact, if
you've gotten this far, you should consider yourself fairly accomplished
in the basics of Unix network programming!  Congratulations!</p>

<p>So here we go into the brave new world of some of the more
esoteric things you might want to learn about sockets.  Have at
it!</p>







<h3 class="sect2title">7.1. <a name="blocking">Blocking</a></h3>


<p><a name="indexId434909-142"></a>Blocking.  You've heard about it‚Äînow what
the heck is it?  In a nutshell, "block" is techie jargon for "sleep".
You probably noticed that when you run <b class="com">listener</b>, above, it
just sits there until a packet arrives.  What happened is that it called
<b><tt class="func">recvfrom()</tt></b>, there was no data, and so
<b><tt class="func">recvfrom()</tt></b> is said to "block" (that is, sleep there) until
some data arrives.</p>

<p>Lots of functions block.  <b><tt class="func">accept()</tt></b> blocks.
All the <b><tt class="func">recv()</tt></b> functions block.  The reason they
can do this is because they're allowed to.  When you first create the
socket descriptor with <b><tt class="func">socket()</tt></b>, the kernel sets it
to blocking.  <a name="indexId434909-143"></a>If you don't want a socket to be blocking, you have to
make a call to <a name="indexId434909-144"></a><b><tt class="func">fcntl()</tt></b>:</p>

<pre class="code">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
.
.
.
sockfd = socket(PF_INET, SOCK_STREAM, 0);
fcntl(sockfd, F_SETFL, O_NONBLOCK);
.
.
. 
</pre>


<p>By setting a socket to non-blocking, you can effectively "poll"
the socket for information.  If you try to read from a non-blocking
socket and there's no data there, it's not allowed to block‚Äîit
will return <tt class="const">-1</tt> and <i><tt class="var">errno</tt></i> will be set to
<a name="indexId434909-145"></a><tt class="const">EAGAIN</tt> or
<a name="indexId434909-146"></a><tt class="const">EWOULDBLOCK</tt>.</p>

<p>(Wait‚Äîit can return <a name="indexId434909-147"></a><tt class="const">EAGAIN</tt>
<i>or</i> <a name="indexId434909-148"></a><tt class="const">EWOULDBLOCK</tt>? Which
do you check for? The specification doesn't actually specify which your
system will return, so for portability, check them both.)</p>

<p>Generally speaking, however, this type of polling is a bad idea.
If you put your program in a busy-wait looking for data on the socket,
you'll suck up CPU time like it was going out of style.  A more elegant
solution for checking to see if there's data waiting to be read comes in
the following section on <a name="indexId434909-149"></a><b><tt class="func">select()</tt></b>.</p>









<h3 class="sect2title">7.2. <a name="select"><b><tt class="titlefunc">select()</tt></b>‚ÄîSynchronous I/O Multiplexing</a></h3>


<p><a name="indexId434909-150"></a>This function is somewhat strange, but it's very
useful.  Take the following situation: you are a server and you want to
listen for incoming connections as well as keep reading from the
connections you already have.</p>

<p>No problem, you say, just an <b><tt class="func">accept()</tt></b> and a
couple of <b><tt class="func">recv()</tt></b>s.  Not so fast, buster!  What if
you're blocking on an <b><tt class="func">accept()</tt></b> call?  How are you
going to <b><tt class="func">recv()</tt></b> data at the same time?  "Use
non-blocking sockets!"  No way!  You don't want to be a CPU hog.  What,
then?</p>

<p><b><tt class="func">select()</tt></b> gives you the power to monitor
several sockets at the same time.  It'll tell you which ones are ready
for reading, which are ready for writing, and which sockets have raised
exceptions, if you really want to know that.</p>

<p>This being said, in modern times <b><tt class="func">select()</tt></b>, though very
portable, is one of the slowest methods for monitoring sockets.  One
possible alternative is <a href="http://www.monkey.org/~provos/libevent/" target="_blank">libevent</a>, or
something similar, that encapsulates all the system-dependent stuff
involved with getting socket notifications.</p>

<p>Without any further ado, I'll offer the synopsis of
<b><tt class="func">select()</tt></b>:</p>

<pre class="code">#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int select(int numfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout); 
</pre>


<p>The function monitors "sets" of file descriptors; in particular
<i><tt class="var">readfds</tt></i>, <i><tt class="var">writefds</tt></i>, and
<i><tt class="var">exceptfds</tt></i>.  If you want to see if you can read
from standard input and some socket descriptor,
<i><tt class="var">sockfd</tt></i>, just add the file descriptors
<tt class="const">0</tt> and <i><tt class="var">sockfd</tt></i> to the set
<i><tt class="var">readfds</tt></i>.  The parameter
<i><tt class="var">numfds</tt></i> should be set to the values of the highest
file descriptor plus one.  In this example, it should be set to
<i><tt class="var">sockfd+1</tt></i>, since it is assuredly higher than
standard input (<tt class="const">0</tt>).</p>

<p>When <b><tt class="func">select()</tt></b> returns,
<i><tt class="var">readfds</tt></i> will be modified to reflect which of the
file descriptors you selected which is ready for reading.  You can test
them with the macro <b><tt class="func">FD_ISSET()</tt></b>, below.</p>

<p>Before progressing much further, I'll talk about how to manipulate
these sets.  Each set is of the type <nobr><tt class="type">fd_set</tt></nobr>.  The following
macros operate on this type:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="50%%"><p><a name="indexId434909-151"></a><b><tt class="func">FD_SET(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left" width="48%%"><p>Add <i><tt class="var">fd</tt></i> to the <i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-152"></a><b><tt class="func">FD_CLR(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Remove <i><tt class="var">fd</tt></i> from the <i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-153"></a><b><tt class="func">FD_ISSET(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Return true if <i><tt class="var">fd</tt></i> is in the
<i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-154"></a><b><tt class="func">FD_ZERO(fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Clear all entries from the <i><tt class="var">set</tt></i>.</p></td>
</tr>

</tbody></table></center>
<p></p>

<p>Finally, what is this weirded out <a name="indexId434909-155"></a>
<nobr><tt class="type">struct timeval</tt></nobr>?
Well, sometimes you don't want to wait forever for someone to send you
some data.  Maybe every 96 seconds you want to print "Still Going..." to
the terminal even though nothing has happened.  This time structure
allows you to specify a timeout period.  If the time is exceeded and
<b><tt class="func">select()</tt></b> still hasn't found any ready file
descriptors, it'll return so you can continue processing.</p>

<p>The <nobr><tt class="type">struct timeval</tt></nobr> has the follow fields:</p>

<pre class="code">struct timeval {
    int tv_sec;     // seconds
    int tv_usec;    // microseconds
}; 
</pre>


<p>Just set <i><tt class="var">tv_sec</tt></i> to the number of seconds to
wait, and set <i><tt class="var">tv_usec</tt></i> to the number of
microseconds to wait.  Yes, that's <i>micro</i>seconds,
not milliseconds.  There are 1,000 microseconds in a millisecond, and
1,000 milliseconds in a second.  Thus, there are 1,000,000 microseconds
in a second.  Why is it "usec"?  The "u" is supposed to look like the
Greek letter Œº (Mu) that we use for "micro".  Also, when the function
returns, <i><tt class="var">timeout</tt></i> <i>might</i> be
updated to show the time still remaining.  This depends on what flavor
of Unix you're running.</p>

<p>Yay!  We have a microsecond resolution timer!  Well, don't count on
it.  You'll probably have to wait some part of your standard Unix
timeslice no matter how small you set your <nobr><tt class="type">struct
timeval</tt></nobr>.</p>

<p>Other things of interest:  If you set the fields in your
<nobr><tt class="type">struct timeval</tt></nobr> to <tt class="const">0</tt>,
<b><tt class="func">select()</tt></b> will timeout immediately, effectively
polling all the file descriptors in your sets.  If you set the
parameter <i><tt class="var">timeout</tt></i> to NULL, it will never timeout,
and will wait until the first file descriptor is ready.  Finally, if you
don't care about waiting for a certain set, you can just set it to NULL
in the call to <b><tt class="func">select()</tt></b>.</p>

<p><a href="http://beej.us/guide/bgnet/examples/select.c" target="_blank">The following code snippet</a> waits 2.5 seconds for
something to appear on standard input:</p>

<pre class="code">/*
** select.c -- a select() demo
*/

#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#define STDIN 0  // file descriptor for standard input

int main(void)
{
    struct timeval tv;
    fd_set readfds;

    tv.tv_sec = 2;
    tv.tv_usec = 500000;

    FD_ZERO(&amp;readfds);
    FD_SET(STDIN, &amp;readfds);

    // don't care about writefds and exceptfds:
    select(STDIN+1, &amp;readfds, NULL, NULL, &amp;tv);

    if (FD_ISSET(STDIN, &amp;readfds))
        printf("A key was pressed!\n");
    else
        printf("Timed out.\n");

    return 0;
} 
</pre>


<p>If you're on a line buffered terminal, the key you hit should be
RETURN or it will time out anyway.</p>

<p>Now, some of you might think this is a great way to wait for data
on a datagram socket‚Äîand you are right: it <i>might</i> be.
Some Unices can use select in this manner, and some can't.  You should
see what your local man page says on the matter if you want to attempt
it.</p>

<p>Some Unices update the time in your <nobr><tt class="type">struct timeval</tt></nobr> to
reflect the amount of time still remaining before a timeout.  But others
do not.  Don't rely on that occurring if you want to be portable.  (Use
<a name="indexId434909-156"></a><b><tt class="func">gettimeofday()</tt></b> if you need to
track time elapsed.  It's a bummer, I know, but that's the way it
is.)</p>

<p>What happens if a socket in the read set closes the connection?
Well, in that case, <b><tt class="func">select()</tt></b> returns with that
socket descriptor set as "ready to read".  When you actually do
<b><tt class="func">recv()</tt></b> from it, <b><tt class="func">recv()</tt></b> will
return <tt class="const">0</tt>.  That's how you know the client has
closed the connection.</p>

<p>One more note of interest about <b><tt class="func">select()</tt></b>: if you have a
socket that is <a name="indexId434909-157"></a>
<a name="indexId434909-158"></a> <b><tt class="func">listen()</tt></b>ing, you can
check to see if there is a new connection by putting that socket's file
descriptor in the <i><tt class="var">readfds</tt></i> set.</p>

<p>And that, my friends, is a quick overview of the almighty
<b><tt class="func">select()</tt></b> function.</p>

<p>But, by popular demand, here is an in-depth example.
Unfortunately, the difference between the dirt-simple example, above, and
this one here is significant.  But have a look, then read the
description that follows it.</p>

<p><a href="http://beej.us/guide/bgnet/examples/selectserver.c" target="_blank">This program</a> acts
like a simple multi-user chat server.  Start it running in one window,
then <b class="com">telnet</b> to it ("<b class="com">telnet hostname
9034</b>") from multiple other windows.  When you type something
in one <b class="com">telnet</b> session, it should appear in all the
others.</p>

<pre class="code">/*
** selectserver.c -- a cheezy multiperson chat server
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define PORT "9034"   // port we're listening on

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
    if (sa-&gt;sa_family == AF_INET) {
        return &amp;(((struct sockaddr_in*)sa)-&gt;sin_addr);
    }

    return &amp;(((struct sockaddr_in6*)sa)-&gt;sin6_addr);
}

int main(void)
{
    fd_set master;    // master file descriptor list
    fd_set read_fds;  // temp file descriptor list for select()
    int fdmax;        // maximum file descriptor number

    int listener;     // listening socket descriptor
    int newfd;        // newly accept()ed socket descriptor
    struct sockaddr_storage remoteaddr; // client address
    socklen_t addrlen;

    char buf[256];    // buffer for client data
    int nbytes;

    char remoteIP[INET6_ADDRSTRLEN];

    int yes=1;        // for setsockopt() SO_REUSEADDR, below
    int i, j, rv;

    struct addrinfo hints, *ai, *p;

    FD_ZERO(&amp;master);    // clear the master and temp sets
    FD_ZERO(&amp;read_fds);

    // get us a socket and bind it
    memset(&amp;hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;
    if ((rv = getaddrinfo(NULL, PORT, &amp;hints, &amp;ai)) != 0) {
        fprintf(stderr, "selectserver: %s\n", gai_strerror(rv));
        exit(1);
    }
    
    for(p = ai; p != NULL; p = p-&gt;ai_next) {
        listener = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol);
        if (listener &lt; 0) { 
            continue;
        }
        
        // lose the pesky "address already in use" error message
        setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));

        if (bind(listener, p-&gt;ai_addr, p-&gt;ai_addrlen) &lt; 0) {
            close(listener);
            continue;
        }

        break;
    }

    // if we got here, it means we didn't get bound
    if (p == NULL) {
        fprintf(stderr, "selectserver: failed to bind\n");
        exit(2);
    }

    freeaddrinfo(ai); // all done with this

    // listen
    if (listen(listener, 10) == -1) {
        perror("listen");
        exit(3);
    }

    // add the listener to the master set
    FD_SET(listener, &amp;master);

    // keep track of the biggest file descriptor
    fdmax = listener; // so far, it's this one

    // main loop
    for(;;) {
        read_fds = master; // copy it
        if (select(fdmax+1, &amp;read_fds, NULL, NULL, NULL) == -1) {
            perror("select");
            exit(4);
        }

        // run through the existing connections looking for data to read
        for(i = 0; i &lt;= fdmax; i++) {
            if (FD_ISSET(i, &amp;read_fds)) { // we got one!!
                if (i == listener) {
                    // handle new connections
                    addrlen = sizeof remoteaddr;
                    newfd = accept(listener,
                        (struct sockaddr *)&amp;remoteaddr,
                        &amp;addrlen);

                    if (newfd == -1) {
                        perror("accept");
                    } else {
                        FD_SET(newfd, &amp;master); // add to master set
                        if (newfd &gt; fdmax) {    // keep track of the max
                            fdmax = newfd;
                        }
                        printf("selectserver: new connection from %s on "
                            "socket %d\n",
                            inet_ntop(remoteaddr.ss_family,
                                get_in_addr((struct sockaddr*)&amp;remoteaddr),
                                remoteIP, INET6_ADDRSTRLEN),
                            newfd);
                    }
                } else {
                    // handle data from a client
                    if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {
                        // got error or connection closed by client
                        if (nbytes == 0) {
                            // connection closed
                            printf("selectserver: socket %d hung up\n", i);
                        } else {
                            perror("recv");
                        }
                        close(i); // bye!
                        FD_CLR(i, &amp;master); // remove from master set
                    } else {
                        // we got some data from a client
                        for(j = 0; j &lt;= fdmax; j++) {
                            // send to everyone!
                            if (FD_ISSET(j, &amp;master)) {
                                // except the listener and ourselves
                                if (j != listener &amp;&amp; j != i) {
                                    if (send(j, buf, nbytes, 0) == -1) {
                                        perror("send");
                                    }
                                }
                            }
                        }
                    }
                } // END handle data from client
            } // END got new incoming connection
        } // END looping through file descriptors
    } // END for(;;)--and you thought it would never end!
    
    return 0;
}</pre>


<p>Notice I have two file descriptor sets in the code:
<i><tt class="var">master</tt></i> and <i><tt class="var">read_fds</tt></i>.  The
first, <i><tt class="var">master</tt></i>, holds all the socket descriptors
that are currently connected, as well as the socket descriptor that is
listening for new connections.</p>

<p>The reason I have the <i><tt class="var">master</tt></i> set is that
<b><tt class="func">select()</tt></b> actually <i>changes</i> the
set you pass into it to reflect which sockets are ready to read.  Since
I have to keep track of the connections from one call of
<b><tt class="func">select()</tt></b> to the next, I must store these safely
away somewhere.  At the last minute, I copy the
<i><tt class="var">master</tt></i> into the <i><tt class="var">read_fds</tt></i>,
and then call <b><tt class="func">select()</tt></b>.</p>

<p>But doesn't this mean that every time I get a new connection, I
have to add it to the <i><tt class="var">master</tt></i> set?  Yup!  And
every time a connection closes, I have to remove it from the
<i><tt class="var">master</tt></i> set?  Yes, it does.</p>

<p>Notice I check to see when the <i><tt class="var">listener</tt></i>
socket is ready to read.  When it is, it means I have a new connection
pending, and I <b><tt class="func">accept()</tt></b> it and add it to the
<i><tt class="var">master</tt></i> set.  Similarly, when a client connection
is ready to read, and <b><tt class="func">recv()</tt></b> returns
<tt class="const">0</tt>, I know the client has closed the connection, and
I must remove it from the <i><tt class="var">master</tt></i> set.</p>

<p>If the client <b><tt class="func">recv()</tt></b> returns non-zero,
though, I know some data has been received.  So I get it, and then go
through the <i><tt class="var">master</tt></i> list and send that data to all
the rest of the connected clients.</p>

<p>And that, my friends, is a less-than-simple overview of the
almighty <b><tt class="func">select()</tt></b> function.</p>

<p>In addition, here is a bonus afterthought: there is another function
called <a name="indexId434909-159"></a><b><tt class="func">poll()</tt></b> which behaves much the same way
<b><tt class="func">select()</tt></b> does, but with a different system for managing the
file descriptor sets.  <a href="#pollman">Check it out!</a></p>









<h3 class="sect2title">7.3. <a name="sendall">Handling Partial <b><tt class="titlefunc">send()</tt></b>s</a></h3>


<p>Remember back in the <a href="#sendrecv">section about
<b><tt class="func">send()</tt></b></a>, above, when I said that
<b><tt class="func">send()</tt></b> might not send all the bytes you asked it
to?  That is, you want it to send 512 bytes, but it returns 412.  What
happened to the remaining 100 bytes?</p>

<p>Well, they're still in your little buffer waiting to be sent out.
Due to circumstances beyond your control, the kernel decided not to send
all the data out in one chunk, and now, my friend, it's up to you to get
the data out there.</p>

<p><a name="indexId434909-160"></a>You could write a function like this to do it,
too:</p>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int sendall(int s, char *buf, int *len)
{
    int total = 0;        // how many bytes we've sent
    int bytesleft = *len; // how many we have left to send
    int n;

    while(total &lt; *len) {
        n = send(s, buf+total, bytesleft, 0);
        if (n == -1) { break; }
        total += n;
        bytesleft -= n;
    }

    *len = total; // return number actually sent here

    return n==-1?-1:0; // return -1 on failure, 0 on success
} 
</pre>


<p>In this example, <i><tt class="var">s</tt></i> is the socket you want
to send the data to, <i><tt class="var">buf</tt></i> is the buffer containing
the data, and <i><tt class="var">len</tt></i> is a pointer to an
<nobr><tt class="type">int</tt></nobr> containing the number of bytes in the buffer.</p>

<p>The function returns <tt class="const">-1</tt> on error (and
<i><tt class="var">errno</tt></i> is still set from the call to
<b><tt class="func">send()</tt></b>.)  Also, the number of bytes actually sent
is returned in <i><tt class="var">len</tt></i>.  This will be the same number
of bytes you asked it to send, unless there was an error.
<b><tt class="func">sendall()</tt></b> will do it's best, huffing and puffing,
to send the data out, but if there's an error, it gets back to you right
away.</p>

<p>For completeness, here's a sample call to the function:</p>

<pre class="code">char buf[10] = "Beej!";
int len;

len = strlen(buf);
if (sendall(s, buf, &amp;len) == -1) {
    perror("sendall");
    printf("We only sent %d bytes because of the error!\n", len);
} 
</pre>


<p>What happens on the receiver's end when part of a packet arrives?
If the packets are variable length, how does the receiver know when one
packet ends and another begins?  Yes, real-world scenarios are a royal
pain in the <a name="indexId434909-161"></a>donkeys.  You probably have to <a name="indexId434909-162"></a><i>encapsulate</i> (remember that from the
<a href="#lowlevel">data encapsulation section</a> way back there
at the beginning?)  Read on for details!</p>

<p>Quick note to all you Linux fans out there: sometimes, in rare
circumstances, Linux's <b><tt class="func">select()</tt></b> can return "ready-to-read"
and then not actually be ready to read! This means it will block on the
<b><tt class="func">read()</tt></b> after the <b><tt class="func">select()</tt></b> says it won't! Why
you little‚Äî! Anyway, the workaround solution is to set the <a name="indexId434909-163"></a><tt class="const">O_NONBLOCK</tt> flag on the receiving socket
so it errors with <tt class="const">EWOULDBLOCK</tt> (which you can just safely
ignore if it occurs). See the <a href="#fcntlman"><b><tt class="func">fcntl()</tt></b>
reference page</a> for more info on setting a socket to
non-blocking.</p>









<h3 class="sect2title">7.4. <a name="serialization">Serialization‚ÄîHow to Pack Data</a></h3>


<p><a name="indexId434909-164"></a>It's easy enough to send text data across
the network, you're finding, but what happens if you want to send some
"binary" data like <nobr><tt class="type">int</tt></nobr>s or <nobr><tt class="type">float</tt></nobr>s?  It turns
out you have a few options.</p>

<ol>

<li>Convert the number into text with a function like
<b><tt class="func">sprintf()</tt></b>, then send the text.  The receiver will parse the
text back into a number using a function like
<b><tt class="func">strtol()</tt></b>.</li>


<li>Just send the data raw, passing a pointer to the data to
<b><tt class="func">send()</tt></b>.</li>


<li>Encode the number into a portable binary form.  The receiver will
decode it.</li>

</ol>


<p>Sneak preview!  Tonight only!</p>

<p>[<i>Curtain raises</i>]</p>

<p>Beej says, "I prefer Method Three, above!"</p>

<p>[<i>THE END</i>]</p>

<p>(Before I begin this section in earnest, I should tell you that there
are libraries out there for doing this, and rolling your own and
remaining portable and error-free is quite a challenge.  So hunt around
and do your homework before deciding to implement this stuff yourself.
I include the information here for those curious about how things like
this work.)</p>

<p>Actually all the methods, above, have their drawbacks and advantages,
but, like I said, in general, I prefer the third method.  First, though,
let's talk about some of the drawbacks and advantages to the other two.</p>

<p>The first method, encoding the numbers as text before sending, has
the advantage that you can easily print and read the data that's coming
over the wire.  Sometimes a human-readable protocol is excellent to use
in a non-bandwidth-intensive situation, such as with <a name="indexId434909-165"></a><a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat" target="_blank">Internet Relay Chat (IRC)</a>.
However, it has the disadvantage that it is slow to convert, and the
results almost always take up more space than the original number!</p>

<p>Method two: passing the raw data.  This one is quite easy (but
dangerous!): just take a pointer to the data to send, and call send with
it.</p>

<pre class="code">double d = 3490.15926535;

send(s, &amp;d, sizeof d, 0);  /* DANGER--non-portable! */</pre>


<p>The receiver gets it like this:</p>

<pre class="code">double d;

recv(s, &amp;d, sizeof d, 0);  /* DANGER--non-portable! */</pre>


<p>Fast, simple‚Äîwhat's not to like?  Well, it turns out that not
all architectures represent a <nobr><tt class="type">double</tt></nobr> (or <nobr><tt class="type">int</tt></nobr>
for that matter) with the same bit representation or even the same byte
ordering!  The code is decidedly non-portable.  (Hey‚Äîmaybe you
don't need portability, in which case this is nice and fast.)</p>

<p>When packing integer types, we've already seen how the <a name="indexId434909-166"></a><b><tt class="func">htons()</tt></b>-class of functions can help keep
things portable by transforming the numbers into <a name="indexId434909-167"></a>
Network Byte Order, and how that's the Right Thing to do.
Unfortunately, there are no similar functions for <nobr><tt class="type">float</tt></nobr>
types.  Is all hope lost?</p>

<p>Fear not!  (Were you afraid there for a second?  No?  Not even a
little bit?)  There is something we can do: we can pack (or "marshal",
or "serialize", or one of a thousand million other names) the data into
a known binary format that the receiver can unpack on the remote
side.</p>

<p>What do I mean by "known binary format"?  Well, we've already seen
the <b><tt class="func">htons()</tt></b> example, right?  It changes (or "encodes", if
you want to think of it that way) a number from whatever the host format
is into Network Byte Order.  To reverse (unencode) the number, the
receiver calls <b><tt class="func">ntohs()</tt></b>.</p>

<p>But didn't I just get finished saying there wasn't any such function
for other non-integer types?  Yes.  I did.  And since there's no
standard way in C to do this, it's a bit of a pickle (that a gratuitous
pun there for you Python fans).</p>

<p>The thing to do is to pack the data into a known format and send that
over the wire for decoding.  For example, to pack <nobr><tt class="type">float</tt></nobr>s,
here's <a href="http://beej.us/guide/bgnet/examples/pack.c" target="_blank">something quick and dirty with
plenty of room for improvement:</a></p>

<pre class="code">#include &lt;stdint.h&gt;

uint32_t htonf(float f)
{
    uint32_t p;
    uint32_t sign;

    if (f &lt; 0) { sign = 1; f = -f; }
    else { sign = 0; }
        
    p = ((((uint32_t)f)&amp;0x7fff)&lt;&lt;16) | (sign&lt;&lt;31); // whole part and sign
    p |= (uint32_t)(((f - (int)f) * 65536.0f))&amp;0xffff; // fraction

    return p;
}

float ntohf(uint32_t p)
{
    float f = ((p&gt;&gt;16)&amp;0x7fff); // whole part
    f += (p&amp;0xffff) / 65536.0f; // fraction

    if (((p&gt;&gt;31)&amp;0x1) == 0x1) { f = -f; } // sign bit set

    return f;
}</pre>


<p>The above code is sort of a naive implementation that stores a
<nobr><tt class="type">float</tt></nobr> in a 32-bit number.  The high bit (31) is used to
store the sign of the number ("1" means negative), and the next seven
bits (30-16) are used to store the whole number portion of the
<nobr><tt class="type">float</tt></nobr>.  Finally, the remaining bits (15-0) are used to
store the fractional portion of the number.</p>

<p>Usage is fairly straightforward:</p>

<pre class="code">#include &lt;stdio.h&gt;

int main(void)
{
    float f = 3.1415926, f2;
    uint32_t netf;

    netf = htonf(f);  // convert to "network" form
    f2 = ntohf(netf); // convert back to test

    printf("Original: %f\n", f);        // 3.141593
    printf(" Network: 0x%08X\n", netf); // 0x0003243F
    printf("Unpacked: %f\n", f2);       // 3.141586

    return 0;
}</pre>


<p>On the plus side, it's small, simple, and fast.  On the minus side,
it's not an efficient use of space and the range is severely
restricted‚Äîtry storing a number greater-than 32767 in there and
it won't be very happy!  You can also see in the above example that the
last couple decimal places are not correctly preserved.</p>

<p>What can we do instead?  Well, <i>The</i> Standard for storing
floating point numbers is known as <a name="indexId434909-168"></a><a href="http://en.wikipedia.org/wiki/IEEE_754" target="_blank">IEEE-754</a>.  Most computers use this format
internally for doing floating point math, so in those cases, strictly
speaking, conversion wouldn't need to be done.  But if you want your
source code to be portable, that's an assumption you can't necessarily
make.  (On the other hand, if you want things to be fast, you should
optimize this out on platforms that don't need to do it!  That's what
<b><tt class="func">htons()</tt></b> and its ilk do.)</p>

<p><a href="http://beej.us/guide/bgnet/examples/ieee754.c" target="_blank">Here's some code that encodes
floats and doubles into IEEE-754 format</a>.  (Mostly‚Äîit
doesn't encode NaN or Infinity, but it could be modified to do
that.)</p>

<pre class="code">#define pack754_32(f) (pack754((f), 32, 8))
#define pack754_64(f) (pack754((f), 64, 11))
#define unpack754_32(i) (unpack754((i), 32, 8))
#define unpack754_64(i) (unpack754((i), 64, 11))

uint64_t pack754(long double f, unsigned bits, unsigned expbits)
{
    long double fnorm;
    int shift;
    long long sign, exp, significand;
    unsigned significandbits = bits - expbits - 1; // -1 for sign bit

    if (f == 0.0) return 0; // get this special case out of the way

    // check sign and begin normalization
    if (f &lt; 0) { sign = 1; fnorm = -f; }
    else { sign = 0; fnorm = f; }

    // get the normalized form of f and track the exponent
    shift = 0;
    while(fnorm &gt;= 2.0) { fnorm /= 2.0; shift++; }
    while(fnorm &lt; 1.0) { fnorm *= 2.0; shift--; }
    fnorm = fnorm - 1.0;

    // calculate the binary form (non-float) of the significand data
    significand = fnorm * ((1LL&lt;&lt;significandbits) + 0.5f);

    // get the biased exponent
    exp = shift + ((1&lt;&lt;(expbits-1)) - 1); // shift + bias

    // return the final answer
    return (sign&lt;&lt;(bits-1)) | (exp&lt;&lt;(bits-expbits-1)) | significand;
}

long double unpack754(uint64_t i, unsigned bits, unsigned expbits)
{
    long double result;
    long long shift;
    unsigned bias;
    unsigned significandbits = bits - expbits - 1; // -1 for sign bit

    if (i == 0) return 0.0;

    // pull the significand
    result = (i&amp;((1LL&lt;&lt;significandbits)-1)); // mask
    result /= (1LL&lt;&lt;significandbits); // convert back to float
    result += 1.0f; // add the one back on

    // deal with the exponent
    bias = (1&lt;&lt;(expbits-1)) - 1;
    shift = ((i&gt;&gt;significandbits)&amp;((1LL&lt;&lt;expbits)-1)) - bias;
    while(shift &gt; 0) { result *= 2.0; shift--; }
    while(shift &lt; 0) { result /= 2.0; shift++; }

    // sign it
    result *= (i&gt;&gt;(bits-1))&amp;1? -1.0: 1.0;

    return result;
}</pre>


<p>I put some handy macros up there at the top for packing and unpacking
32-bit (probably a <nobr><tt class="type">float</tt></nobr>) and 64-bit (probably a
<nobr><tt class="type">double</tt></nobr>) numbers, but the <b><tt class="func">pack754()</tt></b> function
could be called directly and told to encode <i><tt class="var">bits</tt></i>-worth of
data (<i><tt class="var">expbits</tt></i> of which are reserved for the normalized
number's exponent.)</p>

<p>Here's sample usage:</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt; // defines uintN_t types
#include &lt;inttypes.h&gt; // defines PRIx macros

int main(void)
{
    float f = 3.1415926, f2;
    double d = 3.14159265358979323, d2;
    uint32_t fi;
    uint64_t di;

    fi = pack754_32(f);
    f2 = unpack754_32(fi);

    di = pack754_64(d);
    d2 = unpack754_64(di);

    printf("float before : %.7f\n", f);
    printf("float encoded: 0x%08" PRIx32 "\n", fi);
    printf("float after  : %.7f\n\n", f2);

    printf("double before : %.20lf\n", d);
    printf("double encoded: 0x%016" PRIx64 "\n", di);
    printf("double after  : %.20lf\n", d2);

    return 0;
}</pre>


<p>The above code produces this output:</p>

<pre class="screen">float before : 3.1415925
float encoded: 0x40490FDA
float after  : 3.1415925

double before : 3.14159265358979311600
double encoded: 0x400921FB54442D18
double after  : 3.14159265358979311600</pre>


<p>Another question you might have is how do you pack
<nobr><tt class="type">struct</tt></nobr>s?  Unfortunately for you, the compiler is free to
put padding all over the place in a <nobr><tt class="type">struct</tt></nobr>, and that means
you can't portably send the whole thing over the wire in one chunk.
(Aren't you getting sick of hearing "can't do this", "can't do that"?
Sorry!  To quote a friend, "Whenever anything goes wrong, I always blame
Microsoft."  This one might not be Microsoft's fault, admittedly, but my
friend's statement is completely true.)</p>

<p>Back to it: the best way to send the <nobr><tt class="type">struct</tt></nobr> over the
wire is to pack each field independently and then unpack them into the
<nobr><tt class="type">struct</tt></nobr> when they arrive on the other side.</p>

<p>That's a lot of work, is what you're thinking.  Yes, it is.  One
thing you can do is write a helper function to help pack the data for
you.  It'll be fun!  Really!</p>

<p>In the book "<a href="http://cm.bell-labs.com/cm/cs/tpop/" target="_blank">The Practice of
Programming</a>" by Kernighan and Pike, they implement
<b><tt class="func">printf()</tt></b>-like functions called <b><tt class="func">pack()</tt></b>  and
<b><tt class="func">unpack()</tt></b> that do exactly this.  I'd link to them, but
apparently those functions aren't online with the rest of the
source from the book.</p>

<p>(The Practice of Programming is an excellent read.  Zeus saves a
kitten every time I recommend it.)</p>

<p>At this point, I'm going to drop a pointer to the BSD-licensed <a href="http://tpl.sourceforge.net/" target="_blank">Typed Parameter Language C API</a> which I've never
used, but looks completely respectable.  Python and Perl programmers
will want to check out their language's <b><tt class="func">pack()</tt></b> and
<b><tt class="func">unpack()</tt></b> functions for accomplishing the same thing.  And
Java has a big-ol' Serializable interface that can be used in a similar
way.</p>

<p>But if you want to write your own packing utility in C, K&amp;P's
trick is to use variable argument lists to make
<b><tt class="func">printf()</tt></b>-like functions to build the packets.  <a href="http://beej.us/guide/bgnet/examples/pack2.c" target="_blank">Here's a version I cooked up</a> on my own
based on that which hopefully will be enough to give you an idea of how
such a thing can work.</p>

<p>(This code references the <b><tt class="func">pack754()</tt></b> functions, above.
The <b><tt class="func">packi*()</tt></b> functions operate like the familiar
<b><tt class="func">htons()</tt></b> family, except they pack into a <nobr><tt class="type">char</tt></nobr>
array instead of another integer.)</p>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;

/*
** packi16() -- store a 16-bit int into a char buffer (like htons())
*/ 
void packi16(unsigned char *buf, unsigned int i)
{
    *buf++ = i&gt;&gt;8; *buf++ = i;
}

/*
** packi32() -- store a 32-bit int into a char buffer (like htonl())
*/ 
void packi32(unsigned char *buf, unsigned long int i)
{
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** packi64() -- store a 64-bit int into a char buffer (like htonl())
*/ 
void packi64(unsigned char *buf, unsigned long long int i)
{
    *buf++ = i&gt;&gt;56; *buf++ = i&gt;&gt;48;
    *buf++ = i&gt;&gt;40; *buf++ = i&gt;&gt;32;
    *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
    *buf++ = i&gt;&gt;8;  *buf++ = i;
}

/*
** unpacki16() -- unpack a 16-bit int from a char buffer (like ntohs())
*/ 
int unpacki16(unsigned char *buf)
{
    unsigned int i2 = ((unsigned int)buf[0]&lt;&lt;8) | buf[1];
    int i;

    // change unsigned numbers to signed
    if (i2 &lt;= 0x7fffu) { i = i2; }
    else { i = -1 - (unsigned int)(0xffffu - i2); }

    return i;
}

/*
** unpacku16() -- unpack a 16-bit unsigned from a char buffer (like ntohs())
*/ 
unsigned int unpacku16(unsigned char *buf)
{
    return ((unsigned int)buf[0]&lt;&lt;8) | buf[1];
}

/*
** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())
*/ 
long int unpacki32(unsigned char *buf)
{
    unsigned long int i2 = ((unsigned long int)buf[0]&lt;&lt;24) |
                           ((unsigned long int)buf[1]&lt;&lt;16) |
                           ((unsigned long int)buf[2]&lt;&lt;8)  |
                           buf[3];
    long int i;

    // change unsigned numbers to signed
    if (i2 &lt;= 0x7fffffffu) { i = i2; }
    else { i = -1 - (long int)(0xffffffffu - i2); }

    return i;
}

/*
** unpacku32() -- unpack a 32-bit unsigned from a char buffer (like ntohl())
*/ 
unsigned long int unpacku32(unsigned char *buf)
{
    return ((unsigned long int)buf[0]&lt;&lt;24) |
           ((unsigned long int)buf[1]&lt;&lt;16) |
           ((unsigned long int)buf[2]&lt;&lt;8)  |
           buf[3];
}

/*
** unpacki64() -- unpack a 64-bit int from a char buffer (like ntohl())
*/ 
long long int unpacki64(unsigned char *buf)
{
    unsigned long long int i2 = ((unsigned long long int)buf[0]&lt;&lt;56) |
                                ((unsigned long long int)buf[1]&lt;&lt;48) |
                                ((unsigned long long int)buf[2]&lt;&lt;40) |
                                ((unsigned long long int)buf[3]&lt;&lt;32) |
                                ((unsigned long long int)buf[4]&lt;&lt;24) |
                                ((unsigned long long int)buf[5]&lt;&lt;16) |
                                ((unsigned long long int)buf[6]&lt;&lt;8)  |
                                buf[7];
    long long int i;

    // change unsigned numbers to signed
    if (i2 &lt;= 0x7fffffffffffffffu) { i = i2; }
    else { i = -1 -(long long int)(0xffffffffffffffffu - i2); }

    return i;
}

/*
** unpacku64() -- unpack a 64-bit unsigned from a char buffer (like ntohl())
*/ 
unsigned long long int unpacku64(unsigned char *buf)
{
    return ((unsigned long long int)buf[0]&lt;&lt;56) |
           ((unsigned long long int)buf[1]&lt;&lt;48) |
           ((unsigned long long int)buf[2]&lt;&lt;40) |
           ((unsigned long long int)buf[3]&lt;&lt;32) |
           ((unsigned long long int)buf[4]&lt;&lt;24) |
           ((unsigned long long int)buf[5]&lt;&lt;16) |
           ((unsigned long long int)buf[6]&lt;&lt;8)  |
           buf[7];
}

/*
** pack() -- store data dictated by the format string in the buffer
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C         
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (16-bit unsigned length is automatically prepended to strings)
*/ 

unsigned int pack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    signed char c;              // 8-bit
    unsigned char C;

    int h;                      // 16-bit
    unsigned int H;

    long int l;                 // 32-bit
    unsigned long int L;

    long long int q;            // 64-bit
    unsigned long long int Q;

    float f;                    // floats
    double d;
    long double g;
    unsigned long long int fhold;

    char *s;                    // strings
    unsigned int len;

    unsigned int size = 0;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'c': // 8-bit
            size += 1;
            c = (signed char)va_arg(ap, int); // promoted
            *buf++ = c;
            break;

        case 'C': // 8-bit unsigned
            size += 1;
            C = (unsigned char)va_arg(ap, unsigned int); // promoted
            *buf++ = C;
            break;

        case 'h': // 16-bit
            size += 2;
            h = va_arg(ap, int);
            packi16(buf, h);
            buf += 2;
            break;

        case 'H': // 16-bit unsigned
            size += 2;
            H = va_arg(ap, unsigned int);
            packi16(buf, H);
            buf += 2;
            break;

        case 'l': // 32-bit
            size += 4;
            l = va_arg(ap, long int);
            packi32(buf, l);
            buf += 4;
            break;

        case 'L': // 32-bit unsigned
            size += 4;
            L = va_arg(ap, unsigned long int);
            packi32(buf, L);
            buf += 4;
            break;

        case 'q': // 64-bit
            size += 8;
            q = va_arg(ap, long long int);
            packi64(buf, q);
            buf += 8;
            break;

        case 'Q': // 64-bit unsigned
            size += 8;
            Q = va_arg(ap, unsigned long long int);
            packi64(buf, Q);
            buf += 8;
            break;

        case 'f': // float-16
            size += 2;
            f = (float)va_arg(ap, double); // promoted
            fhold = pack754_16(f); // convert to IEEE 754
            packi16(buf, fhold);
            buf += 2;
            break;

        case 'd': // float-32
            size += 4;
            d = va_arg(ap, double);
            fhold = pack754_32(d); // convert to IEEE 754
            packi32(buf, fhold);
            buf += 4;
            break;

        case 'g': // float-64
            size += 8;
            g = va_arg(ap, long double);
            fhold = pack754_64(g); // convert to IEEE 754
            packi64(buf, fhold);
            buf += 8;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = strlen(s);
            size += len + 2;
            packi16(buf, len);
            buf += 2;
            memcpy(buf, s, len);
            buf += len;
            break;
        }
    }

    va_end(ap);

    return size;
}

/*
** unpack() -- unpack data dictated by the format string into the buffer
**
**   bits |signed   unsigned   float   string
**   -----+----------------------------------
**      8 |   c        C         
**     16 |   h        H         f
**     32 |   l        L         d
**     64 |   q        Q         g
**      - |                               s
**
**  (string is extracted based on its stored length, but 's' can be
**  prepended with a max length)
*/
void unpack(unsigned char *buf, char *format, ...)
{
    va_list ap;

    signed char *c;              // 8-bit
    unsigned char *C;

    int *h;                      // 16-bit
    unsigned int *H;

    long int *l;                 // 32-bit
    unsigned long int *L;

    long long int *q;            // 64-bit
    unsigned long long int *Q;

    float *f;                    // floats
    double *d;
    long double *g;
    unsigned long long int fhold;

    char *s;
    unsigned int len, maxstrlen=0, count;

    va_start(ap, format);

    for(; *format != '\0'; format++) {
        switch(*format) {
        case 'c': // 8-bit
            c = va_arg(ap, signed char*);
            if (*buf &lt;= 0x7f) { *c = *buf;} // re-sign
            else { *c = -1 - (unsigned char)(0xffu - *buf); }
            buf++;
            break;

        case 'C': // 8-bit unsigned
            C = va_arg(ap, unsigned char*);
            *C = *buf++;
            break;

        case 'h': // 16-bit
            h = va_arg(ap, int*);
            *h = unpacki16(buf);
            buf += 2;
            break;

        case 'H': // 16-bit unsigned
            H = va_arg(ap, unsigned int*);
            *H = unpacku16(buf);
            buf += 2;
            break;

        case 'l': // 32-bit
            l = va_arg(ap, long int*);
            *l = unpacki32(buf);
            buf += 4;
            break;

        case 'L': // 32-bit unsigned
            L = va_arg(ap, unsigned long int*);
            *L = unpacku32(buf);
            buf += 4;
            break;

        case 'q': // 64-bit
            q = va_arg(ap, long long int*);
            *q = unpacki64(buf);
            buf += 8;
            break;

        case 'Q': // 64-bit unsigned
            Q = va_arg(ap, unsigned long long int*);
            *Q = unpacku64(buf);
            buf += 8;
            break;

        case 'f': // float
            f = va_arg(ap, float*);
            fhold = unpacku16(buf);
            *f = unpack754_16(fhold);
            buf += 2;
            break;

        case 'd': // float-32
            d = va_arg(ap, double*);
            fhold = unpacku32(buf);
            *d = unpack754_32(fhold);
            buf += 4;
            break;

        case 'g': // float-64
            g = va_arg(ap, long double*);
            fhold = unpacku64(buf);
            *g = unpack754_64(fhold);
            buf += 8;
            break;

        case 's': // string
            s = va_arg(ap, char*);
            len = unpacku16(buf);
            buf += 2;
            if (maxstrlen &gt; 0 &amp;&amp; len &gt; maxstrlen) count = maxstrlen - 1;
            else count = len;
            memcpy(s, buf, count);
            s[count] = '\0';
            buf += len;
            break;

        default:
            if (isdigit(*format)) { // track max str len
                maxstrlen = maxstrlen * 10 + (*format-'0');
            }
        }

        if (!isdigit(*format)) maxstrlen = 0;
    }

    va_end(ap);
}</pre>


<p>And <a href="http://beej.us/guide/bgnet/examples/pack2.c" target="_blank">here is a demonstration
program</a> of the above code that packs some data into
<i><tt class="var">buf</tt></i> and then unpacks it into variables.  Note that when
calling <b><tt class="func">unpack()</tt></b> with a string argument (format specifier
"<tt class="const">s</tt>"), it's wise to put a maximum length count in front of
it to prevent a buffer overrun, e.g. "<tt class="const">96s</tt>".  Be wary when
unpacking data you get over the network‚Äîa malicious user might
send badly-constructed packets in an effort to attack your system!</p>

<pre class="code">#include &lt;stdio.h&gt;

// various bits for floating point types--
// varies for different architectures
typedef float float32_t;
typedef double float64_t;

int main(void)
{
    unsigned char buf[1024];
    int8_t magic;
    int16_t monkeycount;
    int32_t altitude;
    float32_t absurdityfactor;
    char *s = "Great unmitigated Zot!  You've found the Runestaff!";
    char s2[96];
    int16_t packetsize, ps2;

    packetsize = pack(buf, "chhlsf", (int8_t)'B', (int16_t)0, (int16_t)37, 
            (int32_t)-5, s, (float32_t)-3490.6677);
    packi16(buf+1, packetsize); // store packet size in packet for kicks

    printf("packet is %" PRId32 " bytes\n", packetsize);

    unpack(buf, "chhl96sf", &amp;magic, &amp;ps2, &amp;monkeycount, &amp;altitude, s2,
        &amp;absurdityfactor);

    printf("'%c' %" PRId32" %" PRId16 " %" PRId32
            " \"%s\" %f\n", magic, ps2, monkeycount,
            altitude, s2, absurdityfactor);

    return 0;
}</pre>


<p>Whether you roll your own code or use someone else's, it's a good
idea to have a general set of data packing routines for the sake of
keeping bugs in check, rather than packing each bit by hand each
time.</p>

<p>When packing the data, what's a good format to use?  Excellent
question.  Fortunately, <a name="indexId434909-169"></a><a href="http://tools.ietf.org/html/rfc4506" target="_blank">RFC 4506</a>, the External Data
Representation Standard, already defines binary formats for a bunch of
different types, like floating point types, integer types, arrays, raw
data, etc.  I suggest conforming to that if you're going to roll the
data yourself.  But you're not obligated to.  The Packet Police are not
right outside your door.  At least, I don't <i>think</i> they are.</p>

<p>In any case, encoding the data somehow or another before you send it
is the right way of doing things!</p>









<h3 class="sect2title">7.5. <a name="sonofdataencap">Son of Data Encapsulation</a></h3>


<p>What does it really mean to encapsulate data, anyway?  In the
simplest case, it means you'll stick a header on there with either some
identifying information or a packet length, or both.</p>

<p>What should your header look like?  Well, it's just some binary
data that represents whatever you feel is necessary to complete your
project.</p>

<p>Wow.  That's vague.</p>

<p>Okay.  For instance, let's say you have a multi-user chat program
that uses <tt class="const">SOCK_STREAM</tt>s.  When a user types ("says")
something, two pieces of information need to be transmitted to the
server: what was said and who said it.</p>

<p>So far so good?  "What's the problem?" you're asking.</p>

<p>The problem is that the messages can be of varying lengths.  One
person named "tom" might say, "Hi", and another person named
"Benjamin" might say, "Hey guys what is up?"</p>

<p>So you <b><tt class="func">send()</tt></b> all this stuff to the clients
as it comes in.  Your outgoing data stream looks like this:</p>

<pre class="screen">t o m H i B e n j a m i n H e y g u y s w h a t i s u p ?</pre>


<p>And so on.  How does the client know when one message starts and
another stops?  You could, if you wanted, make all messages the same
length and just call the <a name="indexId434909-170"></a><b><tt class="func">sendall()</tt></b> we
implemented, <a href="#sendall">above</a>.  But that wastes
bandwidth!  We don't want to <b><tt class="func">send()</tt></b> 1024 bytes just so
"tom" can say "Hi".</p>

<p>So we <i>encapsulate</i> the data in a tiny header
and packet structure.  Both the client and server know how to pack and
unpack (sometimes referred to as "marshal" and "unmarshal") this data.
Don't look now, but we're starting to define a
<i>protocol</i> that describes how a client and server
communicate!</p>

<p>In this case, let's assume the user name is a fixed length of 8
characters, padded with <tt class="const">'\0'</tt>.  And then let's
assume the data is variable length, up to a maximum of 128
characters.  Let's have a look a sample packet structure that we might
use in this situation:</p>

<ol>


<li><tt class="tt">len</tt> (1 byte, unsigned)‚ÄîThe total length of the
packet, counting the 8-byte user name and chat data.</li>


<li><tt class="tt">name</tt> (8 bytes)‚ÄîThe user's name, NUL-padded if
necessary.</li>


<li><tt class="tt">chatdata</tt>
(<i>n</i>-bytes)‚ÄîThe data itself, no more than 128 bytes.
The length of the packet should be calculated as the length of this data
plus 8 (the length of the name field, above).</li>


</ol>


<p>Why did I choose the 8-byte and 128-byte limits for the fields?  I
pulled them out of the air, assuming they'd be long enough.  Maybe,
though, 8 bytes is too restrictive for your needs, and you can have a
30-byte name field, or whatever.  The choice is up to you.</p>

<p>Using the above packet definition, the first packet would consist
of the following information (in hex and ASCII):</p>

<pre class="screen">   0A     74 6F 6D 00 00 00 00 00      48 69
(length)  T  o  m    (padding)         H  i
</pre>


<p>And the second is similar:</p>

<pre class="screen">   18     42 65 6E 6A 61 6D 69 6E      48 65 79 20 67 75 79 73 20 77 ...
(length)  B  e  n  j  a  m  i  n       H  e  y     g  u  y  s     w  ...
</pre>


<p>(The length is stored in Network Byte Order, of course.  In this
case, it's only one byte so it doesn't matter, but generally speaking
you'll want all your binary integers to be stored in Network Byte Order
in your packets.)</p>

<p>When you're sending this data, you should be safe and use a
command similar to <a href="#sendall"><b><tt class="func">sendall()</tt></b></a>, above, so you
know all the data is sent, even if it takes multiple calls to
<b><tt class="func">send()</tt></b> to get it all out.</p>

<p>Likewise, when you're receiving this data, you need to do a bit of extra
work.  To be safe, you should assume that you might receive a partial
packet (like maybe we receive "<tt class="tt">18 42 65
6E 6A</tt>" from Benjamin, above, but that's all we get in this
call to <b><tt class="func">recv()</tt></b>).  We need to call
<b><tt class="func">recv()</tt></b> over and over again until the packet is
completely received.</p>

<p>But how?  Well, we know the number of bytes we need to receive in
total for the packet to be complete, since that number is tacked on the
front of the packet.  We also know the maximum packet size is 1+8+128,
or 137 bytes (because that's how we defined the packet.)</p>

<p>There are actually a couple things you can do here.  Since you know
every packet starts off with a length, you can call <b><tt class="func">recv()</tt></b>
just to get the packet length.  Then once you have that, you can call it
again specifying exactly the remaining length of the packet (possibly
repeatedly to get all the data) until you have the complete packet.
The advantage of this method is that you only need a buffer large
enough for one packet, while the disadvantage is that you need to call
<b><tt class="func">recv()</tt></b> at least twice to get all the data.</p>

<p>Another option is just to call <b><tt class="func">recv()</tt></b> and say the amount
you're willing to receive is the maximum number of bytes in a packet.
Then whatever you get, stick it onto the back of a buffer, and finally
check to see if the packet is complete.  Of course, you might get some
of the next packet, so you'll need to have room for that.</p>

<p>What you can do is declare an array big enough for two packets.
This is your work array where you will reconstruct packets as they
arrive.</p>

<p>Every time you <b><tt class="func">recv()</tt></b> data, you'll append it
into the work buffer and check to see if the packet is complete.  That
is, the number of bytes in the buffer is greater than or equal to the
length specified in the header (+1, because the length in the header
doesn't include the byte for the length itself.)  If the number of bytes
in the buffer is less than 1, the packet is not complete, obviously.
You have to make a special case for this, though, since the first byte
is garbage and you can't rely on it for the correct packet
length.</p>

<p>Once the packet is complete, you can do with it what you
will.  Use it, and remove it from your work buffer.</p>

<p>Whew!  Are you juggling that in your head yet?  Well, here's the
second of the one-two punch: you might have read past the end of one
packet and onto the next in a single <b><tt class="func">recv()</tt></b> call.
That is, you have a work buffer with one complete packet, and an
incomplete part of the next packet!  Bloody heck.  (But this is why you
made your work buffer large enough to hold <i>two</i>
packets‚Äîin case this happened!)</p>

<p>Since you know the length of the first packet from the header, and
you've been keeping track of the number of bytes in the work buffer, you
can subtract and calculate how many of the bytes in the work buffer
belong to the second (incomplete) packet.  When you've handled the first
one, you can clear it out of the work buffer and move the partial second
packet down the to front of the buffer so it's all ready to go for the
next <b><tt class="func">recv()</tt></b>.</p>

<p>(Some of you readers will note that actually moving the partial
second packet to the beginning of the work buffer takes time, and the
program can be coded to not require this by using a circular buffer.
Unfortunately for the rest of you, a discussion on circular buffers is
beyond the scope of this article.  If you're still curious, grab a data
structures book and go from there.)</p>

<p>I never said it was easy.  Ok, I did say it was easy.  And it is;
you just need practice and pretty soon it'll come to you naturally.  By
<a name="indexId434909-171"></a>Excalibur I swear it!</p>

 






<h3 class="sect2title">7.6. <a name="broadcast">Broadcast Packets‚ÄîHello, World!</a></h3>


<p>So far, this guide has talked about sending data from one host to one
other host.  But it is possible, I insist, that you can, with the proper
authority, send data to multiple hosts <i>at the same time</i>!</p>

<p>With <a name="indexId434909-172"></a>UDP (only UDP, not TCP) and standard IPv4, this
is done through a mechanism called <a name="indexId434909-173"></a><i>broadcasting</i>.  With IPv6, broadcasting isn't
supported, and you have to resort to the often superior technique of
<i>multicasting</i>, which, sadly I won't be discussing at this
time.   But enough of the starry-eyed future‚Äîwe're stuck in the
32-bit present.</p>

<p>But wait!  You can't just run off and start broadcasting willy-nilly;
You have to <a name="indexId434909-174"></a>set the socket option <a name="indexId434909-175"></a><tt class="const">SO_BROADCAST</tt> before you can send a
broadcast packet out on the network.  It's like a one of those little
plastic covers they put over the missile launch switch!  That's just how
much power you hold in your hands!</p>

<p>But seriously, though, there is a danger to using broadcast packets,
and that is: every system that receives a broadcast packet must undo all
the onion-skin layers of data encapsulation until it finds out what port
the data is destined to.  And then it hands the data over or discards
it.  In either case, it's a lot of work for each machine that receives
the broadcast packet, and since it is all of them on the local network,
that could be a lot of machines doing a lot of unnecessary work.  When
the game Doom first came out, this was a complaint about its network
code.</p>

<p>Now, there is more than one way to skin a cat... wait a minute.  Is
there really more than one way to skin a cat?  What kind of expression
is that?  Uh, and likewise, there is more than one way to send a
broadcast packet.  So, to get to the meat and potatoes of the whole
thing: how do you specify the destination address for a broadcast
message?  There are two common ways:</p>

<ol>

<li>Send the data to a specific subnet's broadcast address.  This is the
subnet's network number with all one-bits set for the host portion of
the address.  For instance, at home my network is 192.168.1.0, my
netmask is 255.255.255.0, so the last byte of the address is my host
number (because the first three bytes, according to the netmask, are the
network number).  So my broadcast address is 192.168.1.255.  Under Unix,
the <b class="com">ifconfig</b> command will actually give you all this data.
(If you're curious, the bitwise logic to get your broadcast address is
<i><tt class="var">network_number</tt></i> OR (NOT <i><tt class="var">netmask</tt></i>).)  You can send
this type of broadcast packet to remote networks as well as your local
network, but you run the risk of the packet being dropped by the
destination's router.  (If they didn't drop it, then some random smurf
could start flooding their LAN with broadcast traffic.)</li>


<li>Send the data to the "global" broadcast address.  This is <a name="indexId434909-176"></a>255.255.255.255, aka
<a name="indexId434909-177"></a><tt class="const">INADDR_BROADCAST</tt>.  Many
machines will automatically bitwise AND this with your network number to
convert it to a network broadcast address, but some won't.  It varies.
Routers do not forward this type of broadcast packet off your local
network, ironically enough.</li>


</ol>


<p>So what happens if you try to send data on the broadcast address
without first setting the <tt class="const">SO_BROADCAST</tt> socket option?
Well, let's fire up good old <a href="#datagram"><b class="com">talker</b> and
<b class="com">listener</b></a> and see what happens.</p>

<pre class="screen">$ talker 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ talker 192.168.1.255 foo
sendto: Permission denied
$ talker 255.255.255.255 foo
sendto: Permission denied
</pre>


<p>Yes, it's not happy at all...because we didn't set the
<tt class="const">SO_BROADCAST</tt> socket option.  Do that, and now you can
<b><tt class="func">sendto()</tt></b> anywhere you want!</p>

<p>In fact, that's the <i>only difference</i> between a UDP
application that can broadcast and one that can't.  So let's take the
old <b class="com">talker</b> application and add one section that sets the
<tt class="const">SO_BROADCAST</tt> socket option.  We'll call this program
<a href="http://beej.us/guide/bgnet/examples/broadcaster.c" target="_blank">
<i><tt class="var">broadcaster.c</tt></i></a>:</p>


<pre class="code">/*
** broadcaster.c -- a datagram "client" like talker.c, except
**                  this one can broadcast
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#define SERVERPORT 4950    // the port users will be connecting to

int main(int argc, char *argv[])
{
    int sockfd;
    struct sockaddr_in their_addr; // connector's address information
    struct hostent *he;
    int numbytes;
    int broadcast = 1;
    //char broadcast = '1'; // if that doesn't work, try this

    if (argc != 3) {
        fprintf(stderr,"usage: broadcaster hostname message\n");
        exit(1);
    }

    if ((he=gethostbyname(argv[1])) == NULL) {  // get the host info
        perror("gethostbyname");
        exit(1);
    }

    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1) {
        perror("socket");
        exit(1);
    }

    // this call is what allows broadcast packets to be sent:
    if (setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;broadcast,
        sizeof broadcast) == -1) {
        perror("setsockopt (SO_BROADCAST)");
        exit(1);
    }

    their_addr.sin_family = AF_INET;     // host byte order
    their_addr.sin_port = htons(SERVERPORT); // short, network byte order
    their_addr.sin_addr = *((struct in_addr *)he-&gt;h_addr);
    memset(their_addr.sin_zero, '\0', sizeof their_addr.sin_zero);

    if ((numbytes=sendto(sockfd, argv[2], strlen(argv[2]), 0,
             (struct sockaddr *)&amp;their_addr, sizeof their_addr)) == -1) {
        perror("sendto");
        exit(1);
    }

    printf("sent %d bytes to %s\n", numbytes,
        inet_ntoa(their_addr.sin_addr));

    close(sockfd);

    return 0;
}</pre>



<p>What's different between this and a "normal" UDP client/server
situation?  Nothing!  (With the exception of the client being allowed to
send broadcast packets in this case.)  As such, go ahead and run the old
UDP <a href="#datagram"><b class="com">listener</b></a> program in one
window, and <b class="com">broadcaster</b> in another.  You should be now be
able to do all those sends that failed, above.</p>

<pre class="screen">$ broadcaster 192.168.1.2 foo
sent 3 bytes to 192.168.1.2
$ broadcaster 192.168.1.255 foo
sent 3 bytes to 192.168.1.255
$ broadcaster 255.255.255.255 foo
sent 3 bytes to 255.255.255.255
</pre>


<p>And you should see <b class="com">listener</b> responding that it got the
packets.  (If <b class="com">listener</b> doesn't respond, it could be because
it's bound to an IPv6 address.  Try changing the
<tt class="const">AF_UNSPEC</tt> in <i><tt class="var">listener.c</tt></i> to
<tt class="const">AF_INET</tt> to force IPv4.)</p>

<p>Well, that's kind of exciting.  But now fire up <b class="com">listener</b> on
another machine next to you on the same network so that you have two
copies going, one on each machine, and run <b class="com">broadcaster</b> again
with your broadcast address... Hey!  Both <b class="com">listener</b>s get the
packet even though you only called <b><tt class="func">sendto()</tt></b> once!
Cool!</p>

<p>If the <b class="com">listener</b> gets data you send directly to it, but not
data on the broadcast address, it could be that you have a <a name="indexId434909-178"></a>firewall on your local machine that is blocking the
packets.  (Yes, <a name="indexId434909-179"></a>Pat and <a name="indexId434909-180"></a>Bapper, thank
you for realizing before I did that this is why my sample code wasn't
working.  I told you I'd mention you in the guide, and here you are.  So
<i>nyah</i>.)</p>

<p>Again, be careful with broadcast packets.  Since every machine on the
LAN will be forced to deal with the packet whether it
<b><tt class="func">recvfrom()</tt></b>s it or not, it can present quite a load to the
entire computing network.  They are definitely to be used sparingly and
appropriately.</p>

 

 







<hr class="mainsectbreak"><h2 class="sect1title">8. <a name="faq">Common Questions</a></h2><hr class="mainsecthr">


<dl>





<dt><b>Where can I get those header files?</b></dt>


<dd><p><a name="indexId434909-181"></a>If you don't have them on your system
already, you probably don't need them.  Check the manual for your
particular platform.  If you're building for <a name="indexId434909-182"></a>Windows,
you only need to <tt class="tt">#include &lt;winsock.h&gt;</tt>.</p></dd>







<dt><b>What do I do when <b><tt class="func">bind()</tt></b> reports
<a name="indexId434909-183"></a>"Address already in use"?</b></dt>


<dd><p>You have to use <a name="indexId434909-184"></a><b><tt class="func">setsockopt()</tt></b>
with the <a name="indexId434909-185"></a><tt class="const">SO_REUSEADDR</tt> option on
the listening socket.  Check out the <a href="#bind">section on </a><a name="indexId434909-186"></a><b><tt class="func">bind()</tt></b> and the <a href="#select">section on </a><a name="indexId434909-187"></a><b><tt class="func">select()</tt></b> for an example.</p></dd>







<dt><b>How do I get a list of open sockets on the
system?</b></dt>


<dd><p>Use the <a name="indexId434909-188"></a><b class="com">netstat</b>.  Check the
<b class="com">man</b> page for full details, but you should get some good
output just typing:</p>

<pre class="screen">$ netstat</pre>


<p>The only trick is determining which socket is associated with
which program. <tt>:-)</tt></p></dd>







<dt><b>How can I view the routing table?</b></dt>


<dd><p>Run the <a name="indexId434909-189"></a><b class="com">route</b> command (in
<i><tt class="var">/sbin</tt></i> on most Linuxes) or the command
<a name="indexId434909-190"></a><b class="com">netstat -r</b>.</p></dd>







<dt><b>How can I run the client and server programs if I only
have one computer?  Don't I need a network to write network
programs?</b></dt>


<dd><p>Fortunately for you, virtually all machines implement a <a name="indexId434909-191"></a>loopback network "device" that sits in the kernel
and pretends to be a network card.  (This is the interface listed as
"<tt class="tt">lo</tt>" in the routing table.)</p>

<p>Pretend you're logged into a machine named
<a name="indexId434909-192"></a>"<tt class="tt">goat</tt>".  Run the client in one window
and the server in another.  Or start the server in the background
("<b class="com">server &amp;</b>") and run the client in the same
window.  The upshot of the loopback device is that you can either
<b class="com">client goat</b> or <a name="indexId434909-193"></a><b class="com">client localhost</b>
(since "<tt class="tt">localhost</tt>" is likely defined in
your <i><tt class="var">/etc/hosts</tt></i> file) and you'll have the client
talking to the server without a network!</p>

<p>In short, no changes are necessary to any of the code to make it
run on a single non-networked machine!  Huzzah!</p></dd>







<dt><b>How can I tell if the remote side has closed
connection?</b></dt>


<dd><p>You can tell because <b><tt class="func">recv()</tt></b> will
return <tt class="const">0</tt>.</p></dd>







<dt><b>How do I implement a <a name="indexId434909-194"></a>"ping" utility?  What is <a name="indexId434909-195"></a>ICMP?  Where can I find out more about <a name="indexId434909-196"></a>raw sockets and <tt class="const">SOCK_RAW</tt>?</b></dt>


<dd><p>All your raw sockets questions will be answered in <a href="#books">W. Richard Stevens' UNIX Network Programming books</a>.
Also, look in the <i><tt class="var">ping/</tt></i> subdirectory in Stevens' UNIX
Network Programming source code, <a href="http://www.unpbook.com/src.html" target="_blank">available
online</a>.</p></dd>







<dt><b>How do I change or shorten the timeout on a call to
<b><tt class="func">connect()</tt></b>?</b></dt>


<dd><p>Instead of giving you exactly the same answer that W. Richard
Stevens would give you, I'll just refer you to <a href="http://www.unpbook.com/src.html" target="_blank"><i><tt class="var">lib/connect_nonb.c</tt></i> in the UNIX Network
Programming source code</a>.</p>

<p>The gist of it is that you make a socket descriptor with
<b><tt class="func">socket()</tt></b>, <a href="#blocking">set it to
non-blocking</a>, call <b><tt class="func">connect()</tt></b>, and if all goes well
<b><tt class="func">connect()</tt></b> will return <tt class="const">-1</tt> immediately and
<i><tt class="var">errno</tt></i> will be set to <tt class="const">EINPROGRESS</tt>.  Then you
call <a href="#select"><b><tt class="func">select()</tt></b></a> with whatever
timeout you want, passing the socket descriptor in both the read and
write sets.  If it doesn't timeout, it means the <b><tt class="func">connect()</tt></b>
call completed.  At this point, you'll have to use
<b><tt class="func">getsockopt()</tt></b> with the <tt class="const">SO_ERROR</tt> option to get
the return value from the <b><tt class="func">connect()</tt></b> call, which should be
zero if there was no error.</p>

<p>Finally, you'll probably want to set the socket back to be blocking
again before you start transferring data over it.</p>

<p>Notice that this has the added benefit of allowing your program to do
something else while it's connecting, too.  You could, for example, set
the timeout to something low, like 500 ms, and update an indicator
onscreen each timeout, then call <b><tt class="func">select()</tt></b> again.  When
you've called <b><tt class="func">select()</tt></b> and timed-out, say, 20 times, you'll
know it's time to give up on the connection.</p>

<p>Like I said, check out Stevens' source for a perfectly excellent
example.</p></dd>







<dt><b>How do I build for Windows?</b></dt>


<dd><p>First, delete Windows and install Linux or BSD.
<tt>};-)</tt>.  No, actually, just see the <a href="#windows">section on building for
Windows</a> in the introduction.</p></dd>







<dt><b>How do I build for Solaris/SunOS?  I keep getting linker
errors when I try to compile!</b></dt>


<dd><p>The linker errors happen because Sun boxes don't
automatically compile in the socket libraries.  See the <a href="#solaris">section on building for Solaris/SunOS</a> in the
introduction for an example of how to do this.</p></dd>







<dt><b>Why does <b><tt class="func">select()</tt></b> keep falling out
on a signal?</b></dt>


<dd><p>Signals tend to cause blocked system calls to return
<tt class="const">-1</tt> with <i><tt class="var">errno</tt></i> set to <tt class="const">EINTR</tt>.
When you set up a signal handler with <a name="indexId434909-197"></a><b><tt class="func">sigaction()</tt></b>, you can set the flag <a name="indexId434909-198"></a><tt class="const">SA_RESTART</tt>, which is supposed to
restart the system call after it was interrupted.</p>

<p>Naturally, this doesn't always work.</p>

<p>My favorite solution to this involves a
<a name="indexId434909-199"></a><tt class="tt">goto</tt> statement.  You know this
irritates your professors to no end, so go for it!</p>

<pre class="code">select_restart:
if ((err = select(fdmax+1, &amp;readfds, NULL, NULL, NULL)) == -1) {
    if (errno == EINTR) {
        // some signal just interrupted us, so restart
        goto select_restart;
    }
    // handle the real error here:
    perror("select");
} 
</pre>


<p>Sure, you don't <i>need</i> to use
<tt class="tt">goto</tt> in this case; you can use other
structures to control it.  But I think the
<tt class="tt">goto</tt> statement is actually
cleaner.</p></dd>







<dt><b>How can I implement a <a name="indexId434909-200"></a>timeout on a call to
<b><tt class="func">recv()</tt></b>?</b></dt>


<dd><p>Use <a name="indexId434909-201"></a><a href="#select"><b><tt class="func">select()</tt></b></a>!  It allows you to specify a
timeout parameter for socket descriptors that you're looking to read
from.  Or, you could wrap the entire functionality in a single function,
like this:</p>

<pre class="code">#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int recvtimeout(int s, char *buf, int len, int timeout)
{
    fd_set fds;
    int n;
    struct timeval tv;

    // set up the file descriptor set
    FD_ZERO(&amp;fds);
    FD_SET(s, &amp;fds);

    // set up the struct timeval for the timeout
    tv.tv_sec = timeout;
    tv.tv_usec = 0;

    // wait until timeout or data received
    n = select(s+1, &amp;fds, NULL, NULL, &amp;tv);
    if (n == 0) return -2; // timeout!
    if (n == -1) return -1; // error

    // data must be here, so do a normal recv()
    return recv(s, buf, len, 0);
}
.
.
.
// Sample call to recvtimeout():
n = recvtimeout(s, buf, sizeof buf, 10); // 10 second timeout

if (n == -1) {
    // error occurred
    perror("recvtimeout");
}
else if (n == -2) {
    // timeout occurred
} else {
    // got some data in buf
}
.
.
. 
</pre>


<p>Notice that <a name="indexId434909-202"></a><b><tt class="func">recvtimeout()</tt></b>
returns <tt class="const">-2</tt> in case of a timeout.  Why not return
<tt class="const">0</tt>?  Well, if you recall, a return value of
<tt class="const">0</tt> on a call to <b><tt class="func">recv()</tt></b> means that the remote
side closed the connection.  So that return value is already spoken for,
and <tt class="const">-1</tt> means "error", so I chose <tt class="const">-2</tt> as my
timeout indicator.</p>

</dd>











<dt><b>How do I <a name="indexId434909-203"></a>encrypt or compress the data before
sending it through the socket?</b></dt>


<dd>

<p>One easy way to do encryption is to use <a name="indexId434909-204"></a>SSL (secure
sockets layer), but that's beyond the scope of this guide.  (<a name="indexId434909-205"></a>Check out the <a href="http://www.openssl.org/" target="_blank">OpenSSL
project</a> for more info.)</p>

<p>But assuming you want to plug in or implement your own <a name="indexId434909-206"></a>compressor
or encryption system, it's just a matter of thinking of your data as
running through a sequence of steps between both ends.  Each step
changes the data in some way.</p>

<ol>

<li>server reads data from file (or wherever)</li>

<li>server encrypts/compresses data  (you add this part)</li>

<li>server <b><tt class="func">send()</tt></b>s encrypted data</li>

</ol>


<p>Now the other way around:</p>

<ol>

<li>client <b><tt class="func">recv()</tt></b>s encrypted data</li>

<li>client decrypts/decompresses data  (you add this part)</li>

<li>client writes data to file (or wherever)</li>

</ol>


<p>If you're going to compress and encrypt, just remember to compress
first.  <tt>:-)</tt></p>

<p>Just as long as the client properly undoes what the server does,
the data will be fine in the end no matter how many intermediate steps
you add.</p>

<p>So all you need to do to use my code is to find the place between
where the data is read and the data is sent (using
<b><tt class="func">send()</tt></b>) over the network, and stick some code in
there that does the encryption.</p>

</dd>








<dt><b><a name="indexId434909-207"></a><a name="indexId434909-208"></a>What is this
"<tt class="const">PF_INET</tt>" I keep seeing?  Is it related to
<tt class="const">AF_INET</tt>?</b></dt>


<dd>
<p>Yes, yes it is.  See <a href="#socket">the section on
<b><tt class="func">socket()</tt></b></a> for details.</p>

</dd>








<dt><b>How can I write a server that accepts shell commands
from a client and executes them?</b></dt>


<dd>

<p>For simplicity, lets say the client
<b><tt class="func">connect()</tt></b>s, <b><tt class="func">send()</tt></b>s, and
<b><tt class="func">close()</tt></b>s the connection (that is, there are no
subsequent system calls without the client connecting again.)</p>

<p>The process the client follows is this:</p>

<ol>

<li><b><tt class="func">connect()</tt></b> to server</li>

<li><b><tt class="func">send("/sbin/ls &gt; /tmp/client.out")</tt></b></li>

<li><b><tt class="func">close()</tt></b> the connection</li>

</ol>


<p>Meanwhile, the server is handling the data and executing
it:</p>

<ol>

<li><b><tt class="func">accept()</tt></b> the connection from the client</li>

<li><b><tt class="func">recv(str)</tt></b> the command string</li>

<li><b><tt class="func">close()</tt></b> the connection</li>

<li><b><tt class="func">system(str)</tt></b> to run the command</li>

</ol>


<p><a name="indexId434909-209"></a><i>Beware!</i>  Having the server execute
what the client says is like giving remote shell access and people can
do things to your account when they connect to the server.  For
instance, in the above example, what if the client sends "<b class="com">rm -rf
~</b>"?  It deletes everything in your account, that's what!</p>

<p>So you get wise, and you prevent the client from using any except
for a couple utilities that you know are safe, like the
<b class="com">foobar</b> utility:</p>

<pre class="code">if (!strncmp(str, "foobar", 6)) {
    sprintf(sysstr, "%s &gt; /tmp/server.out", str);
    system(sysstr);
} 
</pre>


<p>But you're still unsafe, unfortunately: what if the client enters
"<b class="com">foobar; rm -rf ~</b>"?  The safest thing to do is to
write a little routine that puts an escape ("<tt class="const">\</tt>")
character in front of all non-alphanumeric characters (including spaces,
if appropriate) in the arguments for the command.</p>

<p>As you can see, security is a pretty big issue when the server
starts executing things the client sends.</p>

</dd>








<dt><b>I'm sending a slew of data, but when I
<b><tt class="func">recv()</tt></b>, it only receives 536 bytes or 1460 bytes at
a time.  But if I run it on my local machine, it receives all the data
at the same time.  What's going on?</b></dt>


<dd>

<p>You're hitting the <a name="indexId434909-210"></a>MTU‚Äîthe maximum size the
physical medium can handle.  On the local machine, you're using the
loopback device which can handle 8K or more no problem.  But on
Ethernet, which can only handle 1500 bytes with a header, you hit that
limit.  Over a modem, with 576 MTU (again, with header), you hit the
even lower limit.</p>

<p>You have to make sure all the data is being sent, first of all.
(See the <a href="#sendall"><b><tt class="func">sendall()</tt></b></a>
function implementation for details.) Once you're sure of that, then you
need to call <b><tt class="func">recv()</tt></b> in a loop until all your data
is read.</p>

<p>Read the section <a href="#sonofdataencap">Son of Data
Encapsulation</a> for details on receiving complete packets of data
using multiple calls to <b><tt class="func">recv()</tt></b>.</p>

</dd>








<dt><b>I'm on a Windows box and I don't have the
<b><tt class="func">fork()</tt></b> system call or any kind of <nobr><tt class="type">struct
sigaction</tt></nobr>.  What to do?</b></dt>


<dd>
<p><a name="indexId434909-211"></a>If they're anywhere, they'll be in POSIX libraries
that may have shipped with your compiler.  Since I don't have a Windows
box, I really can't tell you the answer, but I seem to remember that
Microsoft has a POSIX compatibility layer and that's where
<b><tt class="func">fork()</tt></b> would be.  (And maybe even
<nobr><tt class="type">sigaction</tt></nobr>.)</p>

<p>Search the help that came with VC++ for "fork" or "POSIX" and see if it
gives you any clues.</p>

<p>If that doesn't work at all, ditch the
<b><tt class="func">fork()</tt></b>/<nobr><tt class="type">sigaction</tt></nobr> stuff and replace it with the
Win32 equivalent: <a name="indexId434909-212"></a><b><tt class="func">CreateProcess()</tt></b>.  I don't know how
to use <b><tt class="func">CreateProcess()</tt></b>‚Äîit takes a bazillion
arguments, but it should be covered in the docs that came with VC++.</p>

</dd>










<dt><b><a name="indexId434909-213"></a>I'm behind a firewall‚Äîhow do I let people
outside the firewall know my IP address so they can connect to my
machine?</b></dt>


<dd><p>Unfortunately, the purpose of a firewall is to prevent
people outside the firewall from connecting to machines inside the
firewall, so allowing them to do so is basically considered a breach of
security.</p>

<p>This isn't to say that all is lost.  For one thing, you can still
often <b><tt class="func">connect()</tt></b> through the firewall if it's doing
some kind of masquerading or NAT or something like that.  Just design
your programs so that you're always the one initiating the connection,
and you'll be fine.</p>

<p><a name="indexId434909-214"></a>If that's not satisfactory, you
can ask your sysadmins to poke a hole in the firewall so that people can
connect to you.  The firewall can forward to you either through it's NAT
software, or through a proxy or something like that.</p>

<p>Be aware that a hole in the firewall is nothing to be taken
lightly.  You have to make sure you don't give bad people access to the
internal network; if you're a beginner, it's a lot harder to make
software secure than you might imagine.</p>

<p>Don't make your sysadmin mad at me.
<tt>;-)</tt></p></dd>






<dt><b><a name="indexId434909-215"></a><a name="indexId434909-216"></a>How do I write
a packet sniffer?  How do I put my Ethernet interface into promiscuous
mode?</b></dt>


<dd><p>For those not in the know, when a network card is in "promiscuous
mode", it will forward ALL packets to the operating system, not just
those that were addressed to this particular machine.  (We're talking
Ethernet-layer addresses here, not IP addresses--but since ethernet is
lower-layer than IP, all IP addresses are effectively forwarded as
well.  See the section <a href="#lowlevel">Low Level Nonsense and
Network Theory</a> for more info.)</p>

<p>This is the basis for how a packet sniffer works.  It puts the
interface into promiscuous mode, then the OS gets every single packet
that goes by on the wire.  You'll have a socket of some type that you
can read this data from.</p>

<p>Unfortunately, the answer to the question varies depending on the
platform, but if you Google for, for instance, "windows promiscuous <a name="indexId434909-217"></a>ioctl" you'll probably get somewhere.  There's what looks
like <a href="http://interactive.linuxjournal.com/article/4659" target="_blank">a decent writeup in Linux Journal</a>,
as well.</p></dd>






<dt><b>How can I set a custom <a name="indexId434909-218"></a>timeout value for
a TCP or UDP socket?</b></dt>


<dd><p>It depends on your system.  You might search the net for <a name="indexId434909-219"></a><tt class="const">SO_RCVTIMEO</tt> and <a name="indexId434909-220"></a><tt class="const">SO_SNDTIMEO</tt> (for use with <a name="indexId434909-221"></a><b><tt class="func">setsockopt()</tt></b>) to see if your system
supports such functionality.</p>

<p>The Linux man page suggests using <b><tt class="func">alarm()</tt></b> or
<b><tt class="func">setitimer()</tt></b> as a substitute.</p>

</dd>






<dt><b>How can I tell which ports are available to use?  Is there a list of
"official" port numbers?</b></dt>


<dd><p>Usually this isn't an issue.  If you're writing, say, a web
server, then it's a good idea to use the well-known port 80 for your
software.  If you're writing just your own specialized server, then
choose a port at random (but greater than 1023) and give it a try.</p>

<p>If the port is already in use, you'll get an "Address already in use"
error when you try to <b><tt class="func">bind()</tt></b>.  Choose another port.  (It's
a good idea to allow the user of your software to specify an alternate
port either with a config file or a command line switch.)</p>

<p>There is a <a href="http://www.iana.org/assignments/port-numbers" target="_blank">list of official port
numbers</a> maintained by the Internet Assigned Numbers Authority
(IANA).  Just because something (over 1023) is in that list doesn't mean
you can't use the port.  For instance, Id Software's DOOM uses the same
port as "mdqs", whatever that is.  All that matters is that no one else
<i>on the same machine</i> is using that port when you want to use
it.</p>

</dd>







</dl>


 






 





<hr class="mainsectbreak"><h2 class="sect1title">9. <a name="man">Man Pages</a></h2><hr class="mainsecthr">


<p><a name="indexId434909-222"></a>In the Unix world, there are a lot of manuals.
They have little sections that describe individual functions that you
have at your disposal.</p>

<p>Of course, <b class="com">manual</b> would be too much of a thing to type.  I
mean, no one in the Unix world, including myself, likes to type that
much.  Indeed I could go on and on at great length about how much I
prefer to be terse but instead I shall be brief and not bore you with
long-winded diatribes about how utterly amazingly brief I prefer to be
in virtually all circumstances in their entirety.</p>

<p><i>[Applause]</i></p>

<p>Thank you.  What I am getting at is that these pages are called "man
pages" in the Unix world, and I have included my own personal truncated
variant here for your reading enjoyment.  The thing is, many of these
functions are way more general purpose than I'm letting on, but I'm only
going to present the parts that are relevant for Internet Sockets
Programming.</p>

<p>But wait!  That's not all that's wrong with my man pages:</p>

<ul>

<li>They are incomplete and only show the basics from the guide.</li>

<li>There are many more man pages than this in the real world.</li>

<li>They are different than the ones on your system.</li>

<li>The header files might be different for certain functions on your
system.</li>

<li>The function parameters might be different for certain functions on your
system.</li>

</ul>


<p>If you want the real information, check your local Unix man pages by
typing <b class="com">man whatever</b>, where "whatever" is something that
you're incredibly interested in, such as "<tt class="tt">accept</tt>".  (I'm sure
Microsoft Visual Studio has something similar in their help section.
But "man" is better because it is one byte more concise than "help".
Unix wins again!)</p>

<p>So, if these are so flawed, why even include them at all in the
Guide?  Well, there are a few reasons, but the best are that (a) these
versions are geared specifically toward network programming and are
easier to digest than the real ones, and (b) these versions contain
examples!</p>

<p>Oh!  And speaking of the examples, I don't tend to put in all the
error checking because it really increases the length of the code.  But
you should absolutely do error checking pretty much any time you make
any of the system calls unless you're totally 100% sure it's not going
to fail, and you should probably do it even then!</p>



<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.1. <a name="acceptman"><b><tt class="titlefunc">accept()</tt></b></a></h2><p></p>

<p>Accept an incoming connection on a listening socket</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int accept(int <i><tt class="var em1">s</tt></i>, struct sockaddr *<i><tt class="var em1">addr</tt></i>, socklen_t *<i><tt class="var em1">addrlen</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-223"></a>Once you've gone through the trouble of getting a
<a name="indexId434909-224"></a><tt class="const">SOCK_STREAM</tt> socket and setting it
up for incoming connections with <b><tt class="func">listen()</tt></b>, then you call
<b><tt class="func">accept()</tt></b> to actually get yourself a new socket descriptor
to use for subsequent communication with the newly connected client.</p>

<p>The old socket that you are using for listening is still there, and
will be used for further <b><tt class="func">accept()</tt></b> calls as they come
in.</p>

<p>
</p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="20%%"><p><i><tt class="var">s</tt></i></p></td>

<td valign="top" align="left" width="78%%"><p>The <b><tt class="func">listen()</tt></b>ing socket descriptor.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">addr</tt></i></p></td>

<td valign="top" align="left"><p>This is filled in with the address of the site that's
connecting to you.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">addrlen</tt></i></p></td>

<td valign="top" align="left"><p>This is filled in with the <b><tt class="func">sizeof()</tt></b> the
structure returned in the <i><tt class="var">addr</tt></i> parameter.  You can safely
ignore it if you assume you're getting a <a name="indexId434909-225"></a>
<nobr><tt class="type">struct
sockaddr_in</tt></nobr> back, which you know you are, because that's the type
you passed in for <i><tt class="var">addr</tt></i>.</p></td>
</tr>

</tbody></table></center>

<p></p>

<p><b><tt class="func">accept()</tt></b> will normally block, and you can use
<b><tt class="func">select()</tt></b> to peek on the listening socket descriptor ahead
of time to see if it's "ready to read".  If so, then there's a new
connection waiting to be <b><tt class="func">accept()</tt></b>ed!  Yay!  Alternatively,
you could set the <a name="indexId434909-226"></a><tt class="const">O_NONBLOCK</tt> flag
on the listening socket using <a name="indexId434909-227"></a><b><tt class="func">fcntl()</tt></b>,
and then it will never block, choosing instead to return
<tt class="const">-1</tt> with <i><tt class="var">errno</tt></i> set to <a name="indexId434909-228"></a><tt class="const">EWOULDBLOCK</tt>.</p>

<p>The socket descriptor returned by <b><tt class="func">accept()</tt></b> is a bona
fide socket descriptor, open and connected to the remote host.  You have
to <b><tt class="func">close()</tt></b> it when you're done with it.</p>



<h3 class="sect2title">Return Value</h3>

<p><b><tt class="func">accept()</tt></b> returns the newly connected socket descriptor,
or <tt class="const">-1</tt> on error, with <i><tt class="var">errno</tt></i> set
appropriately.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">struct sockaddr_storage their_addr;
socklen_t addr_size;
struct addrinfo hints, *res;
int sockfd, new_fd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, MYPORT, &amp;hints, &amp;res);

// make a socket, bind it, and listen on it:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);
listen(sockfd, BACKLOG);

// now accept an incoming connection:

addr_size = sizeof their_addr;
new_fd = accept(sockfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

// ready to communicate on socket descriptor new_fd!</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#socketman"><b><tt class="func">socket()</tt></b></a>,
<a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a>,
<a href="#listenman"><b><tt class="func">listen()</tt></b></a>,
<a href="#sockaddr_inman"><nobr><tt class="type">struct sockaddr_in</tt></nobr></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.2. <a name="bindman"><b><tt class="titlefunc">bind()</tt></b></a></h2><p></p>

<p>Associate a socket with an IP address and port number</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int bind(int <i><tt class="var em1">sockfd</tt></i>, struct sockaddr *<i><tt class="var em1">my_addr</tt></i>, socklen_t <i><tt class="var em1">addrlen</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-229"></a>When a remote machine wants to connect to your
server program, it needs two pieces of information: the
<a name="indexId434909-230"></a>IP address and the <a name="indexId434909-231"></a>port number.
The <b><tt class="func">bind()</tt></b> call allows you to do just that.</p>

<p>First, you call <b><tt class="func">getaddrinfo()</tt></b> to load up a <b><tt class="func">struct
sockaddr</tt></b> with the destination address and port information.  Then
you call <b><tt class="func">socket()</tt></b> to get a socket descriptor, and then you
pass the socket and address into <b><tt class="func">bind()</tt></b>, and the IP address
and port are magically (using actual magic) bound to the socket!</p>

<p>If you don't know your IP address, or you know you only have one IP
address on the machine, or you don't care which of the machine's IP
addresses is used, you can simply pass the <tt class="const">AI_PASSIVE</tt>
flag in the <i><tt class="var">hints</tt></i> parameter to
<b><tt class="func">getaddrinfo()</tt></b>.  What this does is fill in the IP address
part of the <b><tt class="func">struct sockaddr</tt></b> with a special value that tells
<b><tt class="func">bind()</tt></b> that it should automatically fill in this host's IP
address.</p>

<p>What what?  What special value is loaded into the <b><tt class="func">struct
sockaddr</tt></b>'s IP address to cause it to auto-fill the address with
the current host?  I'll tell you, but keep in mind this is only if
you're filling out the <nobr><tt class="type">struct sockaddr</tt></nobr> by hand; if not, use
the results from <b><tt class="func">getaddrinfo()</tt></b>, as per above.  In IPv4, the
<i><tt class="var">sin_addr.s_addr</tt></i> field of the <nobr><tt class="type">struct
sockaddr_in</tt></nobr> structure is set to <tt class="const">INADDR_ANY</tt>.  In
IPv6, the <i><tt class="var">sin6_addr</tt></i> field of the <nobr><tt class="type">struct
sockaddr_in6</tt></nobr> structure is assigned into from the global variable
<i><tt class="var">in6addr_any</tt></i>.  Or, if you're declaring a new <nobr><tt class="type">struct
in6_addr</tt></nobr>, you can initialize it to
<tt class="const">IN6ADDR_ANY_INIT</tt>.</p>

<p>Lastly, the <i><tt class="var">addrlen</tt></i> parameter should be set to
<tt class="tt">sizeof my_addr</tt>.</p>


<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">// modern way of doing things with getaddrinfo()

struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// make a socket:
// (you should actually walk the "res" linked list and error-check!)

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>


<pre class="code">// example of packing a struct by hand, IPv4

struct sockaddr_in myaddr;
int s;

myaddr.sin_family = AF_INET;
myaddr.sin_port = htons(3490);

// you can specify an IP address:
inet_pton(AF_INET, "63.161.169.137", &amp;(myaddr.sin_addr));

// or you can let it automatically select one:
myaddr.sin_addr.s_addr = INADDR_ANY;

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;myaddr, sizeof myaddr);</pre>




<h3 class="sect2title">See Also</h3>

<p><a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a>,
<a href="#socketman"><b><tt class="func">socket()</tt></b></a>,
<a href="#sockaddr_inman"><nobr><tt class="type">struct sockaddr_in</tt></nobr></a>,
<a href="#sockaddr_inman"><nobr><tt class="type">struct in_addr</tt></nobr></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.3. <a name="connectman"><b><tt class="titlefunc">connect()</tt></b></a></h2><p></p>

<p>Connect a socket to a server</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int connect(int <i><tt class="var em1">sockfd</tt></i>, const struct sockaddr *<i><tt class="var em1">serv_addr</tt></i>,
            socklen_t <i><tt class="var em1">addrlen</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-232"></a>Once you've built a socket descriptor with the
<b><tt class="func">socket()</tt></b> call, you can <b><tt class="func">connect()</tt></b> that socket
to a remote server using the well-named <b><tt class="func">connect()</tt></b> system
call.  All you need to do is pass it the socket descriptor and the
address of the server you're interested in getting to know better.  (Oh,
and the length of the address, which is commonly passed to functions
like this.)</p>

<p>Usually this information comes along as the result of a call to
<b><tt class="func">getaddrinfo()</tt></b>, but you can fill out your own <nobr><tt class="type">struct
sockaddr</tt></nobr> if you want to.</p>

<p>If you haven't yet called <b><tt class="func">bind()</tt></b> on the socket
descriptor, it is automatically bound to your IP address and a random
local port.  This is usually just fine with you if you're not a server,
since you really don't care what your local port is; you only care what
the remote port is so you can put it in the <i><tt class="var">serv_addr</tt></i>
parameter.  You <i>can</i> call <b><tt class="func">bind()</tt></b> if you really
want your client socket to be on a specific IP address and port, but
this is pretty rare.</p>

<p>Once the socket is <b><tt class="func">connect()</tt></b>ed, you're free to
<b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b> data on it to your heart's
content.</p>

<p><a name="indexId434909-233"></a>Special note: if you
<b><tt class="func">connect()</tt></b> a <tt class="const">SOCK_DGRAM</tt> UDP socket to a
remote host, you can use <b><tt class="func">send()</tt></b> and <b><tt class="func">recv()</tt></b> as
well as <b><tt class="func">sendto()</tt></b> and <b><tt class="func">recvfrom()</tt></b>.  If you
want.</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">// connect to www.example.com port 80 (http)

struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;

// we could put "80" instead on "http" on the next line:
getaddrinfo("www.example.com", "http", &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// connect it to the address and port we passed in to getaddrinfo():

connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#socketman"><b><tt class="func">socket()</tt></b></a>,
<a href="#bindman"><b><tt class="func">bind()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.4. <a name="closeman"><b><tt class="titlefunc">close()</tt></b></a></h2><p></p>

<p>Close a socket descriptor</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;unistd.h&gt;

int close(int <i><tt class="var em1">s</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-234"></a>After you've finished using the socket for
whatever demented scheme you have concocted and you don't want to
<b><tt class="func">send()</tt></b> or <b><tt class="func">recv()</tt></b> or, indeed, do <i>anything
else</i> at all with the socket, you can <b><tt class="func">close()</tt></b> it, and
it'll be freed up, never to be used again.</p>

<p>The remote side can tell if this happens one of two ways. One: if the
remote side calls <b><tt class="func">recv()</tt></b>, it will return <tt class="const">0</tt>.
Two: if the remote side calls <b><tt class="func">send()</tt></b>, it'll receive a
signal <a name="indexId434909-235"></a><tt class="const">SIGPIPE</tt> and send() will return
<tt class="const">-1</tt> and <i><tt class="var">errno</tt></i> will be set to <a name="indexId434909-236"></a><tt class="const">EPIPE</tt>.</p>

<p><a name="indexId434909-237"></a><b>Windows users</b>: the function you need to use
is called <a name="indexId434909-238"></a><b><tt class="func">closesocket()</tt></b>, not
<b><tt class="func">close()</tt></b>.  If you try to use <b><tt class="func">close()</tt></b> on a
socket descriptor, it's possible Windows will get angry... And you
wouldn't like it when it's angry.</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">s = socket(PF_INET, SOCK_DGRAM, 0);
.
.
.
// a whole lotta stuff...*BRRRONNNN!*
.
.
.
close(s);  // not much to it, really.</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#socketman"><b><tt class="func">socket()</tt></b></a>,
<a href="#shutdownman"><b><tt class="func">shutdown()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.5. <a name="getaddrinfoman"><b><tt class="titlefunc">getaddrinfo()</tt></b>, <b><tt class="titlefunc">freeaddrinfo()</tt></b>,
<b><tt class="titlefunc">gai_strerror()</tt></b></a></h2><p></p>

<p>Get information about a host name and/or service and load up a
<nobr><tt class="type">struct sockaddr</tt></nobr> with the result.</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getaddrinfo(const char *nodename, const char *servname,
                const struct addrinfo *hints, struct addrinfo **res);

void freeaddrinfo(struct addrinfo *ai);

const char *gai_strerror(int ecode);

struct addrinfo {
  int     ai_flags;          // AI_PASSIVE, AI_CANONNAME, ...
  int     ai_family;         // AF_xxx
  int     ai_socktype;       // SOCK_xxx
  int     ai_protocol;       // 0 (auto) or IPPROTO_TCP, IPPROTO_UDP 

  socklen_t  ai_addrlen;     // length of ai_addr
  char   *ai_canonname;      // canonical name for nodename
  struct sockaddr  *ai_addr; // binary address
  struct addrinfo  *ai_next; // next structure in linked list
};</pre>


<h3 class="sect2title">Description</h3>

<p><b><tt class="func">getaddrinfo()</tt></b> is an excellent function that will return
information on a particular host name (such as its IP address) and load
up a <nobr><tt class="type">struct sockaddr</tt></nobr> for you, taking care of the gritty
details (like if it's IPv4 or IPv6.)  It replaces the old functions
<b><tt class="func">gethostbyname()</tt></b> and <b><tt class="func">getservbyname()</tt></b>.The
description, below, contains a lot of information that might be a little
daunting, but actual usage is pretty simple.  It might be worth it to
check out the examples first.</p>

<p>The host name that you're interested in goes in the
<i><tt class="var">nodename</tt></i> parameter.  The address can be either a host
name, like "www.example.com", or an IPv4 or IPv6 address (passed as a
string).  This parameter can also be <tt class="const">NULL</tt> if you're using
the <tt class="const">AI_PASSIVE</tt> flag (see below.)</p>

<p>The <i><tt class="var">servname</tt></i> parameter is basically the port number.
It can be a port number (passed as a string, like "80"), or it can be a
service name, like "http" or "tftp" or "smtp" or "pop", etc.  Well-known
service names can be found in the <a href="http://www.iana.org/assignments/port-numbers" target="_blank">IANA Port
List</a> or in your <i><tt class="var">/etc/services</tt></i> file.</p>

<p>Lastly, for input parameters, we have <i><tt class="var">hints</tt></i>.  This is
really where you get to define what the <b><tt class="func">getaddrinfo()</tt></b>
function is going to do.  Zero the whole structure before use with
<b><tt class="func">memset()</tt></b>.  Let's take a look at the fields you need to set
up before use.</p>

<p>The <i><tt class="var">ai_flags</tt></i> can be set to a variety of things, but
here are a couple important ones.  (Multiple flags can be specified by
bitwise-ORing them together with the <tt class="operator">|</tt> operator.)
Check your man page for the complete list of flags.</p>

<p><tt class="const">AI_CANONNAME</tt> causes the <i><tt class="var">ai_canonname</tt></i>
of the result to the filled out with the host's canonical (real) name.
<tt class="const">AI_PASSIVE</tt> causes the result's IP address to
be filled out with <tt class="const">INADDR_ANY</tt> (IPv4)or
<i><tt class="var">in6addr_any</tt></i> (IPv6); this causes a subsequent call to
<b><tt class="func">bind()</tt></b> to auto-fill the IP address of the <nobr><tt class="type">struct
sockaddr</tt></nobr> with the address of the current host.  That's excellent
for setting up a server when you don't want to hardcode the address.</p>

<p>If you do use the <tt class="const">AI_PASSIVE</tt>, flag, then you can pass
<tt class="const">NULL</tt> in the <i><tt class="var">nodename</tt></i> (since
<b><tt class="func">bind()</tt></b> will fill it in for you later.)</p>

<p>Continuing on with the input paramters, you'll likely want to set
<i><tt class="var">ai_family</tt></i> to <tt class="const">AF_UNSPEC</tt> which tells
<b><tt class="func">getaddrinfo()</tt></b> to look for both IPv4 and IPv6 addresses.
You can also restrict yourself to one or the other with
<tt class="const">AF_INET</tt> or <tt class="const">AF_INET6</tt>.</p>

<p>Next, the <i><tt class="var">socktype</tt></i> field should be set to
<tt class="const">SOCK_STREAM</tt> or <tt class="const">SOCK_DGRAM</tt>, depending on
which type of socket you want.</p>

<p>Finally, just leave <i><tt class="var">ai_protocol</tt></i> at <tt class="const">0</tt> to
automatically choose your protocol type.</p>

<p>Now, after you get all that stuff in there, you can
<i>finally</i> make the call to <b><tt class="func">getaddrinfo()</tt></b>!</p>

<p>Of course, this is where the fun begins.  The <i><tt class="var">res</tt></i> will
now point to a linked list of <nobr><tt class="type">struct addrinfo</tt></nobr>s, and you can
go through this list to get all the addresses that match what you passed
in with the hints.</p>

<p>Now, it's possible to get some addresses that don't work for one
reason or another, so what the Linux man page does is loops through the
list doing a call to <b><tt class="func">socket()</tt></b> and <b><tt class="func">connect()</tt></b>
(or <b><tt class="func">bind()</tt></b> if you're setting up a server with the
<tt class="const">AI_PASSIVE</tt> flag) until it succeeds.</p>

<p>Finally, when you're done with the linked list, you need to call
<b><tt class="func">freeaddrinfo()</tt></b> to free up the memory (or it will be leaked,
and Some People will get upset.)</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or nonzero on error.  If it returns nonzero,
you can use the function <b><tt class="func">gai_strerror()</tt></b> to get a printable
version of the error code in the return value.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">// code for a client connecting to a server
// namely a stream socket to www.example.com on port 80 (http)
// either IPv4 or IPv6

int sockfd;  
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // use AF_INET6 to force IPv6
hints.ai_socktype = SOCK_STREAM;

if ((rv = getaddrinfo("www.example.com", "http", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    exit(1);
}

// loop through all the results and connect to the first we can
for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
    if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
            p-&gt;ai_protocol)) == -1) {
        perror("socket");
        continue;
    }

    if (connect(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        perror("connect");
        close(sockfd);
        continue;
    }

    break; // if we get here, we must have connected successfully
}

if (p == NULL) {
    // looped off the end of the list with no connection
    fprintf(stderr, "failed to connect\n");
    exit(2);
}

freeaddrinfo(servinfo); // all done with this structure</pre>


<p></p>
<pre class="code">// code for a server waiting for connections
// namely a stream socket on port 3490, on this host's IP
// either IPv4 or IPv6.

int sockfd;  
struct addrinfo hints, *servinfo, *p;
int rv;

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC; // use AF_INET6 to force IPv6
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE; // use my IP address

if ((rv = getaddrinfo(NULL, "3490", &amp;hints, &amp;servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    exit(1);
}

// loop through all the results and bind to the first we can
for(p = servinfo; p != NULL; p = p-&gt;ai_next) {
    if ((sockfd = socket(p-&gt;ai_family, p-&gt;ai_socktype,
            p-&gt;ai_protocol)) == -1) {
        perror("socket");
        continue;
    }

    if (bind(sockfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == -1) {
        close(sockfd);
        perror("bind");
        continue;
    }

    break; // if we get here, we must have connected successfully
}

if (p == NULL) {
    // looped off the end of the list with no successful bind
    fprintf(stderr, "failed to bind socket\n");
    exit(2);
}

freeaddrinfo(servinfo); // all done with this structure</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b></a>,
<a href="#getnameinfoman"><b><tt class="func">getnameinfo()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.6. <a name="gethostnameman"><b><tt class="titlefunc">gethostname()</tt></b></a></h2><p></p>

<p>Returns the name of the system</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/unistd.h&gt;

int gethostname(char *<i><tt class="var em1">name</tt></i>, size_t <i><tt class="var em1">len</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-239"></a>Your system has a name.  They all do.  This
is a slightly more Unixy thing than the rest of the networky stuff we've
been talking about, but it still has its uses.</p>

<p>For instance, you can get your host name, and then call <a name="indexId434909-240"></a><b><tt class="func">gethostbyname()</tt></b> to find out your
<a name="indexId434909-241"></a>IP address.</p>

<p>The parameter <i><tt class="var">name</tt></i> should point to a buffer that will hold
the host name, and <i><tt class="var">len</tt></i> is the size of that buffer in bytes.
<b><tt class="func">gethostname()</tt></b> won't overwrite the end of the buffer (it
might return an error, or it might just stop writing), and it will
<tt class="const">NUL</tt>-terminate the string if there's room for it in the
buffer.</p>


<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">char hostname[128];

gethostname(hostname, sizeof hostname);
printf("My hostname: %s\n", hostname);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.7. <a name="gethostbynameman"><b><tt class="titlefunc">gethostbyname()</tt></b>, <b><tt class="titlefunc">gethostbyaddr()</tt></b></a></h2><p></p>

<p>Get an IP address for a hostname, or vice-versa</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

struct hostent *gethostbyname(const char *<i><tt class="var em1">name</tt></i>); // DEPRECATED!
struct hostent *gethostbyaddr(const char *<i><tt class="var em1">addr</tt></i>, int <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">type</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-242"></a><a name="indexId434909-243"></a><i>PLEASE
NOTE: these two functions are superseded by <b><tt class="func">getaddrinfo()</tt></b>
and <b><tt class="func">getnameinfo()</tt></b>!</i>  In particular,
<b><tt class="func">gethostbyname()</tt></b> doesn't work well with IPv6.</p>

<p>These functions map back and forth between host names and IP
addresses.  For instance, if you have "www.example.com", you can use
<b><tt class="func">gethostbyname()</tt></b> to get its IP address and store it in a
<nobr><tt class="type">struct in_addr</tt></nobr>.</p>

<p>Conversely, if you have a <nobr><tt class="type">struct in_addr</tt></nobr> or a
<nobr><tt class="type">struct in6_addr</tt></nobr>, you can use <b><tt class="func">gethostbyaddr()</tt></b>
to get the hostname back.  <b><tt class="func">gethostbyaddr()</tt></b> <i>is</i>
IPv6 compatible, but you should use the newer shinier
<b><tt class="func">getnameinfo()</tt></b> instead.</p>

<p>(If you have a string containing an IP address in dots-and-numbers
format that you want to look up the hostname of, you'd be better off
using <b><tt class="func">getaddrinfo()</tt></b> with the <tt class="const">AI_CANONNAME</tt>
flag.)</p>

<p><b><tt class="func">gethostbyname()</tt></b> takes a string like "www.yahoo.com", and
returns a <nobr><tt class="type">struct hostent</tt></nobr> which contains tons of
information, including the <a name="indexId434909-244"></a>IP address.  (Other
information is the official host name, a list of aliases, the address
type, the length of the addresses, and the list of addresses‚Äîit's
a general-purpose structure that's pretty easy to use for our specific
purposes once you see how.)</p>

<p><b><tt class="func">gethostbyaddr()</tt></b> takes a <nobr><tt class="type">struct in_addr</tt></nobr> or
<nobr><tt class="type">struct in6_addr</tt></nobr> and brings you up a corresponding host name
(if there is one), so it's sort of the reverse of
<b><tt class="func">gethostbyname()</tt></b>.  As for parameters, even though
<i><tt class="var">addr</tt></i> is a <nobr><tt class="type">char*</tt></nobr>, you actually want to pass in a
pointer to a <nobr><tt class="type">struct in_addr</tt></nobr>.  <i><tt class="var">len</tt></i> should be
<tt class="tt">sizeof(struct in_addr)</tt>, and <i><tt class="var">type</tt></i> should be
<tt class="const">AF_INET</tt>.</p>

<p>So what is this <a name="indexId434909-245"></a><nobr><tt class="type">struct hostent</tt></nobr>
that gets returned?  It has a number of fields that contain information
about the host in question.</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="30%%"><p><i><tt class="var">char *h_name</tt></i></p></td>

<td valign="top" align="left" width="68%%"><p>The real canonical host name.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">char **h_aliases</tt></i></p></td>

<td valign="top" align="left"><p>A list of aliases that can be accessed with
arrays‚Äîthe last element is <tt class="const">NULL</tt></p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">int h_addrtype</tt></i></p></td>

<td valign="top" align="left"><p>The result's address type, which really should be
<tt class="const">AF_INET</tt> for our purposes.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">int length</tt></i></p></td>

<td valign="top" align="left"><p>The length of the addresses in bytes, which is 4 for
IP (version 4) addresses.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">char **h_addr_list</tt></i></p></td>

<td valign="top" align="left"><p>A list of IP addresses for this host.  Although this
is a <nobr><tt class="type">char**</tt></nobr>, it's really an array of <nobr><tt class="type">struct
in_addr*</tt></nobr>s in disguise.  The last array element is
<tt class="const">NULL</tt>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">h_addr</tt></i></p></td>

<td valign="top" align="left"><p>A commonly defined alias for
<i><tt class="var">h_addr_list[0]</tt></i>.  If you just want any old IP address for this
host (yeah, they can have more than one) just use this field.</p></td>
</tr>


</tbody></table></center>
<p></p>



<h3 class="sect2title">Return Value</h3>

<p>Returns a pointer to a resultant <nobr><tt class="type">struct hostent</tt></nobr> on
success, or <tt class="const">NULL</tt> on error.</p>

<p>Instead of the normal <b><tt class="func">perror()</tt></b> and all that stuff you'd
normally use for error reporting, these functions have parallel results
in the variable <i><tt class="var">h_errno</tt></i>, which can be printed using the
functions <a name="indexId434909-246"></a><b><tt class="func">herror()</tt></b> or <a name="indexId434909-247"></a><b><tt class="func">hstrerror()</tt></b>.  These work just like the
classic <i><tt class="var">errno</tt></i>, <b><tt class="func">perror()</tt></b>, and
<b><tt class="func">strerror()</tt></b> functions you're used to.</p>



<h3 class="sect2title">Example</h3>

<pre class="code">// THIS IS A DEPRECATED METHOD OF GETTING HOST NAMES
// use getaddrinfo() instead!

#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;netdb.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char *argv[])
{
    int i;
    struct hostent *he;
    struct in_addr **addr_list;

    if (argc != 2) {
        fprintf(stderr,"usage: ghbn hostname\n");
        return 1;
    }

    if ((he = gethostbyname(argv[1])) == NULL) {  // get the host info
        herror("gethostbyname");
        return 2;
    }

    // print information about this host:
    printf("Official name is: %s\n", he-&gt;h_name);
    printf("    IP addresses: ");
    addr_list = (struct in_addr **)he-&gt;h_addr_list;
    for(i = 0; addr_list[i] != NULL; i++) {
        printf("%s ", inet_ntoa(*addr_list[i]));
    }
    printf("\n");

    return 0;
}</pre>


<pre class="code">// THIS HAS BEEN SUPERCEDED
// use getnameinfo() instead!

struct hostent *he;
struct in_addr ipv4addr;
struct in6_addr ipv6addr;

inet_pton(AF_INET, "192.0.2.34", &amp;ipv4addr);
he = gethostbyaddr(&amp;ipv4addr, sizeof ipv4addr, AF_INET);
printf("Host name: %s\n", he-&gt;h_name);

inet_pton(AF_INET6, "2001:db8:63b3:1::beef", &amp;ipv6addr);
he = gethostbyaddr(&amp;ipv6addr, sizeof ipv6addr, AF_INET6);
printf("Host name: %s\n", he-&gt;h_name);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a>,
<a href="#getnameinfoman"><b><tt class="func">getnameinfo()</tt></b></a>,
<a href="#gethostnameman"><b><tt class="func">gethostname()</tt></b></a>,
<a href="#errnoman"><i><tt class="var">errno</tt></i></a>,
<a href="#perrorman"><b><tt class="func">perror()</tt></b></a>,
<a href="#perrorman"><b><tt class="func">strerror()</tt></b></a>,
<a href="#sockaddr_inman"><nobr><tt class="type">struct in_addr</tt></nobr></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.8. <a name="getnameinfoman"><b><tt class="titlefunc">getnameinfo()</tt></b></a></h2><p></p>

<p>Look up the host name and service name information for a given
<nobr><tt class="type">struct sockaddr</tt></nobr>.</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;

int getnameinfo(const struct sockaddr *sa, socklen_t salen,
                char *host, size_t hostlen,
                char *serv, size_t servlen, int flags);</pre>



<h3 class="sect2title">Description</h3>

<p>This function is the opposite of <b><tt class="func">getaddrinfo()</tt></b>, that is,
this function takes an already loaded <nobr><tt class="type">struct sockaddr</tt></nobr> and
does a name and service name lookup on it.  It replaces the old
<b><tt class="func">gethostbyaddr()</tt></b> and <b><tt class="func">getservbyport()</tt></b>
functions.</p>

<p>You have to pass in a pointer to a <nobr><tt class="type">struct sockaddr</tt></nobr>
(which in actuality is probably a <nobr><tt class="type">struct sockaddr_in</tt></nobr> or
<nobr><tt class="type">struct sockaddr_in6</tt></nobr> that you've cast) in the
<i><tt class="var">sa</tt></i> parameter, and the length of that <nobr><tt class="type">struct</tt></nobr>
in the <i><tt class="var">salen</tt></i>.</p>

<p>The resultant host name and service name will be written to the area
pointed to by the <i><tt class="var">host</tt></i> and <i><tt class="var">serv</tt></i>
parameters.  Of course, you have to specify the max lengths of these
buffers in <i><tt class="var">hostlen</tt></i> and <i><tt class="var">servlen</tt></i>.</p>

<p>Finally, there are several flags you can pass, but here a a couple
good ones.  <tt class="const">NI_NOFQDN</tt> will cause the <i><tt class="var">host</tt></i>
to only contain the host name, not the whole domain name.
<tt class="const">NI_NAMEREQD</tt> will cause the function to fail if the name
cannot be found with a DNS lookup (if you don't specify this flag and
the name can't be found, <b><tt class="func">getnameinfo()</tt></b> will put a string
version of the IP address in <i><tt class="var">host</tt></i> instead.)</p>

<p>As always, check your local man pages for the full scoop.</p>


<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or non-zero on error.  If the return value
is non-zero, it can be passed to <b><tt class="func">gai_strerror()</tt></b> to get a
human-readable string.  See <b><tt class="func">getaddrinfo</tt></b> for more
information.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">struct sockaddr_in6 sa; // could be IPv4 if you want
char host[1024];
char service[20];

// pretend sa is full of good information about the host and port...

getnameinfo(&amp;sa, sizeof sa, host, sizeof host, service, sizeof service, 0);

printf("   host: %s\n", host);    // e.g. "www.example.com"
printf("service: %s\n", service); // e.g. "http"
</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a>,
<a href="#gethostbynameman"><b><tt class="func">gethostbyaddr()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.9. <a name="getpeernameman"><b><tt class="titlefunc">getpeername()</tt></b></a></h2><p></p>

<p>Return address info about the remote side of the connection</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/socket.h&gt;

int getpeername(int <i><tt class="var em1">s</tt></i>, struct sockaddr *<i><tt class="var em1">addr</tt></i>, socklen_t *<i><tt class="var em1">len</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-248"></a>Once you have either <b><tt class="func">accept()</tt></b>ed
a remote connection, or <b><tt class="func">connect()</tt></b>ed to a server, you now
have what is known as a <i>peer</i>.  Your peer is simply the
computer you're connected to, identified by an <a name="indexId434909-249"></a>IP
address and a <a name="indexId434909-250"></a>port.
So...</p>

<p><b><tt class="func">getpeername()</tt></b> simply returns a <nobr><tt class="type">struct
sockaddr_in</tt></nobr> filled with information about the machine you're
connected to.</p>

<p>Why is it called a "name"?  Well, there are a lot of different kinds
of sockets, not just Internet Sockets like we're using in this guide,
and so "name" was a nice generic term that covered all cases.  In our
case, though, the peer's "name" is it's IP address and port.</p>

<p>Although the function returns the size of the resultant address in
<i><tt class="var">len</tt></i>, you must preload <i><tt class="var">len</tt></i> with the size of
<i><tt class="var">addr</tt></i>.</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">// assume s is a connected socket

socklen_t len;
struct sockaddr_storage addr;
char ipstr[INET6_ADDRSTRLEN];
int port;

len = sizeof addr;
getpeername(s, (struct sockaddr*)&amp;addr, &amp;len);

// deal with both IPv4 and IPv6:
if (addr.ss_family == AF_INET) {
    struct sockaddr_in *s = (struct sockaddr_in *)&amp;addr;
    port = ntohs(s-&gt;sin_port);
    inet_ntop(AF_INET, &amp;s-&gt;sin_addr, ipstr, sizeof ipstr);
} else { // AF_INET6
    struct sockaddr_in6 *s = (struct sockaddr_in6 *)&amp;addr;
    port = ntohs(s-&gt;sin6_port);
    inet_ntop(AF_INET6, &amp;s-&gt;sin6_addr, ipstr, sizeof ipstr);
}

printf("Peer IP address: %s\n", ipstr);
printf("Peer port      : %d\n", port);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#gethostnameman"><b><tt class="func">gethostname()</tt></b></a>,
<a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b></a>,
<a href="#gethostbynameman"><b><tt class="func">gethostbyaddr()</tt></b></a></p>


 



<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.10. <a name="errnoman"><i><tt class="titlevar">errno</tt></i></a></h2><p></p>

<p>Holds the error code for the last system call</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;errno.h&gt;

int <i><tt class="var em1">errno</tt></i>;</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-251"></a>This is the variable that holds error information
for a lot of system calls.  If you'll recall, things like
<b><tt class="func">socket()</tt></b> and <b><tt class="func">listen()</tt></b> return <tt class="const">-1</tt>
on error, and they set the exact value of <i><tt class="var">errno</tt></i> to let you
know specifically which error occurred.</p>

<p>The header file <i><tt class="var">errno.h</tt></i> lists a bunch of constant
symbolic names for errors, such as <tt class="const">EADDRINUSE</tt>,
<tt class="const">EPIPE</tt>, <tt class="const">ECONNREFUSED</tt>, etc.  Your local man
pages will tell you what codes can be returned as an error, and you can
use these at run time to handle different errors in different ways.</p>

<p>Or, more commonly, you can call <a name="indexId434909-252"></a><b><tt class="func">perror()</tt></b> or <a name="indexId434909-253"></a><b><tt class="func">strerror()</tt></b> to get a human-readable
version of the error.</p>

<p>One thing to note, for you multithreading enthusiasts, is that on
most systems <i><tt class="var">errno</tt></i> is defined in a threadsafe manner.  (That
is, it's not actually a global variable, but it behaves just like a
global variable would in a single-threaded environment.)</p>



<h3 class="sect2title">Return Value</h3>

<p>The value of the variable is the latest error to have transpired, which
might be the code for "success" if the last action succeeded.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">s = socket(PF_INET, SOCK_STREAM, 0);
if (s == -1) {
    perror("socket"); // or use strerror()
}

tryagain:
if (select(n, &amp;readfds, NULL, NULL) == -1) {
    // an error has occurred!!

    // if we were only interrupted, just restart the select() call:
    if (errno == EINTR) goto tryagain;  // AAAA!  goto!!!

    // otherwise it's a more serious error:
    perror("select");
    exit(1);
}</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#perrorman"><b><tt class="func">perror()</tt></b></a>,
<a href="#perrorman"><b><tt class="func">strerror()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.11. <a name="fcntlman"><b><tt class="titlefunc">fcntl()</tt></b></a></h2><p></p>

<p>Control socket descriptors</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/unistd.h&gt;
#include &lt;sys/fcntl.h&gt;

int fcntl(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">cmd</tt></i>, long <i><tt class="var em1">arg</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-254"></a>This function is typically used to do file locking
and other file-oriented stuff, but it also has a couple socket-related
functions that you might see or use from time to time.</p>

<p>Parameter <i><tt class="var">s</tt></i> is the socket descriptor you wish to operate
on, <i><tt class="var">cmd</tt></i> should be set to <a name="indexId434909-255"></a><tt class="const">F_SETFL</tt>, and <i><tt class="var">arg</tt></i> can be one of
the following commands.  (Like I said, there's more to
<b><tt class="func">fcntl()</tt></b> than I'm letting on here, but I'm trying to stay
socket-oriented.)</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="20%%"><p><a name="indexId434909-256"></a><tt class="const">O_NONBLOCK</tt></p></td>

<td valign="top" align="left" width="73%%"><p>Set the socket to be non-blocking.  See the section on
<a href="#blocking">blocking</a> for more details.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-257"></a><tt class="const">O_ASYNC</tt></p></td>

<td valign="top" align="left"><p>Set the socket to do asynchronous I/O.  When data is
ready to be <b><tt class="func">recv()</tt></b>'d on the socket, the signal <a name="indexId434909-258"></a><tt class="const">SIGIO</tt> will be raised.  This is rare to see,
and beyond the scope of the guide.  And I think it's only available on
certain systems.</p></td>
</tr>


</tbody></table></center>
<p></p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>

<p>Different uses of the <b><tt class="func">fcntl()</tt></b> system call actually have
different return values, but I haven't covered them here because they're
not socket-related.  See your local <b><tt class="func">fcntl()</tt></b> man page for
more information.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int s = socket(PF_INET, SOCK_STREAM, 0);

fcntl(s, F_SETFL, O_NONBLOCK);  // set to non-blocking
fcntl(s, F_SETFL, O_ASYNC);     // set to asynchronous I/O</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#blocking">Blocking</a>,
<a href="#sendman"><b><tt class="func">send()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.12. <a name="htonsman"><b><tt class="titlefunc">htons()</tt></b>, <b><tt class="titlefunc">htonl()</tt></b>,
<b><tt class="titlefunc">ntohs()</tt></b>, <b><tt class="titlefunc">ntohl()</tt></b></a></h2><p></p>


<p>Convert multi-byte integer types from host byte order to
network byte order</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;netinet/in.h&gt;

uint32_t htonl(uint32_t <i><tt class="var em1">hostlong</tt></i>);
uint16_t htons(uint16_t <i><tt class="var em1">hostshort</tt></i>);
uint32_t ntohl(uint32_t <i><tt class="var em1">netlong</tt></i>);
uint16_t ntohs(uint16_t <i><tt class="var em1">netshort</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-259"></a><a name="indexId434909-260"></a><a name="indexId434909-261"></a><a name="indexId434909-262"></a>Just to make you really unhappy, different computers use
different byte orderings internally for their multibyte integers (i.e.
any integer that's larger than a <nobr><tt class="type">char</tt></nobr>.)  The upshot of
this is that if you <b><tt class="func">send()</tt></b> a two-byte <nobr><tt class="type">short
int</tt></nobr> from an Intel box to a Mac (before they became Intel boxes,
too, I mean), what one computer thinks is the number <tt class="const">1</tt>,
the other will think is the number <tt class="const">256</tt>, and
vice-versa.</p>

<p><a name="indexId434909-263"></a>The way to get around this problem is for
everyone to put aside their differences and agree that Motorola and IBM
had it right, and Intel did it the weird way, and so we all convert our
byte orderings to "big-endian" before sending them out.  Since Intel is
a "little-endian" machine, it's far more politically correct to call our
preferred byte ordering "Network Byte Order".  So these functions
convert from your native byte order to network byte order and back
again.</p>

<p>(This means on Intel these functions swap all the bytes around, and
on PowerPC they do nothing because the bytes are already in Network
Byte Order.  But you should always use them in your code anyway, since
someone might want to build it on an Intel machine and still have things
work properly.)</p>

<p>Note that the types involved are 32-bit (4 byte, probably
<nobr><tt class="type">int</tt></nobr>) and 16-bit (2 byte, very likely <nobr><tt class="type">short</tt></nobr>)
numbers.  64-bit machines might have a <b><tt class="func">htonll()</tt></b> for 64-bit
<nobr><tt class="type">int</tt></nobr>s, but I've not seen it.  You'll just have to write your
own.</p>

<p>Anyway, the way these functions work is that you first decide if
you're converting <i>from</i> host (your machine's) byte order or
from network byte order.  If "host", the the first letter of the
function you're going to call is "h".  Otherwise it's "n" for "network".
The middle of the function name is always "to" because you're converting
from one "to" another, and the penultimate letter shows what you're converting
<i>to</i>.  The last letter is the size of the data, "s" for short,
or "l" for long.  Thus:</p>

<p>
</p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="20%%"><p><a name="indexId434909-264"></a><b><tt class="func">htons()</tt></b></p></td>
<td valign="top" align="left" width="78%%"><p><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">s</tt></b>hort</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-265"></a><b><tt class="func">htonl()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">h</tt></b>ost <b><tt class="func">to</tt></b> <b><tt class="func">n</tt></b>etwork <b><tt class="func">l</tt></b>ong</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-266"></a><b><tt class="func">ntohs()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">s</tt></b>hort</p></td>
</tr>

<tr><td valign="top" align="left"><p><a name="indexId434909-267"></a><b><tt class="func">ntohl()</tt></b></p></td>
<td valign="top" align="left"><p><b><tt class="func">n</tt></b>etwork <b><tt class="func">to</tt></b> <b><tt class="func">h</tt></b>ost <b><tt class="func">l</tt></b>ong</p></td>
</tr>

</tbody></table></center>

<p></p>



<h3 class="sect2title">Return Value</h3>

<p>Each function returns the converted value.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">uint32_t some_long = 10;
uint16_t some_short = 20;

uint32_t network_byte_order;

// convert and send
network_byte_order = htonl(some_long);
send(s, &amp;network_byte_order, sizeof(uint32_t), 0);

some_short == ntohs(htons(some_short)); // this expression is true</pre>








<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.13. <a name="inet_ntoaman"><b><tt class="titlefunc">inet_ntoa()</tt></b>, <b><tt class="titlefunc">inet_aton()</tt></b>,
<b><tt class="titlefunc">inet_addr</tt></b></a></h2><p></p>

<p>Convert IP addresses from a dots-and-number string to a
<nobr><tt class="type">struct in_addr</tt></nobr> and back</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

// ALL THESE ARE DEPRECATED!  Use inet_pton()  or inet_ntop() instead!!

char *inet_ntoa(struct in_addr <i><tt class="var em1">in</tt></i>);
int inet_aton(const char *<i><tt class="var em1">cp</tt></i>, struct in_addr *<i><tt class="var em1">inp</tt></i>);
in_addr_t inet_addr(const char *<i><tt class="var em1">cp</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><i>These functions are deprecated because they don't handle IPv6!
Use <b><tt class="func">inet_ntop()</tt></b> or <b><tt class="func">inet_pton()</tt></b> instead!  They
are included here because they can still be found in the wild.</i></p>

<p><a name="indexId434909-268"></a><a name="indexId434909-269"></a><a name="indexId434909-270"></a>
All of these functions convert from a <nobr><tt class="type">struct in_addr</tt></nobr> (part
of your <nobr><tt class="type">struct sockaddr_in</tt></nobr>, most likely) to a string in
dots-and-numbers format (e.g. "192.168.5.10") and vice-versa.  If you
have an IP address passed on the command line or something, this is the
easiest way to get a <nobr><tt class="type">struct in_addr</tt></nobr> to
<b><tt class="func">connect()</tt></b> to, or whatever.  If you need more power, try
some of the DNS functions like <b><tt class="func">gethostbyname()</tt></b> or attempt a
<i>coup d'√âtat</i> in your local country.</p>

<p>The function <b><tt class="func">inet_ntoa()</tt></b> converts a network address in a
<nobr><tt class="type">struct in_addr</tt></nobr> to a dots-and-numbers format string.  The
"n" in "ntoa" stands for network, and the "a" stands for ASCII for
historical reasons (so it's "Network To ASCII"‚Äîthe "toa" suffix
has an analogous friend in the C library called <b><tt class="func">atoi()</tt></b>
which converts an ASCII string to an integer.)</p>

<p>The function <b><tt class="func">inet_aton()</tt></b> is the opposite, converting
from a dots-and-numbers string into a <nobr><tt class="type">in_addr_t</tt></nobr> (which is
the type of the field <nobr><tt class="type">s_addr</tt></nobr> in your <nobr><tt class="type">struct
in_addr</tt></nobr>.)</p>

<p>Finally, the function <b><tt class="func">inet_addr()</tt></b> is an older function
that does basically the same thing as <b><tt class="func">inet_aton()</tt></b>.  It's
theoretically deprecated, but you'll see it a lot and the police won't
come get you if you use it.</p>



<h3 class="sect2title">Return Value</h3>

<p><b><tt class="func">inet_aton()</tt></b> returns non-zero if the address is a valid
one, and it returns zero if the address is invalid.</p>

<p><b><tt class="func">inet_ntoa()</tt></b> returns the dots-and-numbers string in a
static buffer that is overwritten with each call to the function.</p>

<p><b><tt class="func">inet_addr()</tt></b> returns the address as an
<nobr><tt class="type">in_addr_t</tt></nobr>, or <tt class="const">-1</tt> if there's an error.  (That
is the same result as if you tried to convert the string <a name="indexId434909-271"></a>"255.255.255.255", which is a valid IP address.
This is why <b><tt class="func">inet_aton()</tt></b> is better.)</p>



<h3 class="sect2title">Example</h3>

<pre class="code">struct sockaddr_in antelope;
char *some_addr;

inet_aton("10.0.0.1", &amp;antelope.sin_addr); // store IP in antelope

some_addr = inet_ntoa(antelope.sin_addr); // return the IP
printf("%s\n", some_addr); // prints "10.0.0.1"

// and this call is the same as the inet_aton() call, above:
antelope.sin_addr.s_addr = inet_addr("10.0.0.1");</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#inet_ntopman"><b><tt class="func">inet_ntop()</tt></b></a>,
<a href="#inet_ntopman"><b><tt class="func">inet_pton()</tt></b></a>,
<a href="#gethostbynameman"><b><tt class="func">gethostbyname()</tt></b></a>,
<a href="#gethostbynameman"><b><tt class="func">gethostbyaddr()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.14. <a name="inet_ntopman"><b><tt class="titlefunc">inet_ntop()</tt></b>, <b><tt class="titlefunc">inet_pton()</tt></b></a></h2><p></p>

<p>Convert IP addresses to human-readable form and
back.</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;arpa/inet.h&gt;

const char *inet_ntop(int af, const void *src,
                      char *dst, socklen_t size);

int inet_pton(int af, const char *src, void *dst);</pre>




<h3 class="sect2title">Description</h3>

<p>These functions are for dealing with human-readable IP addresses and
converting them to their binary representation for use with various
functions and system calls.  The "n" stands for "network", and "p" for
"presentation".  Or "text presentation".  But you can think of it as
"printable".  "ntop" is "network to printable".  See?</p>

<p>Sometimes you don't want to look at a pile of binary numbers when
looking at an IP address.  You want it in a nice printable form, like
<tt class="tt">192.0.2.180</tt>, or <tt class="tt">2001:db8:8714:3a90::12</tt>.  In that case,
<b><tt class="func">inet_ntop()</tt></b> is for you.</p>

<p><b><tt class="func">inet_ntop()</tt></b> takes the address family in the
<i><tt class="var">af</tt></i> parameter (either <tt class="const">AF_INET</tt> or
<tt class="const">AF_INET6</tt>).  The <i><tt class="var">src</tt></i> parameter should be a
pointer to either a <nobr><tt class="type">struct in_addr</tt></nobr> or <nobr><tt class="type">struct
in6_addr</tt></nobr> containing the address you wish to convert to a string.
Finally <i><tt class="var">dst</tt></i> and <i><tt class="var">size</tt></i> are the pointer to
the destination string and the maximum length of that string.</p>

<p>What should the maximum length of the <i><tt class="var">dst</tt></i> string be?
What is the maximum length for IPv4 and IPv6 addresses?  Fortunately
there are a couple of macros to help you out.  The maximum lengths are:
<tt class="const">INET_ADDRSTRLEN</tt> and <tt class="const">INET6_ADDRSTRLEN</tt>.</p>

<p>Other times, you might have a string containing an IP address in
readable form, and you want to pack it into a <nobr><tt class="type">struct
sockaddr_in</tt></nobr> or a <nobr><tt class="type">struct sockaddr_in6</tt></nobr>.  In that case,
the opposite funcion <b><tt class="func">inet_pton()</tt></b> is what you're after.</p>

<p><b><tt class="func">inet_pton()</tt></b> also takes an address family (either
<tt class="const">AF_INET</tt> or <tt class="const">AF_INET6</tt>) in the
<i><tt class="var">af</tt></i> parameter.  The <i><tt class="var">src</tt></i> parameter is a
pointer to a string containing the IP address in printable form.  Lastly
the <i><tt class="var">dst</tt></i> parameter points to where the result should be
stored, which is probably a <nobr><tt class="type">struct in_addr</tt></nobr> or <nobr><tt class="type">struct
in6_addr</tt></nobr>.</p>

<p>These functions don't do DNS lookups‚Äîyou'll need
<b><tt class="func">getaddrinfo()</tt></b> for that.</p>



<h3 class="sect2title">Return Value</h3>

<p><b><tt class="func">inet_ntop()</tt></b> returns the <i><tt class="var">dst</tt></i> parameter on
success, or <tt class="const">NULL</tt> on failure (and <i><tt class="var">errno</tt></i> is
set).</p>

<p><b><tt class="func">inet_pton()</tt></b> returns <tt class="const">1</tt> on success.  It
returns <tt class="const">-1</tt> if there was an error (<i><tt class="var">errno</tt></i> is
set), or <tt class="const">0</tt> if the input isn't a valid IP address.</p>



<h3 class="sect2title">Example</h3>

<pre class="code">// IPv4 demo of inet_ntop() and inet_pton()

struct sockaddr_in sa;
char str[INET_ADDRSTRLEN];

// store this IP address in sa:
inet_pton(AF_INET, "192.0.2.33", &amp;(sa.sin_addr));

// now get it back and print it
inet_ntop(AF_INET, &amp;(sa.sin_addr), str, INET_ADDRSTRLEN);

printf("%s\n", str); // prints "192.0.2.33"</pre>


<pre class="code">// IPv6 demo of inet_ntop() and inet_pton()
// (basically the same except with a bunch of 6s thrown around)

struct sockaddr_in6 sa;
char str[INET6_ADDRSTRLEN];

// store this IP address in sa:
inet_pton(AF_INET6, "2001:db8:8714:3a90::12", &amp;(sa.sin6_addr));

// now get it back and print it
inet_ntop(AF_INET6, &amp;(sa.sin6_addr), str, INET6_ADDRSTRLEN);

printf("%s\n", str); // prints "2001:db8:8714:3a90::12"</pre>

<pre class="code">// Helper function you can use:

//Convert a struct sockaddr address to a string, IPv4 and IPv6:

char *get_ip_str(const struct sockaddr *sa, char *s, size_t maxlen)
{
    switch(sa-&gt;sa_family) {
        case AF_INET:
            inet_ntop(AF_INET, &amp;(((struct sockaddr_in *)sa)-&gt;sin_addr),
                    s, maxlen);
            break;

        case AF_INET6:
            inet_ntop(AF_INET6, &amp;(((struct sockaddr_in6 *)sa)-&gt;sin6_addr),
                    s, maxlen);
            break;

        default:
            strncpy(s, "Unknown AF", maxlen);
            return NULL;
    }

    return s;
}</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a></p>







<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.15. <a name="listenman"><b><tt class="titlefunc">listen()</tt></b></a></h2><p></p>

<p>Tell a socket to listen for incoming connections</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/socket.h&gt;

int listen(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">backlog</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-272"></a>You can take your socket descriptor (made with
the <b><tt class="func">socket()</tt></b> system call) and tell it to listen for
incoming connections.  This is what differentiates the servers from the
clients, guys.</p>

<p>The <i><tt class="var">backlog</tt></i> parameter can mean a couple different things
depending on the system you on, but loosely it is how many pending
connections you can have before the kernel starts rejecting new ones.
So as the new connections come in, you should be quick to
<b><tt class="func">accept()</tt></b> them so that the backlog doesn't fill.  Try
setting it to 10 or so, and if your clients start getting "Connection
refused" under heavy load, set it higher.</p>

<p>Before calling <b><tt class="func">listen()</tt></b>, your server should call
<b><tt class="func">bind()</tt></b> to attach itself to a specific port number.  That
port number (on the server's IP address) will be the one that clients
connect to.</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, "3490", &amp;hints, &amp;res);

// make a socket:

sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);

// bind it to the port we passed in to getaddrinfo():

bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

listen(sockfd, 10); // set s up to be a server (listening) socket

// then have an accept() loop down here somewhere</pre>




<h3 class="sect2title">See Also</h3>

<p><a href="#acceptman"><b><tt class="func">accept()</tt></b></a>,
<a href="#bindman"><b><tt class="func">bind()</tt></b></a>,
<a href="#socketman"><b><tt class="func">socket()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.16. <a name="perrorman"><b><tt class="titlefunc">perror()</tt></b>, <b><tt class="titlefunc">strerror()</tt></b></a></h2><p></p>

<p>Print an error as a human-readable string</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;   // for strerror()

void perror(const char *<i><tt class="var em1">s</tt></i>);
char *strerror(int <i><tt class="var em1">errnum</tt></i>);</pre>



<h3 class="sect2title">Description</h3>


<p><a name="indexId434909-273"></a><a name="indexId434909-274"></a>Since so many functions
return <tt class="const">-1</tt> on error and set the value of the variable <a name="indexId434909-275"></a><i><tt class="var">errno</tt></i> to be some number, it would sure be nice
if you could easily print that in a form that made sense to you.</p>

<p>Mercifully, <b><tt class="func">perror()</tt></b> does that.  If you want more
description to be printed before the error, you can point the parameter
<i><tt class="var">s</tt></i> to it (or you can leave <i><tt class="var">s</tt></i> as <tt class="const">NULL</tt>
and nothing additional will be printed.)</p>

<p>In a nutshell, this function takes <i><tt class="var">errno</tt></i> values, like
<tt class="const">ECONNRESET</tt>, and prints them nicely, like "Connection
reset by peer."</p>

<p>The function <b><tt class="func">strerror()</tt></b> is very similar to
<b><tt class="func">perror()</tt></b>, except it returns a pointer to the error message
string for a given value (you usually pass in the variable
<i><tt class="var">errno</tt></i>.)</p>



<h3 class="sect2title">Return Value</h3>

<p><b><tt class="func">strerror()</tt></b> returns a pointer to the error message
string.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int s;

s = socket(PF_INET, SOCK_STREAM, 0);

if (s == -1) { // some error has occurred
    // prints "socket error: " + the error message:
    perror("socket error");
}

// similarly:
if (listen(s, 10) == -1) {
    // this prints "an error: " + the error message from errno:
    printf("an error: %s\n", strerror(errno));
}</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#errnoman"><i><tt class="var">errno</tt></i></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.17. <a name="pollman"><b><tt class="titlefunc">poll()</tt></b></a></h2><p></p>

<p>Test for events on multiple sockets simultaneously</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/poll.h&gt;

int poll(struct pollfd *<i><tt class="var em1">ufds</tt></i>, unsigned int <i><tt class="var em1">nfds</tt></i>, int <i><tt class="var em1">timeout</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-276"></a>This function is very similar to
<b><tt class="func">select()</tt></b> in that they both watch sets of file descriptors
for events, such as incoming data ready to <b><tt class="func">recv()</tt></b>, socket
ready to <b><tt class="func">send()</tt></b> data to, out-of-band data ready to
<b><tt class="func">recv()</tt></b>, errors, etc.</p>

<p>The basic idea is that you pass an array of <i><tt class="var">nfds</tt></i>
<nobr><tt class="type">struct pollfd</tt></nobr>s in <i><tt class="var">ufds</tt></i>, along with a timeout in
milliseconds (1000 milliseconds in a second.)  The <i><tt class="var">timeout</tt></i>
can be negative if you want to wait forever.  If no event happens on any
of the socket descriptors by the timeout, <b><tt class="func">poll()</tt></b> will
return.</p>

<p>Each element in the array of <nobr><tt class="type">struct pollfd</tt></nobr>s represents
one socket descriptor, and contains the following fields:</p>

<pre class="code"><a name="indexId434909-277"></a>struct pollfd {
    int fd;         // the socket descriptor
    short events;   // bitmap of events we're interested in
    short revents;  // when poll() returns, bitmap of events that occurred
};</pre>


<p>Before calling <b><tt class="func">poll()</tt></b>, load <i><tt class="var">fd</tt></i> with the
socket descriptor (if you set <i><tt class="var">fd</tt></i> to a negative number, this
<nobr><tt class="type">struct pollfd</tt></nobr> is ignored and its <i><tt class="var">revents</tt></i> field
is set to zero) and then construct the <i><tt class="var">events</tt></i> field by
bitwise-ORing the following macros:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="25%%"><p><tt class="const">POLLIN</tt></p></td>

<td valign="top" align="left" width="73%%"><p>Alert me when data is ready to
<b><tt class="func">recv()</tt></b> on this socket.</p></td>
</tr>


<tr><td valign="top" align="left"><p><tt class="const">POLLOUT</tt></p></td>

<td valign="top" align="left"><p>Alert me when I can <b><tt class="func">send()</tt></b> data to this
socket without blocking.</p></td>
</tr>


<tr><td valign="top" align="left"><p><tt class="const">POLLPRI</tt></p></td>

<td valign="top" align="left"><p>Alert me when out-of-band data is ready to
<b><tt class="func">recv()</tt></b> on this socket.</p></td>
</tr>

</tbody></table></center>
<p></p>

<p>Once the <b><tt class="func">poll()</tt></b> call returns, the <i><tt class="var">revents</tt></i>
field will be constructed as a bitwise-OR of the above fields, telling
you which descriptors actually have had that event occur.  Additionally,
these other fields might be present:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="25%%"><p><tt class="const">POLLERR</tt></p></td>

<td valign="top" align="left" width="73%%"><p>An error has occurred on this socket.</p></td>
</tr>


<tr><td valign="top" align="left"><p><tt class="const">POLLHUP</tt></p></td>

<td valign="top" align="left"><p>The remote side of the connection hung up.</p></td>
</tr>


<tr><td valign="top" align="left"><p><tt class="const">POLLNVAL</tt></p></td>

<td valign="top" align="left"><p>Something was wrong with the socket descriptor
<i><tt class="var">fd</tt></i>‚Äîmaybe it's uninitialized?</p></td>
</tr>

</tbody></table></center>
<p></p>



<h3 class="sect2title">Return Value</h3>

<p>Returns the number of elements in the <i><tt class="var">ufds</tt></i> array that have
had event occur on them; this can be zero if the timeout occurred.  Also
returns <tt class="const">-1</tt> on error (and <b><tt class="func">errno</tt></b> will be set
accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int s1, s2;
int rv;
char buf1[256], buf2[256];
struct pollfd ufds[2];

s1 = socket(PF_INET, SOCK_STREAM, 0);
s2 = socket(PF_INET, SOCK_STREAM, 0);

// pretend we've connected both to a server at this point
//connect(s1, ...)...
//connect(s2, ...)...

// set up the array of file descriptors.
//
// in this example, we want to know when there's normal or out-of-band
// data ready to be recv()'d...

ufds[0].fd = s1;
ufds[0].events = POLLIN | POLLPRI; // check for normal or out-of-band

ufds[1].fd = s2;
ufds[1].events = POLLIN; // check for just normal data

// wait for events on the sockets, 3.5 second timeout
rv = poll(ufds, 2, 3500);

if (rv == -1) {
    perror("poll"); // error occurred in poll()
} else if (rv == 0) {
    printf("Timeout occurred!  No data after 3.5 seconds.\n");
} else {
    // check for events on s1:
    if (ufds[0].revents &amp; POLLIN) {
        recv(s1, buf1, sizeof buf1, 0); // receive normal data
    }
    if (ufds[0].revents &amp; POLLPRI) {
        recv(s1, buf1, sizeof buf1, MSG_OOB); // out-of-band data
    }

    // check for events on s2:
    if (ufds[1].revents &amp; POLLIN) {
        recv(s1, buf2, sizeof buf2, 0);
    }
}</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#selectman"><b><tt class="func">select()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.18. <a name="recvman"><b><tt class="titlefunc">recv()</tt></b>, <b><tt class="titlefunc">recvfrom()</tt></b></a></h2><p></p>

<p>Receive data on a socket</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t recv(int s, void *<i><tt class="var em1">buf</tt></i>, size_t <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">flags</tt></i>);
ssize_t recvfrom(int <i><tt class="var em1">s</tt></i>, void *<i><tt class="var em1">buf</tt></i>, size_t <i><tt class="var em1">len</tt></i>, int <i><tt class="var em1">flags</tt></i>,
                 struct sockaddr *<i><tt class="var em1">from</tt></i>, socklen_t *<i><tt class="var em1">fromlen</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-278"></a><a name="indexId434909-279"></a>Once you have a socket up and
connected, you can read incoming data from the remote side using the
<b><tt class="func">recv()</tt></b> (for TCP <a name="indexId434909-280"></a><tt class="const">SOCK_STREAM</tt> sockets) and
<b><tt class="func">recvfrom()</tt></b> (for UDP <a name="indexId434909-281"></a><tt class="const">SOCK_DGRAM</tt> sockets).</p>

<p>Both functions take the socket descriptor <i><tt class="var">s</tt></i>, a pointer to
the buffer <i><tt class="var">buf</tt></i>, the size (in bytes) of the buffer
<i><tt class="var">len</tt></i>, and a set of <i><tt class="var">flags</tt></i> that control how the
functions work.</p>

<p>Additionally, the <b><tt class="func">recvfrom()</tt></b> takes a
<a name="indexId434909-282"></a><nobr><tt class="type">struct sockaddr*</tt></nobr>,
<i><tt class="var">from</tt></i> that will tell you where the data came from, and will
fill in <i><tt class="var">fromlen</tt></i> with the size of <nobr><tt class="type">struct
sockaddr</tt></nobr>.  (You must also initialize <i><tt class="var">fromlen</tt></i> to be the
size of <i><tt class="var">from</tt></i> or <nobr><tt class="type">struct sockaddr</tt></nobr>.)</p>

<p>So what wondrous flags can you pass into this function?  Here are
some of them, but you should check your local man pages for more
information and what is actually supported on your system.  You
bitwise-or these together, or just set <i><tt class="var">flags</tt></i> to
<tt class="const">0</tt> if you want it to be a regular vanilla
<b><tt class="func">recv()</tt></b>.</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="30%%"><p><a name="indexId434909-283"></a><tt class="const">MSG_OOB</tt></p></td>

<td valign="top" align="left" width="68%%"><p><a name="indexId434909-284"></a>Receive Out of Band data.
This is how to get data that has been sent to you with the
<tt class="const">MSG_OOB</tt> flag in <b><tt class="func">send()</tt></b>.  As the receiving
side, you will have had signal <a name="indexId434909-285"></a><tt class="const">SIGURG</tt>
raised telling you there is urgent data.  In your handler for that
signal, you could call <b><tt class="func">recv()</tt></b> with this
<tt class="const">MSG_OOB</tt> flag.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-286"></a><tt class="const">MSG_PEEK</tt></p></td>

<td valign="top" align="left"><p>If you want to call <b><tt class="func">recv()</tt></b> "just for
pretend", you can call it with this flag.  This will tell you what's
waiting in the buffer for when you call <b><tt class="func">recv()</tt></b> "for real"
(i.e. <i>without</i> the <tt class="const">MSG_PEEK</tt> flag.  It's like a
sneak preview into the next <b><tt class="func">recv()</tt></b> call.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-287"></a><tt class="const">MSG_WAITALL</tt></p></td>

<td valign="top" align="left"><p>Tell <b><tt class="func">recv()</tt></b> to not return until all the data
you specified in the <i><tt class="var">len</tt></i> parameter.  It will ignore your
wishes in extreme circumstances, however, like if a signal interrupts
the call or if some error occurs or if the remote side closes the
connection, etc.  Don't be mad with it.</p></td>
</tr>


</tbody></table></center>
<p></p>

<p>When you call <b><tt class="func">recv()</tt></b>, it will block until there is some
data to read.  If you want to not block, set the socket to non-blocking
or check with <b><tt class="func">select()</tt></b> or <b><tt class="func">poll()</tt></b> to see if
there is incoming data before calling <b><tt class="func">recv()</tt></b> or
<b><tt class="func">recvfrom()</tt></b>.</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns the number of bytes actually received (which might be less
than you requested in the <i><tt class="var">len</tt></i> parameter), or <tt class="const">-1</tt>
on error (and <b><tt class="func">errno</tt></b> will be set accordingly.)</p>

<p>If the remote side has closed the connection, <b><tt class="func">recv()</tt></b>
will return <tt class="const">0</tt>.  This is the normal method for determining
if the remote side has closed the connection.  Normality is good,
rebel!</p>



<h3 class="sect2title">Example</h3>

<pre class="code">// stream sockets and recv()

struct addrinfo hints, *res;
int sockfd;
char buf[512];
int byte_count;

// get host info, make socket, and connect it
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

// all right!  now that we're connected, we can receive some data!
byte_count = recv(sockfd, buf, sizeof buf, 0);
printf("recv()'d %d bytes of data in buf\n", byte_count);
</pre>


<pre class="code">// datagram sockets and recvfrom()

struct addrinfo hints, *res;
int sockfd;
int byte_count;
socklen_t fromlen;
struct sockaddr_storage addr;
char buf[512];
char ipstr[INET6_ADDRSTRLEN];

// get host info, make socket, bind it to port 4950
memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_DGRAM;
hints.ai_flags = AI_PASSIVE;
getaddrinfo(NULL, "4950", &amp;hints, &amp;res);
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);
bind(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);

// no need to accept(), just recvfrom():

fromlen = sizeof addr;
byte_count = recvfrom(sockfd, buf, sizeof buf, 0, &amp;addr, &amp;fromlen);

printf("recv()'d %d bytes of data in buf\n", byte_count);
printf("from IP address %s\n",
    inet_ntop(addr.ss_family,
        addr.ss_family == AF_INET?
            ((struct sockadd_in *)&amp;addr)-&gt;sin_addr:
            ((struct sockadd_in6 *)&amp;addr)-&gt;sin6_addr,
        ipstr, sizeof ipstr);

</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#sendman"><b><tt class="func">send()</tt></b></a>,
<a href="#sendman"><b><tt class="func">sendto()</tt></b></a>,
<a href="#selectman"><b><tt class="func">select()</tt></b></a>,
<a href="#pollman"><b><tt class="func">poll()</tt></b></a>,
<a href="#blocking">Blocking</a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.19. <a name="selectman"><b><tt class="titlefunc">select()</tt></b></a></h2><p></p>

<p>Check if sockets descriptors are ready to read/write</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/select.h&gt;

int select(int <i><tt class="var em1">n</tt></i>, fd_set *<i><tt class="var em1">readfds</tt></i>, fd_set *<i><tt class="var em1">writefds</tt></i>, fd_set *<i><tt class="var em1">exceptfds</tt></i>,
           struct timeval *<i><tt class="var em1">timeout</tt></i>);

FD_SET(int <i><tt class="var em1">fd</tt></i>, fd_set *<i><tt class="var em1">set</tt></i>);
FD_CLR(int <i><tt class="var em1">fd</tt></i>, fd_set *<i><tt class="var em1">set</tt></i>);
FD_ISSET(int <i><tt class="var em1">fd</tt></i>, fd_set *<i><tt class="var em1">set</tt></i>);
FD_ZERO(fd_set *<i><tt class="var em1">set</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-288"></a>The <b><tt class="func">select()</tt></b> function gives you a
way to simultaneously check multiple sockets to see if they have data
waiting to be <b><tt class="func">recv()</tt></b>d, or if you can <b><tt class="func">send()</tt></b>
data to them without blocking, or if some exception has occurred.</p>

<p>You populate your sets of socket descriptors using the macros, like
<b><tt class="func">FD_SET()</tt></b>, above.  Once you have the set, you pass it into
the function as one of the following parameters: <i><tt class="var">readfds</tt></i> if
you want to know when any of the sockets in the set is ready to
<b><tt class="func">recv()</tt></b> data, <i><tt class="var">writefds</tt></i> if any of the sockets is
ready to <b><tt class="func">send()</tt></b> data to, and/or <i><tt class="var">exceptfds</tt></i> if you
need to know when an exception (error) occurs on any of the sockets.
Any or all of these parameters can be <tt class="const">NULL</tt> if you're not
interested in those types of events.  After <b><tt class="func">select()</tt></b>
returns, the values in the sets will be changed to show which are ready
for reading or writing, and which have exceptions.</p>

<p>The first parameter, <i><tt class="var">n</tt></i> is the highest-numbered socket
descriptor (they're just <nobr><tt class="type">int</tt></nobr>s, remember?) plus one.</p>

<p>Lastly, the <a name="indexId434909-289"></a><nobr><tt class="type">struct timeval</tt></nobr>,
<i><tt class="var">timeout</tt></i>, at the end‚Äîthis lets you tell
<b><tt class="func">select()</tt></b> how long to check these sets for.  It'll return
after the timeout, or when an event occurs, whichever is first.  The
<nobr><tt class="type">struct timeval</tt></nobr> has two fields: <i><tt class="var">tv_sec</tt></i> is the
number of seconds, to which is added <i><tt class="var">tv_usec</tt></i>, the number of
microseconds (1,000,000 microseconds in a second.)</p>

<p>The helper macros do the following:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="50%%"><p><a name="indexId434909-290"></a><b><tt class="func">FD_SET(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left" width="48%%"><p>Add <i><tt class="var">fd</tt></i> to the <i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-291"></a><b><tt class="func">FD_CLR(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Remove <i><tt class="var">fd</tt></i> from the <i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-292"></a><b><tt class="func">FD_ISSET(int fd, fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Return true if <i><tt class="var">fd</tt></i> is in the
<i><tt class="var">set</tt></i>.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-293"></a><b><tt class="func">FD_ZERO(fd_set *set);</tt></b></p></td>

<td valign="top" align="left"><p>Clear all entries from the <i><tt class="var">set</tt></i>.</p></td>
</tr>

</tbody></table></center>
<p></p>

<p>Note for Linux users: Linux's <b><tt class="func">select()</tt></b> can return
"ready-to-read" and then not actually be ready to read, thus causing the
subsequent <b><tt class="func">read()</tt></b> call to block. You can work around this
bug by setting <a name="indexId434909-294"></a><tt class="const">O_NONBLOCK</tt> flag on
the receiving socket so it errors with <tt class="const">EWOULDBLOCK</tt>, then
ignoring this error if it occurs.  See the <a href="#fcntlman"><b><tt class="func">fcntl()</tt></b> reference page</a> for more info
on setting a socket to non-blocking.</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns the number of descriptors in the set on success,
<tt class="const">0</tt> if the timeout was reached, or <tt class="const">-1</tt> on
error (and <b><tt class="func">errno</tt></b> will be set accordingly.)  Also, the sets
are modified to show which sockets are ready.</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int s1, s2, n;
fd_set readfds;
struct timeval tv;
char buf1[256], buf2[256];

// pretend we've connected both to a server at this point
//s1 = socket(...);
//s2 = socket(...);
//connect(s1, ...)...
//connect(s2, ...)...

// clear the set ahead of time
FD_ZERO(&amp;readfds);

// add our descriptors to the set
FD_SET(s1, &amp;readfds);
FD_SET(s2, &amp;readfds);

// since we got s2 second, it's the "greater", so we use that for
// the n param in select()
n = s2 + 1;

// wait until either socket has data ready to be recv()d (timeout 10.5 secs)
tv.tv_sec = 10;
tv.tv_usec = 500000;
rv = select(n, &amp;readfds, NULL, NULL, &amp;tv);

if (rv == -1) {
    perror("select"); // error occurred in select()
} else if (rv == 0) {
    printf("Timeout occurred!  No data after 10.5 seconds.\n");
} else {
    // one or both of the descriptors have data
    if (FD_ISSET(s1, &amp;readfds)) {
        recv(s1, buf1, sizeof buf1, 0);
    }
    if (FD_ISSET(s2, &amp;readfds)) {
        recv(s2, buf2, sizeof buf2, 0);
    }
}</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#pollman"><b><tt class="func">poll()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.20. <a name="setsockoptman"><b><tt class="titlefunc">setsockopt()</tt></b>, <b><tt class="titlefunc">getsockopt()</tt></b></a></h2><p></p>

<p>Set various options for a socket</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int getsockopt(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">level</tt></i>, int <i><tt class="var em1">optname</tt></i>, void *<i><tt class="var em1">optval</tt></i>,
               socklen_t *<i><tt class="var em1">optlen</tt></i>);
int setsockopt(int <i><tt class="var em1">s</tt></i>, int <i><tt class="var em1">level</tt></i>, int <i><tt class="var em1">optname</tt></i>, const void *<i><tt class="var em1">optval</tt></i>,
               socklen_t <i><tt class="var em1">optlen</tt></i>);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-295"></a><a name="indexId434909-296"></a>Sockets are fairly
configurable beasts.  In fact, they are so configurable, I'm not even
going to cover it all here.  It's probably system-dependent anyway.  But
I will talk about the basics.</p>

<p>Obviously, these functions get and set certain options on a socket.
On a Linux box, all the socket information is in the man page for socket
in section 7.  (Type: "<b class="com">man 7 socket</b>" to get all these
goodies.)</p>

<p>As for parameters, <i><tt class="var">s</tt></i> is the socket you're talking about,
level should be set to <a name="indexId434909-297"></a><tt class="const">SOL_SOCKET</tt>.
Then you set the <i><tt class="var">optname</tt></i> to the name you're interested in.
Again, see your man page for all the options, but here are some of the
most fun ones:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="30%%"><p><a name="indexId434909-298"></a><tt class="const">SO_BINDTODEVICE</tt></p></td>

<td valign="top" align="left" width="68%%"><p>Bind this socket to a symbolic device name like
<tt class="tt">eth0</tt> instead of using <b><tt class="func">bind()</tt></b> to bind it to an IP
address.  Type the command <b class="com">ifconfig</b> under Unix to see the
device names.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-299"></a><tt class="const">SO_REUSEADDR</tt></p></td>

<td valign="top" align="left"><p>Allows other sockets to <b><tt class="func">bind()</tt></b> to this port, unless
there is an active listening socket bound to the port already.  This
enables you to get around those "Address already in use" error messages
when you try to restart your server after a crash.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-300"></a><tt class="const">SO_BROADCAST</tt></p></td>

<td valign="top" align="left"><p>Allows UDP datagram (<a name="indexId434909-301"></a><tt class="const">SOCK_DGRAM</tt>) sockets to send and receive
packets sent to and from the broadcast address.  Does
nothing‚Äî<i>NOTHING!!</i>‚Äîto TCP stream sockets!
Hahaha!</p></td>
</tr>


</tbody></table></center>
<p></p>

<p>As for the parameter <i><tt class="var">optval</tt></i>, it's usually a pointer to an
<nobr><tt class="type">int</tt></nobr> indicating the value in question.  For booleans, zero
is false, and non-zero is true.  And that's an absolute fact, unless
it's different on your system.  If there is no parameter to be passed,
<i><tt class="var">optval</tt></i> can be <tt class="const">NULL</tt>.</p>

<p>The final parameter, <i><tt class="var">optlen</tt></i>, should be set to the length
of <i><tt class="var">optval</tt></i>, probably <tt class="tt">sizeof(int)</tt>, but varies
depending on the option. Note that in the case of
<b><tt class="func">getsockopt()</tt></b>, this is a pointer to a
<nobr><tt class="type">socklen_t</tt></nobr>, and it specifies the maximum size object that
will be stored in <i><tt class="var">optval</tt></i> (to prevent buffer overflows). And
<b><tt class="func">getsockopt()</tt></b> will modify the value of <i><tt class="var">optlen</tt></i> to
reflect the number of bytes actually set.</p>

<p><b>Warning</b>: on some systems (notably <a name="indexId434909-302"></a><a name="indexId434909-303"></a>Sun and <a name="indexId434909-304"></a>Windows), the option
can be a <nobr><tt class="type">char</tt></nobr> instead of an <nobr><tt class="type">int</tt></nobr>, and is set
to, for example, a character value of <tt class="tt">'1'</tt> instead of an
<nobr><tt class="type">int</tt></nobr> value of <tt class="const">1</tt>.  Again, check your own man
pages for more info with "<b class="com">man setsockopt</b>" and "<b class="com">man 7
socket</b>"!</p>



<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int optval;
int optlen;
char *optval2;

// set SO_REUSEADDR on a socket to true (1):
optval = 1;
setsockopt(s1, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof optval);

// bind a socket to a device name (might not work on all systems):
optval2 = "eth1"; // 4 bytes long, so 4, below:
setsockopt(s2, SOL_SOCKET, SO_BINDTODEVICE, optval2, 4);

// see if the SO_BROADCAST flag is set:
getsockopt(s3, SOL_SOCKET, SO_BROADCAST, &amp;optval, &amp;optlen);
if (optval != 0) {
    print("SO_BROADCAST enabled on s3!\n");
}</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#fcntlman"><b><tt class="func">fcntl()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.21. <a name="sendman"><b><tt class="titlefunc">send()</tt></b>, <b><tt class="titlefunc">sendto()</tt></b></a></h2><p></p>

<p>Send data out over a socket</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int s, const void *buf, size_t len, int flags);
ssize_t sendto(int s, const void *buf, size_t len,
               int flags, const struct sockaddr *to,
               socklen_t tolen);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-305"></a><a name="indexId434909-306"></a>These functions send data to a
socket.  Generally speaking, <b><tt class="func">send()</tt></b> is used for TCP <a name="indexId434909-307"></a><tt class="const">SOCK_STREAM</tt> connected sockets, and
<b><tt class="func">sendto()</tt></b> is used for UDP <a name="indexId434909-308"></a><tt class="const">SOCK_DGRAM</tt> unconnected datagram
sockets.  With the unconnected sockets, you must specify the destination
of a packet each time you send one, and that's why the last parameters
of <b><tt class="func">sendto()</tt></b> define where the packet is going.</p>

<p>With both <b><tt class="func">send()</tt></b> and <b><tt class="func">sendto()</tt></b>, the
parameter <i><tt class="var">s</tt></i> is the socket, <i><tt class="var">buf</tt></i> is a pointer to the
data you want to send, <i><tt class="var">len</tt></i> is the number of bytes you want to
send, and <i><tt class="var">flags</tt></i> allows you to specify more information about
how the data is to be sent.  Set <i><tt class="var">flags</tt></i> to zero if you want it
to be "normal" data.  Here are some of the commonly used flags, but
check your local <b><tt class="func">send()</tt></b> man pages for more details:</p>

<p></p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="30%%"><p><a name="indexId434909-309"></a><tt class="const">MSG_OOB</tt></p></td>
 <td valign="top" align="left" width="68%%"><p>Send
as <a name="indexId434909-310"></a>"out of band" data.  TCP supports this,
and it's a way to tell the receiving system that this data has a higher
priority than the normal data.  The receiver will receive the signal
<a name="indexId434909-311"></a><tt class="const">SIGURG</tt> and it can then receive this data without first
receiving all the rest of the normal data in the queue.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-312"></a><tt class="const">MSG_DONTROUTE</tt></p></td>

<td valign="top" align="left"><p>Don't send this data over a router, just keep it
local.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-313"></a><tt class="const">MSG_DONTWAIT</tt></p></td>

<td valign="top" align="left"><p>If <b><tt class="func">send()</tt></b> would block because outbound
traffic is clogged, have it return <a name="indexId434909-314"></a><tt class="const">EAGAIN</tt>.  This is like a "enable <a name="indexId434909-315"></a>non-blocking just for this send."  See the
section on <a href="#blocking">blocking</a>  for more
details.</p></td>
</tr>


<tr><td valign="top" align="left"><p><a name="indexId434909-316"></a><tt class="const">MSG_NOSIGNAL</tt></p></td>

<td valign="top" align="left"><p>If you <b><tt class="func">send()</tt></b> to a remote host which is
no longer <b><tt class="func">recv()</tt></b>ing, you'll typically get the signal <a name="indexId434909-317"></a><tt class="const">SIGPIPE</tt>.  Adding this flag prevents that
signal from being raised.</p></td>
</tr>


</tbody></table></center>
<p></p>



<h3 class="sect2title">Return Value</h3>

<p>Returns the number of bytes actually sent, or <tt class="const">-1</tt> on
error (and <b><tt class="func">errno</tt></b> will be set accordingly.)  Note that the
number of bytes actually sent might be less than the number you asked it
to send!  See the section on <a href="#sendall">handling partial
<b><tt class="func">send()</tt></b>s</a> for a helper function to get around this.</p>

<p>Also, if the socket has been closed by either side, the process
calling <b><tt class="func">send()</tt></b> will get the signal <tt class="const">SIGPIPE</tt>.
(Unless <b><tt class="func">send()</tt></b> was called with the
<tt class="const">MSG_NOSIGNAL</tt> flag.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int spatula_count = 3490;
char *secret_message = "The Cheese is in The Toaster";

int stream_socket, dgram_socket;
struct sockaddr_in dest;
int temp;

// first with TCP stream sockets:

// assume sockets are made and connected
//stream_socket = socket(...
//connect(stream_socket, ...

// convert to network byte order
temp = htonl(spatula_count);
// send data normally:
send(stream_socket, &amp;temp, sizeof temp, 0);

// send secret message out of band:
send(stream_socket, secret_message, strlen(secret_message)+1, MSG_OOB);

// now with UDP datagram sockets:
//getaddrinfo(...
//dest = ...  // assume "dest" holds the address of the destination
//dgram_socket = socket(...

// send secret message normally:
sendto(dgram_socket, secret_message, strlen(secret_message)+1, 0, 
       (struct sockaddr*)&amp;dest, sizeof dest);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#recvman"><b><tt class="func">recv()</tt></b></a>,
<a href="#recvman"><b><tt class="func">recvfrom()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.22. <a name="shutdownman"><b><tt class="titlefunc">shutdown()</tt></b></a></h2><p></p>

<p>Stop further sends and receives on a socket</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/socket.h&gt;

int shutdown(int s, int how);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-318"></a>That's it!  I've had it!  No more
<b><tt class="func">send()</tt></b>s are allowed on this socket, but I still want to
<b><tt class="func">recv()</tt></b> data on it!  Or vice-versa!  How can I do this?</p>

<p>When you <b><tt class="func">close()</tt></b> a socket descriptor, it closes both
sides of the socket for reading and writing, and frees the socket
descriptor.  If you just want to close one side or the other, you can
use this <b><tt class="func">shutdown()</tt></b> call.</p>

<p>As for parameters, <i><tt class="var">s</tt></i> is obviously the socket you want to
perform this action on, and what action that is can be specified with
the <i><tt class="var">how</tt></i> parameter.  How can be <tt class="const">SHUT_RD</tt> to
prevent further <b><tt class="func">recv()</tt></b>s, <tt class="const">SHUT_WR</tt> to prohibit
further <b><tt class="func">send()</tt></b>s, or <tt class="const">SHUT_RDWR</tt> to do
both.</p>

<p>Note that <b><tt class="func">shutdown()</tt></b> doesn't free up the socket
descriptor, so you still have to eventually <b><tt class="func">close()</tt></b> the
socket even if it has been fully shut down.</p>

<p>This is a rarely used system call.</p>


<h3 class="sect2title">Return Value</h3>

<p>Returns zero on success, or <tt class="const">-1</tt> on error (and
<b><tt class="func">errno</tt></b> will be set accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">int s = socket(PF_INET, SOCK_STREAM, 0);

// ...do some send()s and stuff in here...

// and now that we're done, don't allow any more sends()s:
shutdown(s, SHUT_WR);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#closeman"><b><tt class="func">close()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.23. <a name="socketman"><b><tt class="titlefunc">socket()</tt></b></a></h2><p></p>

<p>Allocate a socket descriptor</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);</pre>



<h3 class="sect2title">Description</h3>

<p><a name="indexId434909-319"></a>Returns a new socket descriptor that you can use
to do sockety things with.  This is generally the first call in the
whopping process of writing a socket program, and you can use the result
for subsequent calls to <b><tt class="func">listen()</tt></b>, <tt class="tt">bind()</tt>,
<tt class="tt">accept()</tt>, or a variety of other functions.</p>

<p>In usual usage, you get the values for these parameters from a call
to <b><tt class="func">getaddrinfo()</tt></b>, as shown in the example below.  But you
can fill them in by hand if you really want to.</p>

<p>
</p><center><table cellpadding="10" cellspacing="0" border="0" class="joetable">

<tbody><tr><td valign="top" align="left" width="20%%"><p><i><tt class="var">domain</tt></i></p></td>


<td valign="top" align="left" width="78%%"><p><i><tt class="var">domain</tt></i> describes what kind of socket
you're interested in.  This can, believe me, be a wide variety of
things, but since this is a socket guide, it's going to be <a name="indexId434909-320"></a><tt class="const">PF_INET</tt> for IPv4, and
<tt class="const">PF_INET6</tt> for IPv6.</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">type</tt></i></p></td>


<td valign="top" align="left"><p>Also, the <i><tt class="var">type</tt></i> parameter can be a number of things,
but you'll probably be setting it to either <a name="indexId434909-321"></a><tt class="const">SOCK_STREAM</tt> for reliable <a name="indexId434909-322"></a>TCP sockets (<b><tt class="func">send()</tt></b>, <b><tt class="func">recv()</tt></b>) or <a name="indexId434909-323"></a><tt class="const">SOCK_DGRAM</tt> for unreliable fast <a name="indexId434909-324"></a>UDP sockets (<b><tt class="func">sendto()</tt></b>,
<b><tt class="func">recvfrom()</tt></b>.)</p>

<p>(Another interesting socket type is <a name="indexId434909-325"></a><tt class="const">SOCK_RAW</tt> which can be used to construct
packets by hand.  It's pretty cool.)</p></td>
</tr>


<tr><td valign="top" align="left"><p><i><tt class="var">protocol</tt></i></p></td>


<td valign="top" align="left"><p>Finally, the <i><tt class="var">protocol</tt></i> parameter tells which protocol to
use with a certain socket type.  Like I've already said, for instance,
<tt class="const">SOCK_STREAM</tt> uses TCP.  Fortunately for you, when using
<tt class="const">SOCK_STREAM</tt> or <tt class="const">SOCK_DGRAM</tt>, you can just
set the protocol to 0, and it'll use the proper protocol automatically.
Otherwise, you can use <a name="indexId434909-326"></a><b><tt class="func">getprotobyname()</tt></b> to look up the
proper protocol number.</p></td>


</tr>
</tbody></table></center>
<p></p>



<h3 class="sect2title">Return Value</h3>

<p>The new socket descriptor to be used in subsequent calls, or
<tt class="const">-1</tt> on error (and <b><tt class="func">errno</tt></b> will be set
accordingly.)</p>


<h3 class="sect2title">Example</h3>

<pre class="code">struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():

memset(&amp;hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;     // AF_INET, AF_INET6, or AF_UNSPEC
hints.ai_socktype = SOCK_STREAM; // SOCK_STREAM or SOCK_DGRAM

getaddrinfo("www.example.com", "3490", &amp;hints, &amp;res);

// make a socket using the information gleaned from getaddrinfo():
sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#acceptman"><b><tt class="func">accept()</tt></b></a>,
<a href="#bindman"><b><tt class="func">bind()</tt></b></a>,
<a href="#getaddrinfoman"><b><tt class="func">getaddrinfo()</tt></b></a>,
<a href="#listenman"><b><tt class="func">listen()</tt></b></a></p>






<p></p><hr class="mainsectbreak">
<h2 class="sect1title">9.24. <a name="sockaddr_inman"><nobr><b><tt class="titletype">struct sockaddr</tt></b></nobr> and pals</a></h2><p></p>

<p>Structures for handling internet addresses</p>

<h3 class="sect2title">Prototypes</h3>

<pre class="code">#include &lt;netinet/in.h&gt;

// All pointers to socket address structures are often cast to pointers
// to this type before use in various functions and system calls:

struct sockaddr {
    unsigned short    <i><tt class="var em1">sa_family</tt></i>;    // address family, AF_xxx
    char              <i><tt class="var em1">sa_data</tt></i>[14];  // 14 bytes of protocol address
};


// IPv4 AF_INET sockets:

struct sockaddr_in {
    short            <i><tt class="var em1">sin_family</tt></i>;   // e.g. AF_INET, AF_INET6
    unsigned short   <i><tt class="var em1">sin_port</tt></i>;     // e.g. htons(3490)
    struct in_addr   <i><tt class="var em1">sin_addr</tt></i>;     // see struct in_addr, below
    char             <i><tt class="var em1">sin_zero</tt></i>[8];  // zero this if you want to
};

struct in_addr {
    unsigned long <i><tt class="var em1">s_addr</tt></i>;          // load with inet_pton()
};


// IPv6 AF_INET6 sockets:

struct sockaddr_in6 {
    u_int16_t       <i><tt class="var em1">sin6_family</tt></i>;   // address family, AF_INET6
    u_int16_t       <i><tt class="var em1">sin6_port</tt></i>;     // port number, Network Byte Order
    u_int32_t       <i><tt class="var em1">sin6_flowinfo</tt></i>; // IPv6 flow information
    struct in6_addr <i><tt class="var em1">sin6_addr</tt></i>;     // IPv6 address
    u_int32_t       <i><tt class="var em1">sin6_scope_id</tt></i>; // Scope ID
};

struct in6_addr {
    unsigned char   <i><tt class="var em1">s6_addr[16]</tt></i>;   // load with inet_pton()
};


// General socket address holding structure, big enough to hold either
// struct sockaddr_in or struct sockaddr_in6 data:

struct sockaddr_storage {
    sa_family_t  <i><tt class="var em1">ss_family</tt></i>;     // address family

    // all this is padding, implementation specific, ignore it:
    char      __ss_pad1[_SS_PAD1SIZE];
    int64_t   __ss_align;
    char      __ss_pad2[_SS_PAD2SIZE];
};</pre>



<h3 class="sect2title">Description</h3>


<p><a name="indexId434909-327"></a><a name="indexId434909-328"></a>These are the
basic structures for all syscalls and functions that deal with internet
addresses.  Often you'll use <b><tt class="func">getaddrinfo()</tt></b> to fill these
structures out, and then will read them when you have to.</p>

<p>In memory, the <nobr><tt class="type">struct sockaddr_in</tt></nobr> and <nobr><tt class="type">struct
sockaddr_in6</tt></nobr> share the same beginning structure as <a name="indexId434909-329"></a><nobr><tt class="type">struct sockaddr</tt></nobr>, and you can freely
cast the pointer of one type to the other without any harm, except the
possible end of the universe.</p>

<p>Just kidding on that end-of-the-universe thing...if the universe does
end when you cast a <nobr><tt class="type">struct sockaddr_in*</tt></nobr> to a <nobr><tt class="type"> struct
sockaddr*</tt></nobr>, I promise you it's pure coincidence and you shouldn't
even worry about it.</p>

<p>So, with that in mind, remember that whenever a function says it
takes a <nobr><tt class="type">struct sockaddr*</tt></nobr> you can cast your <nobr><tt class="type">struct
sockaddr_in*</tt></nobr>, <nobr><tt class="type">struct sockaddr_in6*</tt></nobr>, or <nobr><tt class="type">struct
sockadd_storage*</tt></nobr> to that type with ease and safety.</p>

<p><nobr><tt class="type">struct sockaddr_in</tt></nobr> is the structure used with IPv4
addresses (e.g. "192.0.2.10").  It holds an address family
(<tt class="const">AF_INET</tt>), a port in <i><tt class="var">sin_port</tt></i>, and an IPv4
address in <i><tt class="var">sin_addr</tt></i>.</p>

<p>There's also this <nobr><tt class="type">sin_zero</tt></nobr> field in <nobr><tt class="type">struct
sockaddr_in</tt></nobr> which some people claim must be set to zero.  Other
people don't claim anything about it (the Linux documentation doesn't
even mention it at all), and setting it to zero doesn't seem to be
actually necessary.  So, if you feel like it, set it to zero using
<b><tt class="func">memset()</tt></b>.</p>

<p>Now, that <nobr><tt class="type">struct in_addr</tt></nobr> is a weird beast on different
systems.  Sometimes it's a crazy <tt class="tt">union</tt> with all kinds of
<tt class="tt">#define</tt>s and other nonsense.  But what you should do is only
use the <i><tt class="var">s_addr</tt></i> field in this structure, because many systems
only implement that one.</p>

<p><nobr><tt class="type">struct sockadd_in6</tt></nobr> and <nobr><tt class="type">struct in6_addr</tt></nobr> are
very similar, except they're used for IPv6.</p>

<p><nobr><tt class="type">struct sockaddr_storage</tt></nobr> is a struct you can pass to
<b><tt class="func">accept()</tt></b> or <b><tt class="func">recvfrom()</tt></b> when you're trying to
write IP version-agnostic code and you don't know if the new address is
going to be IPv4 or IPv6.  The <nobr><tt class="type">struct sockaddr_storage</tt></nobr>
structure is large enough to hold both types, unlike the original small
<nobr><tt class="type">struct sockaddr</tt></nobr>.</p>





<h3 class="sect2title">Example</h3>

<pre class="code">// IPv4:

struct sockaddr_in ip4addr;
int s;

ip4addr.sin_family = AF_INET;
ip4addr.sin_port = htons(3490);
inet_pton(AF_INET, "10.0.0.1", &amp;ip4addr.sin_addr);

s = socket(PF_INET, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;ip4addr, sizeof ip4addr);</pre>

<pre class="code">// IPv6:

struct sockaddr_in6 ip6addr;
int s;

ip6addr.sin6_family = AF_INET6;
ip6addr.sin6_port = htons(4950);
inet_pton(AF_INET6, "2001:db8:8714:3a90::12", &amp;ip6addr.sin6_addr);

s = socket(PF_INET6, SOCK_STREAM, 0);
bind(s, (struct sockaddr*)&amp;ip6addr, sizeof ip6addr);</pre>



<h3 class="sect2title">See Also</h3>

<p><a href="#acceptman"><b><tt class="func">accept()</tt></b></a>,
<a href="#bindman"><b><tt class="func">bind()</tt></b></a>,
<a href="#connectman"><b><tt class="func">connect()</tt></b></a>,
<a href="#inet_ntoaman"><b><tt class="func">inet_aton()</tt></b></a>,
<a href="#inet_ntoaman"><b><tt class="func">inet_ntoa()</tt></b></a></p>
















<hr class="mainsectbreak"><h2 class="sect1title">10. <a name="reference">More References</a></h2><hr class="mainsecthr">


<p>You've come this far, and now you're screaming for more!  Where
else can you go to learn more about all this stuff?</p>







<h3 class="sect2title">10.1. <a name="books">Books</a></h3>


<p><a name="indexId434909-330"></a><a name="indexId434909-331"></a>For old-school actual
hold-it-in-your-hand pulp paper books, try some of the following
excellent books.  I used to be an affiliate with a very popular internet
bookseller, but their new customer tracking system is incompatible with
a print document.  As such, I get no more kickbacks.  If you feel
compassion for my plight, paypal a donation to
<tt class="email"><a href="mailto:beej@beej.us">beej@beej.us</a></tt>.  <tt>:-)</tt></p>




<p><i>Unix Network Programming, volumes 1-2</i> by W.
Richard Stevens.  Published by Prentice Hall.  ISBNs for volumes 1-2:
<a href="http://beej.us/guide/url/unixnet1" target="_blank">0131411551</a>,
<a href="http://beej.us/guide/url/unixnet2" target="_blank">0130810819</a>.
</p>


<p><i>Internetworking with TCP/IP, volumes I-III</i> by
Douglas E. Comer and David L. Stevens.  Published by Prentice Hall.
ISBNs for volumes I, II, and III:
<a href="http://beej.us/guide/url/intertcp1" target="_blank">0131876716</a>,
<a href="http://beej.us/guide/url/intertcp2" target="_blank">0130319961</a>,
<a href="http://beej.us/guide/url/intertcp3" target="_blank">0130320714</a>.
</p>


<p><i>TCP/IP Illustrated, volumes 1-3</i> by W.
Richard Stevens and Gary R. Wright.  Published by Addison Wesley.  ISBNs
for volumes 1, 2, and 3 (and a 3-volume set):
<a href="http://beej.us/guide/url/tcpi1" target="_blank">0201633469</a>,
<a href="http://beej.us/guide/url/tcpi2" target="_blank">020163354X</a>,
<a href="http://beej.us/guide/url/tcpi3" target="_blank">0201634953</a>,
(<a href="http://beej.us/guide/url/tcpi123" target="_blank">0201776316</a>).
</p>


<p><i>TCP/IP Network Administration</i> by Craig
Hunt.  Published by O'Reilly &amp; Associates, Inc.  ISBN
<a href="http://beej.us/guide/url/tcpna" target="_blank">0596002971</a>.
</p>


<p><i>Advanced Programming in the UNIX
Environment</i> by W. Richard Stevens.  Published by Addison
Wesley.  ISBN
<a href="http://beej.us/guide/url/advunix" target="_blank">0201433079</a>.
</p>











<h3 class="sect2title">10.2. <a name="webref">Web References</a></h3>


<p><a name="indexId434909-332"></a>On the web:</p>


<p><i><a href="http://www.cis.temple.edu/~giorgio/old/cis307s96/readings/docs/sockets.html" target="_blank"> BSD Sockets: A Quick And
Dirty Primer</a></i> (Unix system programming info,
too!)</p>


<p><i><a href="http://www.developerweb.net/forum/forumdisplay.php?f=70" target="_blank">The Unix Socket
FAQ</a></i></p>


<p><i><a href="http://pclt.cis.yale.edu/pclt/COMM/TCPIP.HTM" target="_blank">Intro to
TCP/IP</a></i></p>


<p><i><a href="http://www.faqs.org/faqs/internet/tcp-ip/tcp-ip-faq/part1/" target="_blank">TCP/IP
FAQ</a></i></p>


<p><i><a href="http://tangentsoft.net/wskfaq/" target="_blank">The Winsock
FAQ</a></i></p>



<p>And here are some relevant Wikipedia pages:</p>



<p><i><a href="http://en.wikipedia.org/wiki/Berkeley_sockets" target="_blank">Berkeley
Sockets</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Internet_Protocol" target="_blank">Internet Protocol
(IP)</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank">Transmission Control Protocol
(TCP)</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank">User Datagram Protocol
(UDP)</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Client-server" target="_blank">Client-Server</a></i></p>


<p><i><a href="http://en.wikipedia.org/wiki/Serialization" target="_blank">Serialization</a></i> (packing and unpacking
data)</p>












<h3 class="sect2title">10.3. <a name="rfcs">RFCs</a></h3>


<p><a name="indexId434909-333"></a><a href="http://www.rfc-editor.org/" target="_blank">RFCs</a>‚Äîthe real
dirt!  These are documents that describe assigned numbers, programming
APIs, and protocols that are used on the Internet.  I've included links
to a few of them here for your enjoyment, so grab a bucket of popcorn
and put on your thinking cap:</p>


<p><i><a href="http://tools.ietf.org/html/rfc1" target="_blank">RFC 1</a></i>‚ÄîThe First RFC;
this gives you an idea of what the "Internet" was like just as it was
coming to life, and an insight into how it was being designed from the
ground up.  (This RFC is completely obsolete, obviously!)</p>


<p><a name="indexId434909-334"></a><i><a href="http://tools.ietf.org/html/rfc768" target="_blank">RFC 768</a></i>‚ÄîThe User
Datagram Protocol (UDP)</p>


<p><a name="indexId434909-335"></a><i><a href="http://tools.ietf.org/html/rfc791" target="_blank">RFC
791</a></i>‚ÄîThe Internet Protocol (IP)</p>


<p><a name="indexId434909-336"></a><i><a href="http://tools.ietf.org/html/rfc793" target="_blank">RFC
793</a></i>‚ÄîThe Transmission Control Protocol
(TCP)</p>


<p><a name="indexId434909-337"></a><i><a href="http://tools.ietf.org/html/rfc854" target="_blank">RFC 854</a></i>‚ÄîThe Telnet
Protocol</p>


<p><a name="indexId434909-338"></a><i><a href="http://tools.ietf.org/html/rfc959" target="_blank">RFC 959</a></i>‚ÄîFile Transfer
Protocol (FTP)</p>


<p><a name="indexId434909-339"></a><i><a href="http://tools.ietf.org/html/rfc1350" target="_blank">RFC
1350</a></i>‚ÄîThe Trivial File Transfer Protocol
(TFTP)</p>


<p><a name="indexId434909-340"></a><i><a href="http://tools.ietf.org/html/rfc1459" target="_blank">RFC
1459</a></i>‚ÄîInternet Relay Chat Protocol
(IRC)</p>


<p><i><a href="http://tools.ietf.org/html/rfc1918" target="_blank">RFC
1918</a></i>‚ÄîAddress Allocation for Private
Internets</p>


<p><a name="indexId434909-341"></a><i><a href="http://tools.ietf.org/html/rfc2131" target="_blank">RFC
2131</a></i>‚ÄîDynamic Host Configuration Protocol
(DHCP)</p>


<p><a name="indexId434909-342"></a><i><a href="http://tools.ietf.org/html/rfc2616" target="_blank">RFC
2616</a></i>‚ÄîHypertext Transfer Protocol
(HTTP)</p>


<p><a name="indexId434909-343"></a><i><a href="http://tools.ietf.org/html/rfc2821" target="_blank">RFC
2821</a></i>‚ÄîSimple Mail Transfer Protocol
(SMTP)</p>


<p><i><a href="http://tools.ietf.org/html/rfc3330" target="_blank">RFC
3330</a></i>‚ÄîSpecial-Use IPv4 Addresses</p>


<p><i><a href="http://tools.ietf.org/html/rfc3493" target="_blank">RFC
3493</a></i>‚ÄîBasic Socket Interface Extensions for
IPv6</p>


<p><i><a href="http://tools.ietf.org/html/rfc3542" target="_blank">RFC
3542</a></i>‚ÄîAdvanced Sockets Application Program
Interface (API) for IPv6</p>


<p><i><a href="http://tools.ietf.org/html/rfc3849" target="_blank">RFC
3849</a></i>‚ÄîIPv6 Address Prefix Reserved for
Documentation</p>


<p><a name="indexId434909-344"></a><i><a href="http://tools.ietf.org/html/rfc3920" target="_blank">RFC
3920</a></i>‚ÄîExtensible Messaging and Presence Protocol
(XMPP)</p>


<p><a name="indexId434909-345"></a><i><a href="http://tools.ietf.org/html/rfc3977" target="_blank">RFC
3977</a></i>‚ÄîNetwork News Transfer Protocol
(NNTP)</p>


<p><i><a href="http://tools.ietf.org/html/rfc4193" target="_blank">RFC
4193</a></i>‚ÄîUnique Local IPv6 Unicast
Addresses</p>


<p><a name="indexId434909-346"></a><i><a href="http://tools.ietf.org/html/rfc4506" target="_blank">RFC
4506</a></i>‚ÄîExternal Data Representation Standard
(XDR)</p>




<p>The IETF has a nice online tool for <a href="http://tools.ietf.org/rfc/" target="_blank">searching and browsing RFCs</a>.</p>



 

<hr class="mainsectbreak"><h2 class="sect1title">Index<a name="zindex"></a></h2><a name="zindex">
<hr class="mainsecthr">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.x.x.x: </a><a href="#indexId434909-85">3.4.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;192.168.x.x: <a href="#indexId434909-86">3.4.1</a><br>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;255.255.255.255: <a href="#indexId434909-176">7.6</a>, <a href="#indexId434909-271">9.13</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">accept()</tt></b>: <a href="#indexId434909-109">5.5</a>, <a href="#indexId434909-111">5.6</a>, <a href="#indexId434909-223">9.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Address already in use: <a href="#indexId434909-100">5.3</a>, <a href="#indexId434909-183">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">AF_INET</tt>: <a href="#indexId434909-70">3.3</a>, <a href="#indexId434909-93">5.2</a>, <a href="#indexId434909-208">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">AF_INET6</tt>: <a href="#indexId434909-71">3.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;asynchronous I/O: <a href="#indexId434909-257">9.11</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bapper: <a href="#indexId434909-180">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">bind()</tt></b>: <a href="#indexId434909-94">5.3</a>, <a href="#indexId434909-186">8.0</a>, <a href="#indexId434909-229">9.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implicit: <a href="#indexId434909-103">5.3</a>, <a href="#indexId434909-107">5.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blah blah blah: <a href="#indexId434909-56">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blocking: <a href="#indexId434909-142">7.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;books: <a href="#indexId434909-330">10.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;broadcast: <a href="#indexId434909-173">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte ordering: <a href="#indexId434909-61">3.2</a>, <a href="#indexId434909-73">3.3</a>, <a href="#indexId434909-167">7.4</a>, <a href="#indexId434909-263">9.12</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datagram: <a href="#indexId434909-140">6.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream: <a href="#indexId434909-137">6.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client/server: <a href="#indexId434909-132">6.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">close()</tt></b>: <a href="#indexId434909-120">5.9</a>, <a href="#indexId434909-234">9.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">closesocket()</tt></b>: <a href="#indexId434909-11">1.5</a>, <a href="#indexId434909-124">5.9</a>, <a href="#indexId434909-238">9.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compilers: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">gcc</b>: <a href="#indexId434909-2">1.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compression: <a href="#indexId434909-206">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">connect()</tt></b>: <a href="#indexId434909-37">2.1</a>, <a href="#indexId434909-97">5.3</a>, <a href="#indexId434909-104">5.3</a>, <a href="#indexId434909-105">5.4</a>, <a href="#indexId434909-232">9.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on datagram sockets: <a href="#indexId434909-119">5.8</a>, <a href="#indexId434909-141">6.3</a>, <a href="#indexId434909-233">9.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Connection refused: <a href="#indexId434909-138">6.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">CreateProcess()</tt></b>: <a href="#indexId434909-16">1.5</a>, <a href="#indexId434909-212">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">CreateThread()</tt></b>: <a href="#indexId434909-17">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">CSocket</tt></nobr>: <a href="#indexId434909-13">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cygwin: <a href="#indexId434909-7">1.5</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data encapsulation: <a href="#indexId434909-46">2.2</a>, <a href="#indexId434909-162">7.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DHCP: <a href="#indexId434909-341">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;disconnected network: see private network.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DNS: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;domain name service: see DNS.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;donkeys: <a href="#indexId434909-161">7.3</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">EAGAIN</tt>: <a href="#indexId434909-145">7.1</a>, <a href="#indexId434909-147">7.1</a>, <a href="#indexId434909-314">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;email to Beej: <a href="#indexId434909-18">1.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encryption: <a href="#indexId434909-203">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">EPIPE</tt>: <a href="#indexId434909-236">9.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i><tt class="var">errno</tt></i>: <a href="#indexId434909-251">9.10</a>, <a href="#indexId434909-275">9.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ethernet: <a href="#indexId434909-52">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">EWOULDBLOCK</tt>: <a href="#indexId434909-146">7.1</a>, <a href="#indexId434909-148">7.1</a>, <a href="#indexId434909-228">9.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Excalibur: <a href="#indexId434909-171">7.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;external data representation standard: see XDR.<br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">F_SETFL</tt>: <a href="#indexId434909-255">9.11</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">fcntl()</tt></b>: <a href="#indexId434909-144">7.1</a>, <a href="#indexId434909-227">9.1</a>, <a href="#indexId434909-254">9.11</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_CLR()</tt></b>: <a href="#indexId434909-152">7.2</a>, <a href="#indexId434909-291">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_ISSET()</tt></b>: <a href="#indexId434909-153">7.2</a>, <a href="#indexId434909-292">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_SET()</tt></b>: <a href="#indexId434909-151">7.2</a>, <a href="#indexId434909-290">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">FD_ZERO()</tt></b>: <a href="#indexId434909-154">7.2</a>, <a href="#indexId434909-293">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file descriptor: <a href="#indexId434909-22">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firewall: <a href="#indexId434909-83">3.4.1</a>, <a href="#indexId434909-178">7.6</a>, <a href="#indexId434909-213">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;poking holes in: <a href="#indexId434909-214">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;footer: <a href="#indexId434909-48">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">fork()</tt></b>: <a href="#indexId434909-15">1.5</a>, <a href="#indexId434909-133">6.0</a>, <a href="#indexId434909-211">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FTP: <a href="#indexId434909-338">10.3</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getaddrinfo()</tt></b>: <a href="#indexId434909-68">3.3</a>, <a href="#indexId434909-89">4.0</a>, <a href="#indexId434909-91">5.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gethostbyaddr()</tt></b>: <a href="#indexId434909-128">5.10</a>, <a href="#indexId434909-243">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gethostbyname()</tt></b>: <a href="#indexId434909-130">5.11</a>, <a href="#indexId434909-240">9.6</a>, <a href="#indexId434909-242">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gethostname()</tt></b>: <a href="#indexId434909-129">5.11</a>, <a href="#indexId434909-239">9.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getnameinfo()</tt></b>: <a href="#indexId434909-90">4.0</a>, <a href="#indexId434909-127">5.10</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getpeername()</tt></b>: <a href="#indexId434909-125">5.10</a>, <a href="#indexId434909-248">9.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getprotobyname()</tt></b>: <a href="#indexId434909-326">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">getsockopt()</tt></b>: <a href="#indexId434909-295">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">gettimeofday()</tt></b>: <a href="#indexId434909-156">7.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goat: <a href="#indexId434909-192">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="tt">goto</tt>: <a href="#indexId434909-199">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header: <a href="#indexId434909-47">2.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;header files: <a href="#indexId434909-181">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">herror()</tt></b>: <a href="#indexId434909-246">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">hstrerror()</tt></b>: <a href="#indexId434909-247">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">htonl()</tt></b>: <a href="#indexId434909-63">3.2</a>, <a href="#indexId434909-260">9.12</a>, <a href="#indexId434909-265">9.12</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">htons()</tt></b>: <a href="#indexId434909-62">3.2</a>, <a href="#indexId434909-74">3.3</a>, <a href="#indexId434909-166">7.4</a>, <a href="#indexId434909-259">9.12</a>, <a href="#indexId434909-264">9.12</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP: <a href="#indexId434909-342">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTP protocol: <a href="#indexId434909-40">2.1</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ICMP: <a href="#indexId434909-195">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IEEE-754: <a href="#indexId434909-168">7.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">INADDR_ANY</tt>: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">INADDR_BROADCAST</tt>: <a href="#indexId434909-177">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_addr()</tt></b>: <a href="#indexId434909-78">3.4</a>, <a href="#indexId434909-270">9.13</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_aton()</tt></b>: <a href="#indexId434909-79">3.4</a>, <a href="#indexId434909-269">9.13</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_ntoa()</tt></b>: <a href="#indexId434909-81">3.4</a>, <a href="#indexId434909-268">9.13</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_ntoa()</tt></b>: <a href="#indexId434909-80">3.4</a>, <a href="#indexId434909-126">5.10</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">inet_pton()</tt></b>: <a href="#indexId434909-77">3.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internet Control Message Protocol: see ICMP.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internet protocol: see IP.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Internet Relay Chat: see IRC.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ioctl(): <a href="#indexId434909-217">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP: <a href="#indexId434909-42">2.1</a>, <a href="#indexId434909-51">2.2</a>, <a href="#indexId434909-57">3.0</a>, <a href="#indexId434909-76">3.4</a>, <a href="#indexId434909-98">5.3</a>, <a href="#indexId434909-115">5.8</a>, <a href="#indexId434909-131">5.11</a>, <a href="#indexId434909-335">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP address: <a href="#indexId434909-230">9.2</a>, <a href="#indexId434909-241">9.6</a>, <a href="#indexId434909-244">9.7</a>, <a href="#indexId434909-249">9.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IPv4: <a href="#indexId434909-58">3.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IPv6: <a href="#indexId434909-60">3.1</a>, <a href="#indexId434909-75">3.3</a>, <a href="#indexId434909-87">3.4.1</a>, <a href="#indexId434909-88">4.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IRC: <a href="#indexId434909-165">7.4</a>, <a href="#indexId434909-340">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISO/OSI: <a href="#indexId434909-53">2.2</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;layered network model: see ISO/OSI.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux: <a href="#indexId434909-6">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">listen()</tt></b>: <a href="#indexId434909-96">5.3</a>, <a href="#indexId434909-108">5.5</a>, <a href="#indexId434909-272">9.15</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backlog: <a href="#indexId434909-110">5.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with select(): <a href="#indexId434909-158">7.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="tt">lo</tt>: see loopback device.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localhost: <a href="#indexId434909-193">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loopback device: <a href="#indexId434909-191">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">man</b> pages: <a href="#indexId434909-222">9.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum Transmission Unit: see MTU.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mirroring: <a href="#indexId434909-19">1.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_DONTROUTE</tt>: <a href="#indexId434909-312">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_DONTWAIT</tt>: <a href="#indexId434909-313">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_NOSIGNAL</tt>: <a href="#indexId434909-316">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_OOB</tt>: <a href="#indexId434909-283">9.18</a>, <a href="#indexId434909-309">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_PEEK</tt>: <a href="#indexId434909-286">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">MSG_WAITALL</tt>: <a href="#indexId434909-287">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MTU: <a href="#indexId434909-210">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NAT: <a href="#indexId434909-84">3.4.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">netstat</b>: <a href="#indexId434909-188">8.0</a>, <a href="#indexId434909-190">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;network address translation: see NAT.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NNTP: <a href="#indexId434909-345">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-blocking sockets: <a href="#indexId434909-143">7.1</a>, <a href="#indexId434909-163">7.3</a>, <a href="#indexId434909-226">9.1</a>, <a href="#indexId434909-256">9.11</a>, <a href="#indexId434909-294">9.19</a>, <a href="#indexId434909-315">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">ntohl()</tt></b>: <a href="#indexId434909-65">3.2</a>, <a href="#indexId434909-262">9.12</a>, <a href="#indexId434909-267">9.12</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">ntohs()</tt></b>: <a href="#indexId434909-64">3.2</a>, <a href="#indexId434909-261">9.12</a>, <a href="#indexId434909-266">9.12</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">O_ASYNC</tt>: see asynchronous I/O.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">O_NONBLOCK</tt>: see non-blocking sockets.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenSSL: <a href="#indexId434909-205">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out-of-band data: <a href="#indexId434909-284">9.18</a>, <a href="#indexId434909-310">9.21</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;packet sniffer: <a href="#indexId434909-215">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pat: <a href="#indexId434909-179">7.6</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">perror()</tt></b>: <a href="#indexId434909-252">9.10</a>, <a href="#indexId434909-273">9.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">PF_INET</tt>: <a href="#indexId434909-207">8.0</a>, <a href="#indexId434909-320">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ping: <a href="#indexId434909-194">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">poll()</tt></b>: <a href="#indexId434909-159">7.2</a>, <a href="#indexId434909-276">9.17</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port: <a href="#indexId434909-116">5.8</a>, <a href="#indexId434909-231">9.2</a>, <a href="#indexId434909-250">9.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ports: <a href="#indexId434909-95">5.3</a>, <a href="#indexId434909-99">5.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private network: <a href="#indexId434909-82">3.4.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promiscuous mode: <a href="#indexId434909-216">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raw sockets: <a href="#indexId434909-33">2.1</a>, <a href="#indexId434909-196">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">read()</tt></b>: <a href="#indexId434909-27">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">recv()</tt></b>: <a href="#indexId434909-26">2.0</a>, <a href="#indexId434909-30">2.0</a>, <a href="#indexId434909-113">5.7</a>, <a href="#indexId434909-278">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout: <a href="#indexId434909-200">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">recvfrom()</tt></b>: <a href="#indexId434909-117">5.8</a>, <a href="#indexId434909-279">9.18</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">recvtimeout()</tt></b>: <a href="#indexId434909-202">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;references: <a href="#indexId434909-331">10.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;web-based: <a href="#indexId434909-332">10.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RFCs: <a href="#indexId434909-333">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">route</b>: <a href="#indexId434909-189">8.0</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SA_RESTART</tt>: <a href="#indexId434909-198">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Secure Sockets Layer: see SSL.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;security: <a href="#indexId434909-209">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">select()</tt></b>: <a href="#indexId434909-12">1.5</a>, <a href="#indexId434909-149">7.1</a>, <a href="#indexId434909-150">7.2</a>, <a href="#indexId434909-187">8.0</a>, <a href="#indexId434909-201">8.0</a>, <a href="#indexId434909-288">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with listen(): <a href="#indexId434909-157">7.2</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">send()</tt></b>: <a href="#indexId434909-25">2.0</a>, <a href="#indexId434909-29">2.0</a>, <a href="#indexId434909-54">2.2</a>, <a href="#indexId434909-112">5.7</a>, <a href="#indexId434909-305">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">sendall()</tt></b>: <a href="#indexId434909-160">7.3</a>, <a href="#indexId434909-170">7.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">sendto()</tt></b>: <a href="#indexId434909-55">2.2</a>, <a href="#indexId434909-306">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;serialization: <a href="#indexId434909-164">7.4</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datagram: <a href="#indexId434909-139">6.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream: <a href="#indexId434909-134">6.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">setsockopt()</tt></b>: <a href="#indexId434909-101">5.3</a>, <a href="#indexId434909-174">7.6</a>, <a href="#indexId434909-184">8.0</a>, <a href="#indexId434909-221">8.0</a>, <a href="#indexId434909-296">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">shutdown()</tt></b>: <a href="#indexId434909-121">5.9</a>, <a href="#indexId434909-318">9.22</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">sigaction()</tt></b>: <a href="#indexId434909-135">6.1</a>, <a href="#indexId434909-197">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SIGIO</tt>: <a href="#indexId434909-258">9.11</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SIGPIPE</tt>: <a href="#indexId434909-235">9.4</a>, <a href="#indexId434909-317">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SIGURG</tt>: <a href="#indexId434909-285">9.18</a>, <a href="#indexId434909-311">9.21</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SMTP: <a href="#indexId434909-343">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_BINDTODEVICE</tt>: <a href="#indexId434909-298">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_BROADCAST</tt>: <a href="#indexId434909-175">7.6</a>, <a href="#indexId434909-300">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_RCVTIMEO</tt>: <a href="#indexId434909-219">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_REUSEADDR</tt>: <a href="#indexId434909-102">5.3</a>, <a href="#indexId434909-185">8.0</a>, <a href="#indexId434909-299">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SO_SNDTIMEO</tt>: <a href="#indexId434909-220">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SOCK_DGRAM</tt>: see socket;datagram.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOCK_RAW: <a href="#indexId434909-325">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SOCK_STREAM</tt>: see socket;stream.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket: <a href="#indexId434909-21">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datagram: <a href="#indexId434909-36">2.1</a>, <a href="#indexId434909-43">2.1</a>, <a href="#indexId434909-45">2.2</a>, <a href="#indexId434909-114">5.8</a>, <a href="#indexId434909-281">9.18</a>, <a href="#indexId434909-301">9.20</a>, <a href="#indexId434909-308">9.21</a>, <a href="#indexId434909-323">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;raw: <a href="#indexId434909-34">2.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream: <a href="#indexId434909-35">2.1</a>, <a href="#indexId434909-38">2.1</a>, <a href="#indexId434909-224">9.1</a>, <a href="#indexId434909-280">9.18</a>, <a href="#indexId434909-307">9.21</a>, <a href="#indexId434909-321">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types: <a href="#indexId434909-31">2.0</a>, <a href="#indexId434909-32">2.1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket descriptor: <a href="#indexId434909-24">2.0</a>, <a href="#indexId434909-66">3.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">socket()</tt></b>: <a href="#indexId434909-23">2.0</a>, <a href="#indexId434909-92">5.2</a>, <a href="#indexId434909-319">9.23</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt class="const">SOL_SOCKET</tt>: <a href="#indexId434909-297">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solaris: <a href="#indexId434909-3">1.4</a>, <a href="#indexId434909-303">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL: <a href="#indexId434909-204">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">strerror()</tt></b>: <a href="#indexId434909-253">9.10</a>, <a href="#indexId434909-274">9.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct addrinfo</tt></nobr>: <a href="#indexId434909-67">3.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct hostent</tt></nobr>: <a href="#indexId434909-245">9.7</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct in_addr</tt></nobr>: <a href="#indexId434909-328">9.24</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct pollfd</tt></nobr>: <a href="#indexId434909-277">9.17</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct sockaddr</tt></nobr>: <a href="#indexId434909-69">3.3</a>, <a href="#indexId434909-118">5.8</a>, <a href="#indexId434909-282">9.18</a>, <a href="#indexId434909-329">9.24</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct sockaddr_in</tt></nobr>: <a href="#indexId434909-72">3.3</a>, <a href="#indexId434909-225">9.1</a>, <a href="#indexId434909-327">9.24</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<nobr><tt class="type">struct timeval</tt></nobr>: <a href="#indexId434909-155">7.2</a>, <a href="#indexId434909-289">9.19</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SunOS: <a href="#indexId434909-4">1.4</a>, <a href="#indexId434909-302">9.20</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP: <a href="#indexId434909-41">2.1</a>, <a href="#indexId434909-322">9.23</a>, <a href="#indexId434909-336">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b class="com">gcc</b>: <a href="#indexId434909-39">2.1</a>, <a href="#indexId434909-337">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TFTP: <a href="#indexId434909-49">2.2</a>, <a href="#indexId434909-339">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timeout, setting: <a href="#indexId434909-218">8.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;translations: <a href="#indexId434909-20">1.8</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transmission control protocol: see TCP.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TRON: <a href="#indexId434909-106">5.4</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UDP: <a href="#indexId434909-44">2.1</a>, <a href="#indexId434909-50">2.2</a>, <a href="#indexId434909-172">7.6</a>, <a href="#indexId434909-324">9.23</a>, <a href="#indexId434909-334">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user datagram protocol: see UDP.<br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vint Cerf: <a href="#indexId434909-59">3.1</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows: <a href="#indexId434909-5">1.5</a>, <a href="#indexId434909-122">5.9</a>, <a href="#indexId434909-182">8.0</a>, <a href="#indexId434909-237">9.4</a>, <a href="#indexId434909-304">9.20</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Winsock: <a href="#indexId434909-8">1.5</a>, <a href="#indexId434909-123">5.9</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Winsock FAQ: <a href="#indexId434909-14">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">write()</tt></b>: <a href="#indexId434909-28">2.0</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">WSACleanup()</tt></b>: <a href="#indexId434909-10">1.5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt class="func">WSAStartup()</tt></b>: <a href="#indexId434909-9">1.5</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XDR: <a href="#indexId434909-169">7.4</a>, <a href="#indexId434909-346">10.3</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XMPP: <a href="#indexId434909-344">10.3</a><br>
</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zombie process: <a href="#indexId434909-136">6.1</a><br>
</p><p>



</p><iframe width="0" height="0" frameborder="0" src="about:blank" id="GINGER_SOFATWARE_contextMenuIFrame" scrolling="no" style="border: 0px solid; z-index: 2147483647; height: 0px; width: 0px; background-color: transparent;"></iframe><iframe width="0" height="0" frameborder="0" src="about:blank" id="GINGER_SOFATWARE_bubblesIFrame" scrolling="no" style="border: 0px solid; position: absolute; z-index: 2147483647; height: 0px; width: 0px; background-color: transparent;"></iframe><div id="GingerWidgetInfo" style="display:none;">{"version":"0.1.0.33","isExtension":true,"extensionName":"Safari"}</div></body></html>UUTF-8         %   7   I   L   O   Z   q   Ä   í   ®   ∆   È   ı  (¬  (Ã  (“  (◊  (⁄  („  (˘  )-  ,˚ …Ñ …í …õ œi ◊. €y €É €é €± €Ω ˆÖ ˆã ˆè ˆò ˆ÷ ˚M † © ≤ ˛ % æ «  !, >Â > >Ò ?0 „⁄             6             „‡